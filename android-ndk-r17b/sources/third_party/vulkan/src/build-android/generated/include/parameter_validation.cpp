/* *** THIS FILE IS GENERATED - DO NOT EDIT! ***
 * See parameter_validation_generator.py for modifications
 *
 * Copyright (c) 2015-2017 The Khronos Group Inc.
 * Copyright (c) 2015-2017 LunarG, Inc.
 * Copyright (C) 2015-2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * Copyright (c) 2015-2017 Valve Corporation
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Author: Mark Lobodzinski <mark@LunarG.com>
 */


#include <string>

#include "vk_loader_platform.h"
#include "vulkan/vulkan.h"
#include "vk_layer_extension_utils.h"
#include "parameter_validation.h"

#ifndef UNUSED_PARAMETER
#define UNUSED_PARAMETER(x) (void)(x)
#endif // UNUSED_PARAMETER

namespace parameter_validation {

extern std::mutex global_lock;
extern std::unordered_map<void *, layer_data *> layer_data_map;
extern std::unordered_map<void *, instance_layer_data *> instance_layer_data_map;

const uint32_t GeneratedHeaderVersion = 69;

const VkAccessFlags AllVkAccessFlagBits = VK_ACCESS_INDIRECT_COMMAND_READ_BIT|VK_ACCESS_INDEX_READ_BIT|VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT|VK_ACCESS_UNIFORM_READ_BIT|VK_ACCESS_INPUT_ATTACHMENT_READ_BIT|VK_ACCESS_SHADER_READ_BIT|VK_ACCESS_SHADER_WRITE_BIT|VK_ACCESS_COLOR_ATTACHMENT_READ_BIT|VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT|VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT|VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT|VK_ACCESS_TRANSFER_READ_BIT|VK_ACCESS_TRANSFER_WRITE_BIT|VK_ACCESS_HOST_READ_BIT|VK_ACCESS_HOST_WRITE_BIT|VK_ACCESS_MEMORY_READ_BIT|VK_ACCESS_MEMORY_WRITE_BIT|VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX|VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX|VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
const VkAttachmentDescriptionFlags AllVkAttachmentDescriptionFlagBits = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT;
const VkBufferCreateFlags AllVkBufferCreateFlagBits = VK_BUFFER_CREATE_SPARSE_BINDING_BIT|VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT|VK_BUFFER_CREATE_SPARSE_ALIASED_BIT;
const VkBufferUsageFlags AllVkBufferUsageFlagBits = VK_BUFFER_USAGE_TRANSFER_SRC_BIT|VK_BUFFER_USAGE_TRANSFER_DST_BIT|VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT|VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT|VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT|VK_BUFFER_USAGE_STORAGE_BUFFER_BIT|VK_BUFFER_USAGE_INDEX_BUFFER_BIT|VK_BUFFER_USAGE_VERTEX_BUFFER_BIT|VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT;
const VkColorComponentFlags AllVkColorComponentFlagBits = VK_COLOR_COMPONENT_R_BIT|VK_COLOR_COMPONENT_G_BIT|VK_COLOR_COMPONENT_B_BIT|VK_COLOR_COMPONENT_A_BIT;
const VkCommandBufferResetFlags AllVkCommandBufferResetFlagBits = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT;
const VkCommandBufferUsageFlags AllVkCommandBufferUsageFlagBits = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT|VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT|VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
const VkCommandPoolCreateFlags AllVkCommandPoolCreateFlagBits = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT|VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
const VkCommandPoolResetFlags AllVkCommandPoolResetFlagBits = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT;
const VkCullModeFlags AllVkCullModeFlagBits = VK_CULL_MODE_NONE|VK_CULL_MODE_FRONT_BIT|VK_CULL_MODE_BACK_BIT|VK_CULL_MODE_FRONT_AND_BACK;
const VkDependencyFlags AllVkDependencyFlagBits = VK_DEPENDENCY_BY_REGION_BIT|VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX|VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX;
const VkDescriptorPoolCreateFlags AllVkDescriptorPoolCreateFlagBits = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
const VkDescriptorSetLayoutCreateFlags AllVkDescriptorSetLayoutCreateFlagBits = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR;
const VkFenceCreateFlags AllVkFenceCreateFlagBits = VK_FENCE_CREATE_SIGNALED_BIT;
const VkFormatFeatureFlags AllVkFormatFeatureFlagBits = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT|VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT|VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT|VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT|VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT|VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT|VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT|VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT|VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT|VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT|VK_FORMAT_FEATURE_BLIT_SRC_BIT|VK_FORMAT_FEATURE_BLIT_DST_BIT|VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT|VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG|VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR|VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR|VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT|VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR|VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR|VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR|VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR|VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR|VK_FORMAT_FEATURE_DISJOINT_BIT_KHR|VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR;
const VkImageAspectFlags AllVkImageAspectFlagBits = VK_IMAGE_ASPECT_COLOR_BIT|VK_IMAGE_ASPECT_DEPTH_BIT|VK_IMAGE_ASPECT_STENCIL_BIT|VK_IMAGE_ASPECT_METADATA_BIT|VK_IMAGE_ASPECT_PLANE_0_BIT_KHR|VK_IMAGE_ASPECT_PLANE_1_BIT_KHR|VK_IMAGE_ASPECT_PLANE_2_BIT_KHR;
const VkImageCreateFlags AllVkImageCreateFlagBits = VK_IMAGE_CREATE_SPARSE_BINDING_BIT|VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT|VK_IMAGE_CREATE_SPARSE_ALIASED_BIT|VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT|VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT|VK_IMAGE_CREATE_BIND_SFR_BIT_KHX|VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR|VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR|VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR|VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT|VK_IMAGE_CREATE_DISJOINT_BIT_KHR|VK_IMAGE_CREATE_ALIAS_BIT_KHR;
const VkImageUsageFlags AllVkImageUsageFlagBits = VK_IMAGE_USAGE_TRANSFER_SRC_BIT|VK_IMAGE_USAGE_TRANSFER_DST_BIT|VK_IMAGE_USAGE_SAMPLED_BIT|VK_IMAGE_USAGE_STORAGE_BIT|VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT|VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT|VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT|VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT;
const VkMemoryHeapFlags AllVkMemoryHeapFlagBits = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT|VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX;
const VkMemoryPropertyFlags AllVkMemoryPropertyFlagBits = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT|VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT|VK_MEMORY_PROPERTY_HOST_CACHED_BIT|VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
const VkPipelineCreateFlags AllVkPipelineCreateFlagBits = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT|VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT|VK_PIPELINE_CREATE_DERIVATIVE_BIT|VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX|VK_PIPELINE_CREATE_DISPATCH_BASE_KHX;
const VkPipelineStageFlags AllVkPipelineStageFlagBits = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT|VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT|VK_PIPELINE_STAGE_VERTEX_INPUT_BIT|VK_PIPELINE_STAGE_VERTEX_SHADER_BIT|VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT|VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT|VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT|VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT|VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT|VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT|VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT|VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT|VK_PIPELINE_STAGE_TRANSFER_BIT|VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT|VK_PIPELINE_STAGE_HOST_BIT|VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT|VK_PIPELINE_STAGE_ALL_COMMANDS_BIT|VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX;
const VkQueryControlFlags AllVkQueryControlFlagBits = VK_QUERY_CONTROL_PRECISE_BIT;
const VkQueryPipelineStatisticFlags AllVkQueryPipelineStatisticFlagBits = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT|VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT|VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT|VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT|VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT|VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT|VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT|VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT|VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT|VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT|VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT;
const VkQueryResultFlags AllVkQueryResultFlagBits = VK_QUERY_RESULT_64_BIT|VK_QUERY_RESULT_WAIT_BIT|VK_QUERY_RESULT_WITH_AVAILABILITY_BIT|VK_QUERY_RESULT_PARTIAL_BIT;
const VkQueueFlags AllVkQueueFlagBits = VK_QUEUE_GRAPHICS_BIT|VK_QUEUE_COMPUTE_BIT|VK_QUEUE_TRANSFER_BIT|VK_QUEUE_SPARSE_BINDING_BIT;
const VkSampleCountFlags AllVkSampleCountFlagBits = VK_SAMPLE_COUNT_1_BIT|VK_SAMPLE_COUNT_2_BIT|VK_SAMPLE_COUNT_4_BIT|VK_SAMPLE_COUNT_8_BIT|VK_SAMPLE_COUNT_16_BIT|VK_SAMPLE_COUNT_32_BIT|VK_SAMPLE_COUNT_64_BIT;
const VkShaderStageFlags AllVkShaderStageFlagBits = VK_SHADER_STAGE_VERTEX_BIT|VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT|VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT|VK_SHADER_STAGE_GEOMETRY_BIT|VK_SHADER_STAGE_FRAGMENT_BIT|VK_SHADER_STAGE_COMPUTE_BIT|VK_SHADER_STAGE_ALL_GRAPHICS|VK_SHADER_STAGE_ALL;
const VkSparseImageFormatFlags AllVkSparseImageFormatFlagBits = VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT|VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT|VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT;
const VkSparseMemoryBindFlags AllVkSparseMemoryBindFlagBits = VK_SPARSE_MEMORY_BIND_METADATA_BIT;
const VkStencilFaceFlags AllVkStencilFaceFlagBits = VK_STENCIL_FACE_FRONT_BIT|VK_STENCIL_FACE_BACK_BIT|VK_STENCIL_FRONT_AND_BACK;
const VkSubpassDescriptionFlags AllVkSubpassDescriptionFlagBits = VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX|VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX;
const VkCompositeAlphaFlagsKHR AllVkCompositeAlphaFlagBitsKHR = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR|VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR|VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR|VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
const VkSurfaceTransformFlagsKHR AllVkSurfaceTransformFlagBitsKHR = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR|VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR|VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR|VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR|VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR|VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR|VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR|VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR|VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR;
const VkSwapchainCreateFlagsKHR AllVkSwapchainCreateFlagBitsKHR = VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX;
const VkDisplayPlaneAlphaFlagsKHR AllVkDisplayPlaneAlphaFlagBitsKHR = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR|VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR|VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR|VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR;
const VkExternalMemoryFeatureFlagsKHR AllVkExternalMemoryFeatureFlagBitsKHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR|VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR|VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR;
const VkExternalMemoryHandleTypeFlagsKHR AllVkExternalMemoryHandleTypeFlagBitsKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR|VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR|VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR|VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR|VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR|VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR|VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR|VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT|VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT|VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
const VkExternalSemaphoreFeatureFlagsKHR AllVkExternalSemaphoreFeatureFlagBitsKHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR|VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR;
const VkExternalSemaphoreHandleTypeFlagsKHR AllVkExternalSemaphoreHandleTypeFlagBitsKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR|VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR|VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR|VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR|VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
const VkSemaphoreImportFlagsKHR AllVkSemaphoreImportFlagBitsKHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR;
const VkExternalFenceFeatureFlagsKHR AllVkExternalFenceFeatureFlagBitsKHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR|VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR;
const VkExternalFenceHandleTypeFlagsKHR AllVkExternalFenceHandleTypeFlagBitsKHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR|VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR|VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR|VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
const VkFenceImportFlagsKHR AllVkFenceImportFlagBitsKHR = VK_FENCE_IMPORT_TEMPORARY_BIT_KHR;
const VkDebugReportFlagsEXT AllVkDebugReportFlagBitsEXT = VK_DEBUG_REPORT_INFORMATION_BIT_EXT|VK_DEBUG_REPORT_WARNING_BIT_EXT|VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT|VK_DEBUG_REPORT_ERROR_BIT_EXT|VK_DEBUG_REPORT_DEBUG_BIT_EXT;
const VkExternalMemoryFeatureFlagsNV AllVkExternalMemoryFeatureFlagBitsNV = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV|VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV|VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV;
const VkExternalMemoryHandleTypeFlagsNV AllVkExternalMemoryHandleTypeFlagBitsNV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV|VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV|VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV|VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV;
const VkDeviceGroupPresentModeFlagsKHX AllVkDeviceGroupPresentModeFlagBitsKHX = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX|VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX|VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX|VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX;
const VkMemoryAllocateFlagsKHX AllVkMemoryAllocateFlagBitsKHX = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX;
const VkPeerMemoryFeatureFlagsKHX AllVkPeerMemoryFeatureFlagBitsKHX = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX|VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX|VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX|VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX;
const VkIndirectCommandsLayoutUsageFlagsNVX AllVkIndirectCommandsLayoutUsageFlagBitsNVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX|VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX|VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX|VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX;
const VkObjectEntryUsageFlagsNVX AllVkObjectEntryUsageFlagBitsNVX = VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX|VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX;
const VkSurfaceCounterFlagsEXT AllVkSurfaceCounterFlagBitsEXT = VK_SURFACE_COUNTER_VBLANK_EXT;

const std::vector<VkPipelineCacheHeaderVersion> AllVkPipelineCacheHeaderVersionEnums = {VK_PIPELINE_CACHE_HEADER_VERSION_ONE, };
const std::vector<VkResult> AllVkResultEnums = {VK_SUCCESS, VK_NOT_READY, VK_TIMEOUT, VK_EVENT_SET, VK_EVENT_RESET, VK_INCOMPLETE, VK_ERROR_OUT_OF_HOST_MEMORY, VK_ERROR_OUT_OF_DEVICE_MEMORY, VK_ERROR_INITIALIZATION_FAILED, VK_ERROR_DEVICE_LOST, VK_ERROR_MEMORY_MAP_FAILED, VK_ERROR_LAYER_NOT_PRESENT, VK_ERROR_EXTENSION_NOT_PRESENT, VK_ERROR_FEATURE_NOT_PRESENT, VK_ERROR_INCOMPATIBLE_DRIVER, VK_ERROR_TOO_MANY_OBJECTS, VK_ERROR_FORMAT_NOT_SUPPORTED, VK_ERROR_FRAGMENTED_POOL, VK_ERROR_SURFACE_LOST_KHR, VK_ERROR_NATIVE_WINDOW_IN_USE_KHR, VK_SUBOPTIMAL_KHR, VK_ERROR_OUT_OF_DATE_KHR, VK_ERROR_INCOMPATIBLE_DISPLAY_KHR, VK_ERROR_VALIDATION_FAILED_EXT, VK_ERROR_INVALID_SHADER_NV, VK_ERROR_OUT_OF_POOL_MEMORY_KHR, VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR, VK_ERROR_NOT_PERMITTED_EXT, };
const std::vector<VkSystemAllocationScope> AllVkSystemAllocationScopeEnums = {VK_SYSTEM_ALLOCATION_SCOPE_COMMAND, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT, VK_SYSTEM_ALLOCATION_SCOPE_CACHE, VK_SYSTEM_ALLOCATION_SCOPE_DEVICE, VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE, };
const std::vector<VkInternalAllocationType> AllVkInternalAllocationTypeEnums = {VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE, };
const std::vector<VkFormat> AllVkFormatEnums = {VK_FORMAT_UNDEFINED, VK_FORMAT_R4G4_UNORM_PACK8, VK_FORMAT_R4G4B4A4_UNORM_PACK16, VK_FORMAT_B4G4R4A4_UNORM_PACK16, VK_FORMAT_R5G6B5_UNORM_PACK16, VK_FORMAT_B5G6R5_UNORM_PACK16, VK_FORMAT_R5G5B5A1_UNORM_PACK16, VK_FORMAT_B5G5R5A1_UNORM_PACK16, VK_FORMAT_A1R5G5B5_UNORM_PACK16, VK_FORMAT_R8_UNORM, VK_FORMAT_R8_SNORM, VK_FORMAT_R8_USCALED, VK_FORMAT_R8_SSCALED, VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SNORM, VK_FORMAT_R8G8_USCALED, VK_FORMAT_R8G8_SSCALED, VK_FORMAT_R8G8_UINT, VK_FORMAT_R8G8_SINT, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R8G8B8_UNORM, VK_FORMAT_R8G8B8_SNORM, VK_FORMAT_R8G8B8_USCALED, VK_FORMAT_R8G8B8_SSCALED, VK_FORMAT_R8G8B8_UINT, VK_FORMAT_R8G8B8_SINT, VK_FORMAT_R8G8B8_SRGB, VK_FORMAT_B8G8R8_UNORM, VK_FORMAT_B8G8R8_SNORM, VK_FORMAT_B8G8R8_USCALED, VK_FORMAT_B8G8R8_SSCALED, VK_FORMAT_B8G8R8_UINT, VK_FORMAT_B8G8R8_SINT, VK_FORMAT_B8G8R8_SRGB, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SNORM, VK_FORMAT_R8G8B8A8_USCALED, VK_FORMAT_R8G8B8A8_SSCALED, VK_FORMAT_R8G8B8A8_UINT, VK_FORMAT_R8G8B8A8_SINT, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_B8G8R8A8_SNORM, VK_FORMAT_B8G8R8A8_USCALED, VK_FORMAT_B8G8R8A8_SSCALED, VK_FORMAT_B8G8R8A8_UINT, VK_FORMAT_B8G8R8A8_SINT, VK_FORMAT_B8G8R8A8_SRGB, VK_FORMAT_A8B8G8R8_UNORM_PACK32, VK_FORMAT_A8B8G8R8_SNORM_PACK32, VK_FORMAT_A8B8G8R8_USCALED_PACK32, VK_FORMAT_A8B8G8R8_SSCALED_PACK32, VK_FORMAT_A8B8G8R8_UINT_PACK32, VK_FORMAT_A8B8G8R8_SINT_PACK32, VK_FORMAT_A8B8G8R8_SRGB_PACK32, VK_FORMAT_A2R10G10B10_UNORM_PACK32, VK_FORMAT_A2R10G10B10_SNORM_PACK32, VK_FORMAT_A2R10G10B10_USCALED_PACK32, VK_FORMAT_A2R10G10B10_SSCALED_PACK32, VK_FORMAT_A2R10G10B10_UINT_PACK32, VK_FORMAT_A2R10G10B10_SINT_PACK32, VK_FORMAT_A2B10G10R10_UNORM_PACK32, VK_FORMAT_A2B10G10R10_SNORM_PACK32, VK_FORMAT_A2B10G10R10_USCALED_PACK32, VK_FORMAT_A2B10G10R10_SSCALED_PACK32, VK_FORMAT_A2B10G10R10_UINT_PACK32, VK_FORMAT_A2B10G10R10_SINT_PACK32, VK_FORMAT_R16_UNORM, VK_FORMAT_R16_SNORM, VK_FORMAT_R16_USCALED, VK_FORMAT_R16_SSCALED, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R16G16_UNORM, VK_FORMAT_R16G16_SNORM, VK_FORMAT_R16G16_USCALED, VK_FORMAT_R16G16_SSCALED, VK_FORMAT_R16G16_UINT, VK_FORMAT_R16G16_SINT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R16G16B16_UNORM, VK_FORMAT_R16G16B16_SNORM, VK_FORMAT_R16G16B16_USCALED, VK_FORMAT_R16G16B16_SSCALED, VK_FORMAT_R16G16B16_UINT, VK_FORMAT_R16G16B16_SINT, VK_FORMAT_R16G16B16_SFLOAT, VK_FORMAT_R16G16B16A16_UNORM, VK_FORMAT_R16G16B16A16_SNORM, VK_FORMAT_R16G16B16A16_USCALED, VK_FORMAT_R16G16B16A16_SSCALED, VK_FORMAT_R16G16B16A16_UINT, VK_FORMAT_R16G16B16A16_SINT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R32_UINT, VK_FORMAT_R32_SINT, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R32G32_UINT, VK_FORMAT_R32G32_SINT, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R32G32B32_UINT, VK_FORMAT_R32G32B32_SINT, VK_FORMAT_R32G32B32_SFLOAT, VK_FORMAT_R32G32B32A32_UINT, VK_FORMAT_R32G32B32A32_SINT, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R64_UINT, VK_FORMAT_R64_SINT, VK_FORMAT_R64_SFLOAT, VK_FORMAT_R64G64_UINT, VK_FORMAT_R64G64_SINT, VK_FORMAT_R64G64_SFLOAT, VK_FORMAT_R64G64B64_UINT, VK_FORMAT_R64G64B64_SINT, VK_FORMAT_R64G64B64_SFLOAT, VK_FORMAT_R64G64B64A64_UINT, VK_FORMAT_R64G64B64A64_SINT, VK_FORMAT_R64G64B64A64_SFLOAT, VK_FORMAT_B10G11R11_UFLOAT_PACK32, VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, VK_FORMAT_D16_UNORM, VK_FORMAT_X8_D24_UNORM_PACK32, VK_FORMAT_D32_SFLOAT, VK_FORMAT_S8_UINT, VK_FORMAT_D16_UNORM_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_BC1_RGB_UNORM_BLOCK, VK_FORMAT_BC1_RGB_SRGB_BLOCK, VK_FORMAT_BC1_RGBA_UNORM_BLOCK, VK_FORMAT_BC1_RGBA_SRGB_BLOCK, VK_FORMAT_BC2_UNORM_BLOCK, VK_FORMAT_BC2_SRGB_BLOCK, VK_FORMAT_BC3_UNORM_BLOCK, VK_FORMAT_BC3_SRGB_BLOCK, VK_FORMAT_BC4_UNORM_BLOCK, VK_FORMAT_BC4_SNORM_BLOCK, VK_FORMAT_BC5_UNORM_BLOCK, VK_FORMAT_BC5_SNORM_BLOCK, VK_FORMAT_BC6H_UFLOAT_BLOCK, VK_FORMAT_BC6H_SFLOAT_BLOCK, VK_FORMAT_BC7_UNORM_BLOCK, VK_FORMAT_BC7_SRGB_BLOCK, VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, VK_FORMAT_EAC_R11_UNORM_BLOCK, VK_FORMAT_EAC_R11_SNORM_BLOCK, VK_FORMAT_EAC_R11G11_UNORM_BLOCK, VK_FORMAT_EAC_R11G11_SNORM_BLOCK, VK_FORMAT_ASTC_4x4_UNORM_BLOCK, VK_FORMAT_ASTC_4x4_SRGB_BLOCK, VK_FORMAT_ASTC_5x4_UNORM_BLOCK, VK_FORMAT_ASTC_5x4_SRGB_BLOCK, VK_FORMAT_ASTC_5x5_UNORM_BLOCK, VK_FORMAT_ASTC_5x5_SRGB_BLOCK, VK_FORMAT_ASTC_6x5_UNORM_BLOCK, VK_FORMAT_ASTC_6x5_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_8x5_UNORM_BLOCK, VK_FORMAT_ASTC_8x5_SRGB_BLOCK, VK_FORMAT_ASTC_8x6_UNORM_BLOCK, VK_FORMAT_ASTC_8x6_SRGB_BLOCK, VK_FORMAT_ASTC_8x8_UNORM_BLOCK, VK_FORMAT_ASTC_8x8_SRGB_BLOCK, VK_FORMAT_ASTC_10x5_UNORM_BLOCK, VK_FORMAT_ASTC_10x5_SRGB_BLOCK, VK_FORMAT_ASTC_10x6_UNORM_BLOCK, VK_FORMAT_ASTC_10x6_SRGB_BLOCK, VK_FORMAT_ASTC_10x8_UNORM_BLOCK, VK_FORMAT_ASTC_10x8_SRGB_BLOCK, VK_FORMAT_ASTC_10x10_UNORM_BLOCK, VK_FORMAT_ASTC_10x10_SRGB_BLOCK, VK_FORMAT_ASTC_12x10_UNORM_BLOCK, VK_FORMAT_ASTC_12x10_SRGB_BLOCK, VK_FORMAT_ASTC_12x12_UNORM_BLOCK, VK_FORMAT_ASTC_12x12_SRGB_BLOCK, VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG, VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG, VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG, VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG, VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG, VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG, VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG, VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG, VK_FORMAT_G8B8G8R8_422_UNORM_KHR, VK_FORMAT_B8G8R8G8_422_UNORM_KHR, VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR, VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR, VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR, VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR, VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR, VK_FORMAT_R10X6_UNORM_PACK16_KHR, VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR, VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR, VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR, VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR, VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR, VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR, VK_FORMAT_R12X4_UNORM_PACK16_KHR, VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR, VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR, VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR, VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR, VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR, VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR, VK_FORMAT_G16B16G16R16_422_UNORM_KHR, VK_FORMAT_B16G16R16G16_422_UNORM_KHR, VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR, VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR, VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR, VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR, VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR, };
const std::vector<VkImageType> AllVkImageTypeEnums = {VK_IMAGE_TYPE_1D, VK_IMAGE_TYPE_2D, VK_IMAGE_TYPE_3D, };
const std::vector<VkImageTiling> AllVkImageTilingEnums = {VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_TILING_LINEAR, };
const std::vector<VkPhysicalDeviceType> AllVkPhysicalDeviceTypeEnums = {VK_PHYSICAL_DEVICE_TYPE_OTHER, VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU, VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU, VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU, VK_PHYSICAL_DEVICE_TYPE_CPU, };
const std::vector<VkQueryType> AllVkQueryTypeEnums = {VK_QUERY_TYPE_OCCLUSION, VK_QUERY_TYPE_PIPELINE_STATISTICS, VK_QUERY_TYPE_TIMESTAMP, };
const std::vector<VkSharingMode> AllVkSharingModeEnums = {VK_SHARING_MODE_EXCLUSIVE, VK_SHARING_MODE_CONCURRENT, };
const std::vector<VkImageLayout> AllVkImageLayoutEnums = {VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_GENERAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_PREINITIALIZED, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR, };
const std::vector<VkImageViewType> AllVkImageViewTypeEnums = {VK_IMAGE_VIEW_TYPE_1D, VK_IMAGE_VIEW_TYPE_2D, VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY, VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, };
const std::vector<VkComponentSwizzle> AllVkComponentSwizzleEnums = {VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_ZERO, VK_COMPONENT_SWIZZLE_ONE, VK_COMPONENT_SWIZZLE_R, VK_COMPONENT_SWIZZLE_G, VK_COMPONENT_SWIZZLE_B, VK_COMPONENT_SWIZZLE_A, };
const std::vector<VkVertexInputRate> AllVkVertexInputRateEnums = {VK_VERTEX_INPUT_RATE_VERTEX, VK_VERTEX_INPUT_RATE_INSTANCE, };
const std::vector<VkPrimitiveTopology> AllVkPrimitiveTopologyEnums = {VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_STRIP, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, };
const std::vector<VkPolygonMode> AllVkPolygonModeEnums = {VK_POLYGON_MODE_FILL, VK_POLYGON_MODE_LINE, VK_POLYGON_MODE_POINT, VK_POLYGON_MODE_FILL_RECTANGLE_NV, };
const std::vector<VkFrontFace> AllVkFrontFaceEnums = {VK_FRONT_FACE_COUNTER_CLOCKWISE, VK_FRONT_FACE_CLOCKWISE, };
const std::vector<VkCompareOp> AllVkCompareOpEnums = {VK_COMPARE_OP_NEVER, VK_COMPARE_OP_LESS, VK_COMPARE_OP_EQUAL, VK_COMPARE_OP_LESS_OR_EQUAL, VK_COMPARE_OP_GREATER, VK_COMPARE_OP_NOT_EQUAL, VK_COMPARE_OP_GREATER_OR_EQUAL, VK_COMPARE_OP_ALWAYS, };
const std::vector<VkStencilOp> AllVkStencilOpEnums = {VK_STENCIL_OP_KEEP, VK_STENCIL_OP_ZERO, VK_STENCIL_OP_REPLACE, VK_STENCIL_OP_INCREMENT_AND_CLAMP, VK_STENCIL_OP_DECREMENT_AND_CLAMP, VK_STENCIL_OP_INVERT, VK_STENCIL_OP_INCREMENT_AND_WRAP, VK_STENCIL_OP_DECREMENT_AND_WRAP, };
const std::vector<VkLogicOp> AllVkLogicOpEnums = {VK_LOGIC_OP_CLEAR, VK_LOGIC_OP_AND, VK_LOGIC_OP_AND_REVERSE, VK_LOGIC_OP_COPY, VK_LOGIC_OP_AND_INVERTED, VK_LOGIC_OP_NO_OP, VK_LOGIC_OP_XOR, VK_LOGIC_OP_OR, VK_LOGIC_OP_NOR, VK_LOGIC_OP_EQUIVALENT, VK_LOGIC_OP_INVERT, VK_LOGIC_OP_OR_REVERSE, VK_LOGIC_OP_COPY_INVERTED, VK_LOGIC_OP_OR_INVERTED, VK_LOGIC_OP_NAND, VK_LOGIC_OP_SET, };
const std::vector<VkBlendFactor> AllVkBlendFactorEnums = {VK_BLEND_FACTOR_ZERO, VK_BLEND_FACTOR_ONE, VK_BLEND_FACTOR_SRC_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR, VK_BLEND_FACTOR_DST_COLOR, VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR, VK_BLEND_FACTOR_SRC_ALPHA, VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA, VK_BLEND_FACTOR_DST_ALPHA, VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA, VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA, VK_BLEND_FACTOR_SRC_ALPHA_SATURATE, VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA, };
const std::vector<VkBlendOp> AllVkBlendOpEnums = {VK_BLEND_OP_ADD, VK_BLEND_OP_SUBTRACT, VK_BLEND_OP_REVERSE_SUBTRACT, VK_BLEND_OP_MIN, VK_BLEND_OP_MAX, VK_BLEND_OP_ZERO_EXT, VK_BLEND_OP_SRC_EXT, VK_BLEND_OP_DST_EXT, VK_BLEND_OP_SRC_OVER_EXT, VK_BLEND_OP_DST_OVER_EXT, VK_BLEND_OP_SRC_IN_EXT, VK_BLEND_OP_DST_IN_EXT, VK_BLEND_OP_SRC_OUT_EXT, VK_BLEND_OP_DST_OUT_EXT, VK_BLEND_OP_SRC_ATOP_EXT, VK_BLEND_OP_DST_ATOP_EXT, VK_BLEND_OP_XOR_EXT, VK_BLEND_OP_MULTIPLY_EXT, VK_BLEND_OP_SCREEN_EXT, VK_BLEND_OP_OVERLAY_EXT, VK_BLEND_OP_DARKEN_EXT, VK_BLEND_OP_LIGHTEN_EXT, VK_BLEND_OP_COLORDODGE_EXT, VK_BLEND_OP_COLORBURN_EXT, VK_BLEND_OP_HARDLIGHT_EXT, VK_BLEND_OP_SOFTLIGHT_EXT, VK_BLEND_OP_DIFFERENCE_EXT, VK_BLEND_OP_EXCLUSION_EXT, VK_BLEND_OP_INVERT_EXT, VK_BLEND_OP_INVERT_RGB_EXT, VK_BLEND_OP_LINEARDODGE_EXT, VK_BLEND_OP_LINEARBURN_EXT, VK_BLEND_OP_VIVIDLIGHT_EXT, VK_BLEND_OP_LINEARLIGHT_EXT, VK_BLEND_OP_PINLIGHT_EXT, VK_BLEND_OP_HARDMIX_EXT, VK_BLEND_OP_HSL_HUE_EXT, VK_BLEND_OP_HSL_SATURATION_EXT, VK_BLEND_OP_HSL_COLOR_EXT, VK_BLEND_OP_HSL_LUMINOSITY_EXT, VK_BLEND_OP_PLUS_EXT, VK_BLEND_OP_PLUS_CLAMPED_EXT, VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT, VK_BLEND_OP_PLUS_DARKER_EXT, VK_BLEND_OP_MINUS_EXT, VK_BLEND_OP_MINUS_CLAMPED_EXT, VK_BLEND_OP_CONTRAST_EXT, VK_BLEND_OP_INVERT_OVG_EXT, VK_BLEND_OP_RED_EXT, VK_BLEND_OP_GREEN_EXT, VK_BLEND_OP_BLUE_EXT, };
const std::vector<VkDynamicState> AllVkDynamicStateEnums = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_LINE_WIDTH, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_BLEND_CONSTANTS, VK_DYNAMIC_STATE_DEPTH_BOUNDS, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV, VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT, VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, };
const std::vector<VkFilter> AllVkFilterEnums = {VK_FILTER_NEAREST, VK_FILTER_LINEAR, VK_FILTER_CUBIC_IMG, };
const std::vector<VkSamplerMipmapMode> AllVkSamplerMipmapModeEnums = {VK_SAMPLER_MIPMAP_MODE_NEAREST, VK_SAMPLER_MIPMAP_MODE_LINEAR, };
const std::vector<VkSamplerAddressMode> AllVkSamplerAddressModeEnums = {VK_SAMPLER_ADDRESS_MODE_REPEAT, VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE, };
const std::vector<VkBorderColor> AllVkBorderColorEnums = {VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK, VK_BORDER_COLOR_INT_TRANSPARENT_BLACK, VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, VK_BORDER_COLOR_INT_OPAQUE_BLACK, VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE, VK_BORDER_COLOR_INT_OPAQUE_WHITE, };
const std::vector<VkDescriptorType> AllVkDescriptorTypeEnums = {VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, };
const std::vector<VkAttachmentLoadOp> AllVkAttachmentLoadOpEnums = {VK_ATTACHMENT_LOAD_OP_LOAD, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_LOAD_OP_DONT_CARE, };
const std::vector<VkAttachmentStoreOp> AllVkAttachmentStoreOpEnums = {VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_STORE_OP_DONT_CARE, };
const std::vector<VkPipelineBindPoint> AllVkPipelineBindPointEnums = {VK_PIPELINE_BIND_POINT_GRAPHICS, VK_PIPELINE_BIND_POINT_COMPUTE, };
const std::vector<VkCommandBufferLevel> AllVkCommandBufferLevelEnums = {VK_COMMAND_BUFFER_LEVEL_PRIMARY, VK_COMMAND_BUFFER_LEVEL_SECONDARY, };
const std::vector<VkIndexType> AllVkIndexTypeEnums = {VK_INDEX_TYPE_UINT16, VK_INDEX_TYPE_UINT32, };
const std::vector<VkSubpassContents> AllVkSubpassContentsEnums = {VK_SUBPASS_CONTENTS_INLINE, VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS, };
const std::vector<VkObjectType> AllVkObjectTypeEnums = {VK_OBJECT_TYPE_UNKNOWN, VK_OBJECT_TYPE_INSTANCE, VK_OBJECT_TYPE_PHYSICAL_DEVICE, VK_OBJECT_TYPE_DEVICE, VK_OBJECT_TYPE_QUEUE, VK_OBJECT_TYPE_SEMAPHORE, VK_OBJECT_TYPE_COMMAND_BUFFER, VK_OBJECT_TYPE_FENCE, VK_OBJECT_TYPE_DEVICE_MEMORY, VK_OBJECT_TYPE_BUFFER, VK_OBJECT_TYPE_IMAGE, VK_OBJECT_TYPE_EVENT, VK_OBJECT_TYPE_QUERY_POOL, VK_OBJECT_TYPE_BUFFER_VIEW, VK_OBJECT_TYPE_IMAGE_VIEW, VK_OBJECT_TYPE_SHADER_MODULE, VK_OBJECT_TYPE_PIPELINE_CACHE, VK_OBJECT_TYPE_PIPELINE_LAYOUT, VK_OBJECT_TYPE_RENDER_PASS, VK_OBJECT_TYPE_PIPELINE, VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT, VK_OBJECT_TYPE_SAMPLER, VK_OBJECT_TYPE_DESCRIPTOR_POOL, VK_OBJECT_TYPE_DESCRIPTOR_SET, VK_OBJECT_TYPE_FRAMEBUFFER, VK_OBJECT_TYPE_COMMAND_POOL, VK_OBJECT_TYPE_SURFACE_KHR, VK_OBJECT_TYPE_SWAPCHAIN_KHR, VK_OBJECT_TYPE_DISPLAY_KHR, VK_OBJECT_TYPE_DISPLAY_MODE_KHR, VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT, VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR, VK_OBJECT_TYPE_OBJECT_TABLE_NVX, VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX, VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR, VK_OBJECT_TYPE_VALIDATION_CACHE_EXT, };
const std::vector<VkColorSpaceKHR> AllVkColorSpaceKHREnums = {VK_COLOR_SPACE_SRGB_NONLINEAR_KHR, VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT, VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT, VK_COLOR_SPACE_DCI_P3_LINEAR_EXT, VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT, VK_COLOR_SPACE_BT709_LINEAR_EXT, VK_COLOR_SPACE_BT709_NONLINEAR_EXT, VK_COLOR_SPACE_BT2020_LINEAR_EXT, VK_COLOR_SPACE_HDR10_ST2084_EXT, VK_COLOR_SPACE_DOLBYVISION_EXT, VK_COLOR_SPACE_HDR10_HLG_EXT, VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT, VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT, VK_COLOR_SPACE_PASS_THROUGH_EXT, VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT, };
const std::vector<VkPresentModeKHR> AllVkPresentModeKHREnums = {VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_FIFO_KHR, VK_PRESENT_MODE_FIFO_RELAXED_KHR, VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR, VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, };
const std::vector<VkDescriptorUpdateTemplateTypeKHR> AllVkDescriptorUpdateTemplateTypeKHREnums = {VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR, VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, };
const std::vector<VkPointClippingBehaviorKHR> AllVkPointClippingBehaviorKHREnums = {VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR, VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR, };
const std::vector<VkTessellationDomainOriginKHR> AllVkTessellationDomainOriginKHREnums = {VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR, VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR, };
const std::vector<VkSamplerYcbcrModelConversionKHR> AllVkSamplerYcbcrModelConversionKHREnums = {VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR, VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR, VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR, VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR, VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR, };
const std::vector<VkSamplerYcbcrRangeKHR> AllVkSamplerYcbcrRangeKHREnums = {VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR, VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR, };
const std::vector<VkChromaLocationKHR> AllVkChromaLocationKHREnums = {VK_CHROMA_LOCATION_COSITED_EVEN_KHR, VK_CHROMA_LOCATION_MIDPOINT_KHR, };
const std::vector<VkDebugReportObjectTypeEXT> AllVkDebugReportObjectTypeEXTEnums = {VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT, };
const std::vector<VkRasterizationOrderAMD> AllVkRasterizationOrderAMDEnums = {VK_RASTERIZATION_ORDER_STRICT_AMD, VK_RASTERIZATION_ORDER_RELAXED_AMD, };
const std::vector<VkShaderInfoTypeAMD> AllVkShaderInfoTypeAMDEnums = {VK_SHADER_INFO_TYPE_STATISTICS_AMD, VK_SHADER_INFO_TYPE_BINARY_AMD, VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD, };
const std::vector<VkValidationCheckEXT> AllVkValidationCheckEXTEnums = {VK_VALIDATION_CHECK_ALL_EXT, VK_VALIDATION_CHECK_SHADERS_EXT, };
const std::vector<VkIndirectCommandsTokenTypeNVX> AllVkIndirectCommandsTokenTypeNVXEnums = {VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX, };
const std::vector<VkObjectEntryTypeNVX> AllVkObjectEntryTypeNVXEnums = {VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX, VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX, VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX, VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX, VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX, };
const std::vector<VkDisplayPowerStateEXT> AllVkDisplayPowerStateEXTEnums = {VK_DISPLAY_POWER_STATE_OFF_EXT, VK_DISPLAY_POWER_STATE_SUSPEND_EXT, VK_DISPLAY_POWER_STATE_ON_EXT, };
const std::vector<VkDeviceEventTypeEXT> AllVkDeviceEventTypeEXTEnums = {VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT, };
const std::vector<VkDisplayEventTypeEXT> AllVkDisplayEventTypeEXTEnums = {VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT, };
const std::vector<VkViewportCoordinateSwizzleNV> AllVkViewportCoordinateSwizzleNVEnums = {VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV, VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV, VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV, VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV, VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV, VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV, VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV, VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV, };
const std::vector<VkDiscardRectangleModeEXT> AllVkDiscardRectangleModeEXTEnums = {VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT, VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT, };
const std::vector<VkConservativeRasterizationModeEXT> AllVkConservativeRasterizationModeEXTEnums = {VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT, VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT, VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT, };
const std::vector<VkSamplerReductionModeEXT> AllVkSamplerReductionModeEXTEnums = {VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT, VK_SAMPLER_REDUCTION_MODE_MIN_EXT, VK_SAMPLER_REDUCTION_MODE_MAX_EXT, };
const std::vector<VkBlendOverlapEXT> AllVkBlendOverlapEXTEnums = {VK_BLEND_OVERLAP_UNCORRELATED_EXT, VK_BLEND_OVERLAP_DISJOINT_EXT, VK_BLEND_OVERLAP_CONJOINT_EXT, };
const std::vector<VkCoverageModulationModeNV> AllVkCoverageModulationModeNVEnums = {VK_COVERAGE_MODULATION_MODE_NONE_NV, VK_COVERAGE_MODULATION_MODE_RGB_NV, VK_COVERAGE_MODULATION_MODE_ALPHA_NV, VK_COVERAGE_MODULATION_MODE_RGBA_NV, };
const std::vector<VkValidationCacheHeaderVersionEXT> AllVkValidationCacheHeaderVersionEXTEnums = {VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT, };
const std::vector<VkQueueGlobalPriorityEXT> AllVkQueueGlobalPriorityEXTEnums = {VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT, VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT, VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT, VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT, };


typedef bool (*PFN_manual_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
typedef bool (*PFN_manual_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
typedef bool (*PFN_manual_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
typedef bool (*PFN_manual_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
typedef bool (*PFN_manual_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence);
typedef bool (*PFN_manual_vkQueueWaitIdle)(VkQueue queue);
typedef bool (*PFN_manual_vkDeviceWaitIdle)(VkDevice device);
typedef bool (*PFN_manual_vkAllocateMemory)(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
typedef bool (*PFN_manual_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkMapMemory)(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);
typedef bool (*PFN_manual_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
typedef bool (*PFN_manual_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
typedef bool (*PFN_manual_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
typedef bool (*PFN_manual_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
typedef bool (*PFN_manual_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef bool (*PFN_manual_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef bool (*PFN_manual_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
typedef bool (*PFN_manual_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
typedef bool (*PFN_manual_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
typedef bool (*PFN_manual_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
typedef bool (*PFN_manual_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence);
typedef bool (*PFN_manual_vkCreateFence)(VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef bool (*PFN_manual_vkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkResetFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences);
typedef bool (*PFN_manual_vkGetFenceStatus)(VkDevice device, VkFence fence);
typedef bool (*PFN_manual_vkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
typedef bool (*PFN_manual_vkCreateSemaphore)(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
typedef bool (*PFN_manual_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreateEvent)(VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
typedef bool (*PFN_manual_vkDestroyEvent)(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkGetEventStatus)(VkDevice device, VkEvent event);
typedef bool (*PFN_manual_vkSetEvent)(VkDevice device, VkEvent event);
typedef bool (*PFN_manual_vkResetEvent)(VkDevice device, VkEvent event);
typedef bool (*PFN_manual_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
typedef bool (*PFN_manual_vkCreateBuffer)(VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
typedef bool (*PFN_manual_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreateBufferView)(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView);
typedef bool (*PFN_manual_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreateImage)(VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage);
typedef bool (*PFN_manual_vkDestroyImage)(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
typedef bool (*PFN_manual_vkCreateImageView)(VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView);
typedef bool (*PFN_manual_vkDestroyImageView)(VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreateShaderModule)(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
typedef bool (*PFN_manual_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreatePipelineCache)(VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
typedef bool (*PFN_manual_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
typedef bool (*PFN_manual_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches);
typedef bool (*PFN_manual_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef bool (*PFN_manual_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef bool (*PFN_manual_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreatePipelineLayout)(VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
typedef bool (*PFN_manual_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreateSampler)(VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
typedef bool (*PFN_manual_vkDestroySampler)(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreateDescriptorSetLayout)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
typedef bool (*PFN_manual_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreateDescriptorPool)(VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
typedef bool (*PFN_manual_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
typedef bool (*PFN_manual_vkAllocateDescriptorSets)(VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets);
typedef bool (*PFN_manual_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets);
typedef bool (*PFN_manual_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies);
typedef bool (*PFN_manual_vkCreateFramebuffer)(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
typedef bool (*PFN_manual_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
typedef bool (*PFN_manual_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
typedef bool (*PFN_manual_vkAllocateCommandBuffers)(VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers);
typedef bool (*PFN_manual_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);
typedef bool (*PFN_manual_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo);
typedef bool (*PFN_manual_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
typedef bool (*PFN_manual_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
typedef bool (*PFN_manual_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
typedef bool (*PFN_manual_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports);
typedef bool (*PFN_manual_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors);
typedef bool (*PFN_manual_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
typedef bool (*PFN_manual_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
typedef bool (*PFN_manual_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, const float blendConstants[4]);
typedef bool (*PFN_manual_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
typedef bool (*PFN_manual_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
typedef bool (*PFN_manual_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
typedef bool (*PFN_manual_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
typedef bool (*PFN_manual_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);
typedef bool (*PFN_manual_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
typedef bool (*PFN_manual_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets);
typedef bool (*PFN_manual_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
typedef bool (*PFN_manual_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
typedef bool (*PFN_manual_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef bool (*PFN_manual_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef bool (*PFN_manual_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef bool (*PFN_manual_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
typedef bool (*PFN_manual_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions);
typedef bool (*PFN_manual_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions);
typedef bool (*PFN_manual_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter);
typedef bool (*PFN_manual_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions);
typedef bool (*PFN_manual_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions);
typedef bool (*PFN_manual_vkCmdUpdateBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData);
typedef bool (*PFN_manual_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
typedef bool (*PFN_manual_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
typedef bool (*PFN_manual_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
typedef bool (*PFN_manual_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects);
typedef bool (*PFN_manual_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions);
typedef bool (*PFN_manual_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef bool (*PFN_manual_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef bool (*PFN_manual_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
typedef bool (*PFN_manual_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
typedef bool (*PFN_manual_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
typedef bool (*PFN_manual_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
typedef bool (*PFN_manual_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef bool (*PFN_manual_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
typedef bool (*PFN_manual_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
typedef bool (*PFN_manual_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues);
typedef bool (*PFN_manual_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
typedef bool (*PFN_manual_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
typedef bool (*PFN_manual_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
typedef bool (*PFN_manual_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);
typedef bool (*PFN_manual_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
typedef bool (*PFN_manual_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
typedef bool (*PFN_manual_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
typedef bool (*PFN_manual_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);
typedef bool (*PFN_manual_vkCreateSwapchainKHR)(VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
typedef bool (*PFN_manual_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
typedef bool (*PFN_manual_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
typedef bool (*PFN_manual_vkQueuePresentKHR)(VkQueue queue, const VkPresentInfoKHR* pPresentInfo);
typedef bool (*PFN_manual_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
typedef bool (*PFN_manual_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
typedef bool (*PFN_manual_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
typedef bool (*PFN_manual_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
typedef bool (*PFN_manual_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
typedef bool (*PFN_manual_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef bool (*PFN_manual_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);
#ifdef VK_USE_PLATFORM_XLIB_KHR
typedef bool (*PFN_manual_vkCreateXlibSurfaceKHR)(VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
typedef bool (*PFN_manual_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
typedef bool (*PFN_manual_vkCreateXcbSurfaceKHR)(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
typedef bool (*PFN_manual_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
typedef bool (*PFN_manual_vkCreateWaylandSurfaceKHR)(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
typedef bool (*PFN_manual_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display);
#endif
#ifdef VK_USE_PLATFORM_MIR_KHR
typedef bool (*PFN_manual_vkCreateMirSurfaceKHR)(VkInstance instance, const VkMirSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
#ifdef VK_USE_PLATFORM_MIR_KHR
typedef bool (*PFN_manual_vkGetPhysicalDeviceMirPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, MirConnection* connection);
#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
typedef bool (*PFN_manual_vkCreateAndroidSurfaceKHR)(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkCreateWin32SurfaceKHR)(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);
#endif
typedef bool (*PFN_manual_vkGetPhysicalDeviceFeatures2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2KHR* pFeatures);
typedef bool (*PFN_manual_vkGetPhysicalDeviceProperties2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2KHR* pProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceFormatProperties2KHR)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2KHR* pFormatProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceImageFormatProperties2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2KHR* pImageFormatInfo, VkImageFormatProperties2KHR* pImageFormatProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceQueueFamilyProperties2KHR)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2KHR* pQueueFamilyProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceMemoryProperties2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2KHR* pMemoryProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2KHR* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2KHR* pProperties);
typedef bool (*PFN_manual_vkTrimCommandPoolKHR)(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlagsKHR flags);
typedef bool (*PFN_manual_vkGetPhysicalDeviceExternalBufferPropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfoKHR* pExternalBufferInfo, VkExternalBufferPropertiesKHR* pExternalBufferProperties);
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkGetMemoryWin32HandleKHR)(VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBitsKHR handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties);
#endif
typedef bool (*PFN_manual_vkGetMemoryFdKHR)(VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd);
typedef bool (*PFN_manual_vkGetMemoryFdPropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBitsKHR handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties);
typedef bool (*PFN_manual_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfoKHR* pExternalSemaphoreInfo, VkExternalSemaphorePropertiesKHR* pExternalSemaphoreProperties);
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkImportSemaphoreWin32HandleKHR)(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkGetSemaphoreWin32HandleKHR)(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
#endif
typedef bool (*PFN_manual_vkImportSemaphoreFdKHR)(VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
typedef bool (*PFN_manual_vkGetSemaphoreFdKHR)(VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd);
typedef bool (*PFN_manual_vkCmdPushDescriptorSetKHR)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites);
typedef bool (*PFN_manual_vkCreateDescriptorUpdateTemplateKHR)(VkDevice device, const VkDescriptorUpdateTemplateCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplateKHR* pDescriptorUpdateTemplate);
typedef bool (*PFN_manual_vkDestroyDescriptorUpdateTemplateKHR)(VkDevice device, VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkUpdateDescriptorSetWithTemplateKHR)(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate, const void* pData);
typedef bool (*PFN_manual_vkCmdPushDescriptorSetWithTemplateKHR)(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData);
typedef bool (*PFN_manual_vkGetSwapchainStatusKHR)(VkDevice device, VkSwapchainKHR swapchain);
typedef bool (*PFN_manual_vkGetPhysicalDeviceExternalFencePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfoKHR* pExternalFenceInfo, VkExternalFencePropertiesKHR* pExternalFenceProperties);
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkImportFenceWin32HandleKHR)(VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkGetFenceWin32HandleKHR)(VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
#endif
typedef bool (*PFN_manual_vkImportFenceFdKHR)(VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo);
typedef bool (*PFN_manual_vkGetFenceFdKHR)(VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd);
typedef bool (*PFN_manual_vkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities);
typedef bool (*PFN_manual_vkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats);
typedef bool (*PFN_manual_vkGetImageMemoryRequirements2KHR)(VkDevice device, const VkImageMemoryRequirementsInfo2KHR* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements);
typedef bool (*PFN_manual_vkGetBufferMemoryRequirements2KHR)(VkDevice device, const VkBufferMemoryRequirementsInfo2KHR* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements);
typedef bool (*PFN_manual_vkGetImageSparseMemoryRequirements2KHR)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2KHR* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2KHR* pSparseMemoryRequirements);
typedef bool (*PFN_manual_vkCreateSamplerYcbcrConversionKHR)(VkDevice device, const VkSamplerYcbcrConversionCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversionKHR* pYcbcrConversion);
typedef bool (*PFN_manual_vkDestroySamplerYcbcrConversionKHR)(VkDevice device, VkSamplerYcbcrConversionKHR ycbcrConversion, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkBindBufferMemory2KHR)(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfoKHR* pBindInfos);
typedef bool (*PFN_manual_vkBindImageMemory2KHR)(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfoKHR* pBindInfos);
typedef bool (*PFN_manual_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage);
typedef bool (*PFN_manual_vkDebugMarkerSetObjectTagEXT)(VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo);
typedef bool (*PFN_manual_vkDebugMarkerSetObjectNameEXT)(VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo);
typedef bool (*PFN_manual_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
typedef bool (*PFN_manual_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
typedef bool (*PFN_manual_vkCmdDrawIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef bool (*PFN_manual_vkCmdDrawIndexedIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef bool (*PFN_manual_vkGetShaderInfoAMD)(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo);
typedef bool (*PFN_manual_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties);
#ifdef VK_USE_PLATFORM_WIN32_KHR
typedef bool (*PFN_manual_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);
#endif
typedef bool (*PFN_manual_vkGetDeviceGroupPeerMemoryFeaturesKHX)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlagsKHX* pPeerMemoryFeatures);
typedef bool (*PFN_manual_vkCmdSetDeviceMaskKHX)(VkCommandBuffer commandBuffer, uint32_t deviceMask);
typedef bool (*PFN_manual_vkCmdDispatchBaseKHX)(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef bool (*PFN_manual_vkGetDeviceGroupPresentCapabilitiesKHX)(VkDevice device, VkDeviceGroupPresentCapabilitiesKHX* pDeviceGroupPresentCapabilities);
typedef bool (*PFN_manual_vkGetDeviceGroupSurfacePresentModesKHX)(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHX* pModes);
typedef bool (*PFN_manual_vkGetPhysicalDevicePresentRectanglesKHX)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects);
typedef bool (*PFN_manual_vkAcquireNextImage2KHX)(VkDevice device, const VkAcquireNextImageInfoKHX* pAcquireInfo, uint32_t* pImageIndex);
#ifdef VK_USE_PLATFORM_VI_NN
typedef bool (*PFN_manual_vkCreateViSurfaceNN)(VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
typedef bool (*PFN_manual_vkEnumeratePhysicalDeviceGroupsKHX)(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupPropertiesKHX* pPhysicalDeviceGroupProperties);
typedef bool (*PFN_manual_vkCmdProcessCommandsNVX)(VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo);
typedef bool (*PFN_manual_vkCmdReserveSpaceForCommandsNVX)(VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo);
typedef bool (*PFN_manual_vkCreateIndirectCommandsLayoutNVX)(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout);
typedef bool (*PFN_manual_vkDestroyIndirectCommandsLayoutNVX)(VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkCreateObjectTableNVX)(VkDevice device, const VkObjectTableCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkObjectTableNVX* pObjectTable);
typedef bool (*PFN_manual_vkDestroyObjectTableNVX)(VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkRegisterObjectsNVX)(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectTableEntryNVX* const*    ppObjectTableEntries, const uint32_t* pObjectIndices);
typedef bool (*PFN_manual_vkUnregisterObjectsNVX)(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX* pObjectEntryTypes, const uint32_t* pObjectIndices);
typedef bool (*PFN_manual_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX)(VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX* pFeatures, VkDeviceGeneratedCommandsLimitsNVX* pLimits);
typedef bool (*PFN_manual_vkCmdSetViewportWScalingNV)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings);
typedef bool (*PFN_manual_vkReleaseDisplayEXT)(VkPhysicalDevice physicalDevice, VkDisplayKHR display);
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
typedef bool (*PFN_manual_vkAcquireXlibDisplayEXT)(VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display);
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
typedef bool (*PFN_manual_vkGetRandROutputDisplayEXT)(VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay);
#endif
typedef bool (*PFN_manual_vkGetPhysicalDeviceSurfaceCapabilities2EXT)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities);
typedef bool (*PFN_manual_vkDisplayPowerControlEXT)(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo);
typedef bool (*PFN_manual_vkRegisterDeviceEventEXT)(VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef bool (*PFN_manual_vkRegisterDisplayEventEXT)(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef bool (*PFN_manual_vkGetSwapchainCounterEXT)(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue);
typedef bool (*PFN_manual_vkGetRefreshCycleDurationGOOGLE)(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties);
typedef bool (*PFN_manual_vkGetPastPresentationTimingGOOGLE)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings);
typedef bool (*PFN_manual_vkCmdSetDiscardRectangleEXT)(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles);
typedef bool (*PFN_manual_vkSetHdrMetadataEXT)(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata);
#ifdef VK_USE_PLATFORM_IOS_MVK
typedef bool (*PFN_manual_vkCreateIOSSurfaceMVK)(VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
#ifdef VK_USE_PLATFORM_MACOS_MVK
typedef bool (*PFN_manual_vkCreateMacOSSurfaceMVK)(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
#endif
typedef bool (*PFN_manual_vkCmdSetSampleLocationsEXT)(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo);
typedef bool (*PFN_manual_vkGetPhysicalDeviceMultisamplePropertiesEXT)(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties);
typedef bool (*PFN_manual_vkCreateValidationCacheEXT)(VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache);
typedef bool (*PFN_manual_vkDestroyValidationCacheEXT)(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator);
typedef bool (*PFN_manual_vkMergeValidationCachesEXT)(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches);
typedef bool (*PFN_manual_vkGetValidationCacheDataEXT)(VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData);
typedef bool (*PFN_manual_vkGetMemoryHostPointerPropertiesEXT)(VkDevice device, VkExternalMemoryHandleTypeFlagBitsKHR handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties);
typedef bool (*PFN_manual_vkCmdWriteBufferMarkerAMD)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker);


std::unordered_map<std::string, void *> custom_functions = {
    {"vkEnumeratePhysicalDevices", nullptr},
    {"vkGetPhysicalDeviceFeatures", nullptr},
    {"vkGetPhysicalDeviceFormatProperties", nullptr},
    {"vkGetPhysicalDeviceImageFormatProperties", nullptr},
    {"vkGetPhysicalDeviceProperties", nullptr},
    {"vkGetPhysicalDeviceQueueFamilyProperties", nullptr},
    {"vkGetPhysicalDeviceMemoryProperties", nullptr},
    {"vkGetDeviceQueue", nullptr},
    {"vkQueueSubmit", nullptr},
    {"vkQueueWaitIdle", nullptr},
    {"vkDeviceWaitIdle", nullptr},
    {"vkAllocateMemory", nullptr},
    {"vkFreeMemory", nullptr},
    {"vkMapMemory", nullptr},
    {"vkUnmapMemory", nullptr},
    {"vkFlushMappedMemoryRanges", nullptr},
    {"vkInvalidateMappedMemoryRanges", nullptr},
    {"vkGetDeviceMemoryCommitment", nullptr},
    {"vkBindBufferMemory", nullptr},
    {"vkBindImageMemory", nullptr},
    {"vkGetBufferMemoryRequirements", nullptr},
    {"vkGetImageMemoryRequirements", nullptr},
    {"vkGetImageSparseMemoryRequirements", nullptr},
    {"vkGetPhysicalDeviceSparseImageFormatProperties", nullptr},
    {"vkQueueBindSparse", nullptr},
    {"vkCreateFence", nullptr},
    {"vkDestroyFence", nullptr},
    {"vkResetFences", nullptr},
    {"vkGetFenceStatus", nullptr},
    {"vkWaitForFences", nullptr},
    {"vkCreateSemaphore", nullptr},
    {"vkDestroySemaphore", nullptr},
    {"vkCreateEvent", nullptr},
    {"vkDestroyEvent", nullptr},
    {"vkGetEventStatus", nullptr},
    {"vkSetEvent", nullptr},
    {"vkResetEvent", nullptr},
    {"vkDestroyQueryPool", nullptr},
    {"vkGetQueryPoolResults", nullptr},
    {"vkCreateBuffer", nullptr},
    {"vkDestroyBuffer", nullptr},
    {"vkCreateBufferView", nullptr},
    {"vkDestroyBufferView", nullptr},
    {"vkCreateImage", nullptr},
    {"vkDestroyImage", nullptr},
    {"vkGetImageSubresourceLayout", nullptr},
    {"vkCreateImageView", nullptr},
    {"vkDestroyImageView", nullptr},
    {"vkCreateShaderModule", nullptr},
    {"vkDestroyShaderModule", nullptr},
    {"vkCreatePipelineCache", nullptr},
    {"vkDestroyPipelineCache", nullptr},
    {"vkGetPipelineCacheData", nullptr},
    {"vkMergePipelineCaches", nullptr},
    {"vkCreateGraphicsPipelines", nullptr},
    {"vkCreateComputePipelines", nullptr},
    {"vkDestroyPipeline", nullptr},
    {"vkCreatePipelineLayout", nullptr},
    {"vkDestroyPipelineLayout", nullptr},
    {"vkCreateSampler", nullptr},
    {"vkDestroySampler", nullptr},
    {"vkCreateDescriptorSetLayout", nullptr},
    {"vkDestroyDescriptorSetLayout", nullptr},
    {"vkCreateDescriptorPool", nullptr},
    {"vkDestroyDescriptorPool", nullptr},
    {"vkResetDescriptorPool", nullptr},
    {"vkAllocateDescriptorSets", nullptr},
    {"vkFreeDescriptorSets", nullptr},
    {"vkUpdateDescriptorSets", nullptr},
    {"vkCreateFramebuffer", nullptr},
    {"vkDestroyFramebuffer", nullptr},
    {"vkGetRenderAreaGranularity", nullptr},
    {"vkDestroyCommandPool", nullptr},
    {"vkResetCommandPool", nullptr},
    {"vkAllocateCommandBuffers", nullptr},
    {"vkFreeCommandBuffers", nullptr},
    {"vkBeginCommandBuffer", nullptr},
    {"vkEndCommandBuffer", nullptr},
    {"vkResetCommandBuffer", nullptr},
    {"vkCmdBindPipeline", nullptr},
    {"vkCmdSetViewport", nullptr},
    {"vkCmdSetScissor", nullptr},
    {"vkCmdSetLineWidth", nullptr},
    {"vkCmdSetDepthBias", nullptr},
    {"vkCmdSetBlendConstants", nullptr},
    {"vkCmdSetDepthBounds", nullptr},
    {"vkCmdSetStencilCompareMask", nullptr},
    {"vkCmdSetStencilWriteMask", nullptr},
    {"vkCmdSetStencilReference", nullptr},
    {"vkCmdBindDescriptorSets", nullptr},
    {"vkCmdBindIndexBuffer", nullptr},
    {"vkCmdBindVertexBuffers", nullptr},
    {"vkCmdDraw", nullptr},
    {"vkCmdDrawIndexed", nullptr},
    {"vkCmdDrawIndirect", nullptr},
    {"vkCmdDrawIndexedIndirect", nullptr},
    {"vkCmdDispatch", nullptr},
    {"vkCmdDispatchIndirect", nullptr},
    {"vkCmdCopyBuffer", nullptr},
    {"vkCmdCopyImage", nullptr},
    {"vkCmdBlitImage", nullptr},
    {"vkCmdCopyBufferToImage", nullptr},
    {"vkCmdCopyImageToBuffer", nullptr},
    {"vkCmdUpdateBuffer", nullptr},
    {"vkCmdFillBuffer", nullptr},
    {"vkCmdClearColorImage", nullptr},
    {"vkCmdClearDepthStencilImage", nullptr},
    {"vkCmdClearAttachments", nullptr},
    {"vkCmdResolveImage", nullptr},
    {"vkCmdSetEvent", nullptr},
    {"vkCmdResetEvent", nullptr},
    {"vkCmdWaitEvents", nullptr},
    {"vkCmdPipelineBarrier", nullptr},
    {"vkCmdBeginQuery", nullptr},
    {"vkCmdEndQuery", nullptr},
    {"vkCmdResetQueryPool", nullptr},
    {"vkCmdWriteTimestamp", nullptr},
    {"vkCmdCopyQueryPoolResults", nullptr},
    {"vkCmdPushConstants", nullptr},
    {"vkCmdBeginRenderPass", nullptr},
    {"vkCmdNextSubpass", nullptr},
    {"vkCmdEndRenderPass", nullptr},
    {"vkCmdExecuteCommands", nullptr},
    {"vkDestroySurfaceKHR", nullptr},
    {"vkGetPhysicalDeviceSurfaceSupportKHR", nullptr},
    {"vkGetPhysicalDeviceSurfaceCapabilitiesKHR", nullptr},
    {"vkGetPhysicalDeviceSurfaceFormatsKHR", nullptr},
    {"vkGetPhysicalDeviceSurfacePresentModesKHR", nullptr},
    {"vkCreateSwapchainKHR", nullptr},
    {"vkDestroySwapchainKHR", nullptr},
    {"vkGetSwapchainImagesKHR", nullptr},
    {"vkAcquireNextImageKHR", nullptr},
    {"vkQueuePresentKHR", nullptr},
    {"vkGetPhysicalDeviceDisplayPropertiesKHR", nullptr},
    {"vkGetPhysicalDeviceDisplayPlanePropertiesKHR", nullptr},
    {"vkGetDisplayPlaneSupportedDisplaysKHR", nullptr},
    {"vkGetDisplayModePropertiesKHR", nullptr},
    {"vkCreateDisplayModeKHR", nullptr},
    {"vkGetDisplayPlaneCapabilitiesKHR", nullptr},
    {"vkCreateDisplayPlaneSurfaceKHR", nullptr},
    {"vkCreateSharedSwapchainsKHR", nullptr},
#ifdef VK_USE_PLATFORM_XLIB_KHR
    {"vkCreateXlibSurfaceKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    {"vkGetPhysicalDeviceXlibPresentationSupportKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    {"vkCreateXcbSurfaceKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    {"vkGetPhysicalDeviceXcbPresentationSupportKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    {"vkCreateWaylandSurfaceKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    {"vkGetPhysicalDeviceWaylandPresentationSupportKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_MIR_KHR
    {"vkCreateMirSurfaceKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_MIR_KHR
    {"vkGetPhysicalDeviceMirPresentationSupportKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    {"vkCreateAndroidSurfaceKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkCreateWin32SurfaceKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetPhysicalDeviceWin32PresentationSupportKHR", nullptr},
#endif
    {"vkGetPhysicalDeviceFeatures2KHR", nullptr},
    {"vkGetPhysicalDeviceProperties2KHR", nullptr},
    {"vkGetPhysicalDeviceFormatProperties2KHR", nullptr},
    {"vkGetPhysicalDeviceImageFormatProperties2KHR", nullptr},
    {"vkGetPhysicalDeviceQueueFamilyProperties2KHR", nullptr},
    {"vkGetPhysicalDeviceMemoryProperties2KHR", nullptr},
    {"vkGetPhysicalDeviceSparseImageFormatProperties2KHR", nullptr},
    {"vkTrimCommandPoolKHR", nullptr},
    {"vkGetPhysicalDeviceExternalBufferPropertiesKHR", nullptr},
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetMemoryWin32HandleKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetMemoryWin32HandlePropertiesKHR", nullptr},
#endif
    {"vkGetMemoryFdKHR", nullptr},
    {"vkGetMemoryFdPropertiesKHR", nullptr},
    {"vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", nullptr},
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkImportSemaphoreWin32HandleKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetSemaphoreWin32HandleKHR", nullptr},
#endif
    {"vkImportSemaphoreFdKHR", nullptr},
    {"vkGetSemaphoreFdKHR", nullptr},
    {"vkCmdPushDescriptorSetKHR", nullptr},
    {"vkCreateDescriptorUpdateTemplateKHR", nullptr},
    {"vkDestroyDescriptorUpdateTemplateKHR", nullptr},
    {"vkUpdateDescriptorSetWithTemplateKHR", nullptr},
    {"vkCmdPushDescriptorSetWithTemplateKHR", nullptr},
    {"vkGetSwapchainStatusKHR", nullptr},
    {"vkGetPhysicalDeviceExternalFencePropertiesKHR", nullptr},
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkImportFenceWin32HandleKHR", nullptr},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetFenceWin32HandleKHR", nullptr},
#endif
    {"vkImportFenceFdKHR", nullptr},
    {"vkGetFenceFdKHR", nullptr},
    {"vkGetPhysicalDeviceSurfaceCapabilities2KHR", nullptr},
    {"vkGetPhysicalDeviceSurfaceFormats2KHR", nullptr},
    {"vkGetImageMemoryRequirements2KHR", nullptr},
    {"vkGetBufferMemoryRequirements2KHR", nullptr},
    {"vkGetImageSparseMemoryRequirements2KHR", nullptr},
    {"vkCreateSamplerYcbcrConversionKHR", nullptr},
    {"vkDestroySamplerYcbcrConversionKHR", nullptr},
    {"vkBindBufferMemory2KHR", nullptr},
    {"vkBindImageMemory2KHR", nullptr},
    {"vkDebugReportMessageEXT", nullptr},
    {"vkDebugMarkerSetObjectTagEXT", nullptr},
    {"vkDebugMarkerSetObjectNameEXT", nullptr},
    {"vkCmdDebugMarkerBeginEXT", nullptr},
    {"vkCmdDebugMarkerInsertEXT", nullptr},
    {"vkCmdDrawIndirectCountAMD", nullptr},
    {"vkCmdDrawIndexedIndirectCountAMD", nullptr},
    {"vkGetShaderInfoAMD", nullptr},
    {"vkGetPhysicalDeviceExternalImageFormatPropertiesNV", nullptr},
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetMemoryWin32HandleNV", nullptr},
#endif
    {"vkGetDeviceGroupPeerMemoryFeaturesKHX", nullptr},
    {"vkCmdSetDeviceMaskKHX", nullptr},
    {"vkCmdDispatchBaseKHX", nullptr},
    {"vkGetDeviceGroupPresentCapabilitiesKHX", nullptr},
    {"vkGetDeviceGroupSurfacePresentModesKHX", nullptr},
    {"vkGetPhysicalDevicePresentRectanglesKHX", nullptr},
    {"vkAcquireNextImage2KHX", nullptr},
#ifdef VK_USE_PLATFORM_VI_NN
    {"vkCreateViSurfaceNN", nullptr},
#endif
    {"vkEnumeratePhysicalDeviceGroupsKHX", nullptr},
    {"vkCmdProcessCommandsNVX", nullptr},
    {"vkCmdReserveSpaceForCommandsNVX", nullptr},
    {"vkCreateIndirectCommandsLayoutNVX", nullptr},
    {"vkDestroyIndirectCommandsLayoutNVX", nullptr},
    {"vkCreateObjectTableNVX", nullptr},
    {"vkDestroyObjectTableNVX", nullptr},
    {"vkRegisterObjectsNVX", nullptr},
    {"vkUnregisterObjectsNVX", nullptr},
    {"vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX", nullptr},
    {"vkCmdSetViewportWScalingNV", nullptr},
    {"vkReleaseDisplayEXT", nullptr},
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    {"vkAcquireXlibDisplayEXT", nullptr},
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    {"vkGetRandROutputDisplayEXT", nullptr},
#endif
    {"vkGetPhysicalDeviceSurfaceCapabilities2EXT", nullptr},
    {"vkDisplayPowerControlEXT", nullptr},
    {"vkRegisterDeviceEventEXT", nullptr},
    {"vkRegisterDisplayEventEXT", nullptr},
    {"vkGetSwapchainCounterEXT", nullptr},
    {"vkGetRefreshCycleDurationGOOGLE", nullptr},
    {"vkGetPastPresentationTimingGOOGLE", nullptr},
    {"vkCmdSetDiscardRectangleEXT", nullptr},
    {"vkSetHdrMetadataEXT", nullptr},
#ifdef VK_USE_PLATFORM_IOS_MVK
    {"vkCreateIOSSurfaceMVK", nullptr},
#endif
#ifdef VK_USE_PLATFORM_MACOS_MVK
    {"vkCreateMacOSSurfaceMVK", nullptr},
#endif
    {"vkCmdSetSampleLocationsEXT", nullptr},
    {"vkGetPhysicalDeviceMultisamplePropertiesEXT", nullptr},
    {"vkCreateValidationCacheEXT", nullptr},
    {"vkDestroyValidationCacheEXT", nullptr},
    {"vkMergeValidationCachesEXT", nullptr},
    {"vkGetValidationCacheDataEXT", nullptr},
    {"vkGetMemoryHostPointerPropertiesEXT", nullptr},
    {"vkCmdWriteBufferMarkerAMD", nullptr},
};


template <typename T>
bool OutputExtensionError(const T *layer_data, const std::string &api_name, const std::string &extension_name) {
    return log_msg(layer_data->report_data, VK_DEBUG_REPORT_ERROR_BIT_EXT, VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT, 0, __LINE__,
                   EXTENSION_NOT_ENABLED, LayerName, "Attemped to call %s() but its required extension %s has not been enabled\n",
                   api_name.c_str(), extension_name.c_str());
}


// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);

bool parameter_validation_vkCreateInstance(
    VkInstance instance,
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;

    skip |= validate_struct_type(local_data->report_data, "vkCreateInstance", "pCreateInfo", "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, true, VALIDATION_ERROR_0be2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_reserved_flags(local_data->report_data, "vkCreateInstance", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_0be09005);

        skip |= validate_struct_type(local_data->report_data, "vkCreateInstance", "pCreateInfo->pApplicationInfo", "VK_STRUCTURE_TYPE_APPLICATION_INFO", pCreateInfo->pApplicationInfo, VK_STRUCTURE_TYPE_APPLICATION_INFO, false, VALIDATION_ERROR_0062b00b);

        if (pCreateInfo->pApplicationInfo != NULL)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkCreateInstance", "pCreateInfo->pApplicationInfo->pNext", NULL, pCreateInfo->pApplicationInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0061c40d);
        }

        skip |= validate_string_array(local_data->report_data, "vkCreateInstance", "pCreateInfo->enabledLayerCount", "pCreateInfo->ppEnabledLayerNames", pCreateInfo->enabledLayerCount, pCreateInfo->ppEnabledLayerNames, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_0be29001);

        skip |= validate_string_array(local_data->report_data, "vkCreateInstance", "pCreateInfo->enabledExtensionCount", "pCreateInfo->ppEnabledExtensionNames", pCreateInfo->enabledExtensionCount, pCreateInfo->ppEnabledExtensionNames, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_0be28e01);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateInstance", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateInstance", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateInstance", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateInstance", "pInstance", pInstance, VALIDATION_ERROR_21219c01);

    return skip;
}

// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR void VKAPI_CALL vkDestroyInstance(
    VkInstance                                  instance,
    const VkAllocationCallbacks*                pAllocator);

bool parameter_validation_vkDestroyInstance(
    VkInstance                                  instance,
    const VkAllocationCallbacks*                pAllocator)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyInstance", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyInstance", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyInstance", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    return skip;
}

VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_array(local_data->report_data, "vkEnumeratePhysicalDevices", "pPhysicalDeviceCount", "pPhysicalDevices", pPhysicalDeviceCount, pPhysicalDevices, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2801dc01);

    PFN_manual_vkEnumeratePhysicalDevices custom_func = (PFN_manual_vkEnumeratePhysicalDevices)custom_functions["vkEnumeratePhysicalDevices"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pPhysicalDeviceCount, pPhysicalDevices);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceFeatures", "pFeatures", pFeatures, VALIDATION_ERROR_2c016e01);

    PFN_manual_vkGetPhysicalDeviceFeatures custom_func = (PFN_manual_vkGetPhysicalDeviceFeatures)custom_functions["vkGetPhysicalDeviceFeatures"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pFeatures);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceFeatures(physicalDevice, pFeatures);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceFormatProperties", "format", "VkFormat", AllVkFormatEnums, format, VALIDATION_ERROR_2c409201);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceFormatProperties", "pFormatProperties", pFormatProperties, VALIDATION_ERROR_2c417601);

    PFN_manual_vkGetPhysicalDeviceFormatProperties custom_func = (PFN_manual_vkGetPhysicalDeviceFormatProperties)custom_functions["vkGetPhysicalDeviceFormatProperties"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, format, pFormatProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties", "format", "VkFormat", AllVkFormatEnums, format, VALIDATION_ERROR_2ca09201);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties", "type", "VkImageType", AllVkImageTypeEnums, type, VALIDATION_ERROR_2ca30401);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties", "tiling", "VkImageTiling", AllVkImageTilingEnums, tiling, VALIDATION_ERROR_2ca2fa01);

    skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties", "usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, usage, true, false, VALIDATION_ERROR_2ca30603);

    skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties", "flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, flags, false, false, VALIDATION_ERROR_2ca09001);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties", "pImageFormatProperties", pImageFormatProperties, VALIDATION_ERROR_2ca18401);

    PFN_manual_vkGetPhysicalDeviceImageFormatProperties custom_func = (PFN_manual_vkGetPhysicalDeviceImageFormatProperties)custom_functions["vkGetPhysicalDeviceImageFormatProperties"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceProperties", "pProperties", pProperties, VALIDATION_ERROR_2d61f401);

    PFN_manual_vkGetPhysicalDeviceProperties custom_func = (PFN_manual_vkGetPhysicalDeviceProperties)custom_functions["vkGetPhysicalDeviceProperties"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceProperties(physicalDevice, pProperties);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_array(local_data->report_data, "vkGetPhysicalDeviceQueueFamilyProperties", "pQueueFamilyPropertyCount", "pQueueFamilyProperties", pQueueFamilyPropertyCount, pQueueFamilyProperties, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2da20001);

    PFN_manual_vkGetPhysicalDeviceQueueFamilyProperties custom_func = (PFN_manual_vkGetPhysicalDeviceQueueFamilyProperties)custom_functions["vkGetPhysicalDeviceQueueFamilyProperties"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceMemoryProperties", "pMemoryProperties", pMemoryProperties, VALIDATION_ERROR_2ce1b001);

    PFN_manual_vkGetPhysicalDeviceMemoryProperties custom_func = (PFN_manual_vkGetPhysicalDeviceMemoryProperties)custom_functions["vkGetPhysicalDeviceMemoryProperties"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pMemoryProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
    }
}

// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR VkResult VKAPI_CALL vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);

bool parameter_validation_vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;

    skip |= validate_struct_type(local_data->report_data, "vkCreateDevice", "pCreateInfo", "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, true, VALIDATION_ERROR_0562b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_reserved_flags(local_data->report_data, "vkCreateDevice", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_05609005);

        skip |= validate_struct_type_array(local_data->report_data, "vkCreateDevice", "pCreateInfo->queueCreateInfoCount", "pCreateInfo->pQueueCreateInfos", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", pCreateInfo->queueCreateInfoCount, pCreateInfo->pQueueCreateInfos, VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, true, true, VALIDATION_ERROR_0561fe01);

        if (pCreateInfo->pQueueCreateInfos != NULL)
        {
            for (uint32_t queueCreateInfoIndex = 0; queueCreateInfoIndex < pCreateInfo->queueCreateInfoCount; ++queueCreateInfoIndex)
            {
                const VkStructureType allowed_structs_VkDeviceQueueCreateInfo[] = { VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT };

                skip |= validate_struct_pnext(local_data->report_data, "vkCreateDevice", ParameterName("pCreateInfo->pQueueCreateInfos[%i].pNext", ParameterName::IndexVector{ queueCreateInfoIndex }), "VkDeviceQueueGlobalPriorityCreateInfoEXT", pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].pNext, ARRAY_SIZE(allowed_structs_VkDeviceQueueCreateInfo), allowed_structs_VkDeviceQueueCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_06c1c40d);

                skip |= validate_reserved_flags(local_data->report_data, "vkCreateDevice", ParameterName("pCreateInfo->pQueueCreateInfos[%i].flags", ParameterName::IndexVector{ queueCreateInfoIndex }), pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].flags, VALIDATION_ERROR_06c09005);

                skip |= validate_array(local_data->report_data, "vkCreateDevice", ParameterName("pCreateInfo->pQueueCreateInfos[%i].queueCount", ParameterName::IndexVector{ queueCreateInfoIndex }), ParameterName("pCreateInfo->pQueueCreateInfos[%i].pQueuePriorities", ParameterName::IndexVector{ queueCreateInfoIndex }), pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].queueCount, pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].pQueuePriorities, true, true, VALIDATION_ERROR_06c29e1b, VALIDATION_ERROR_06c20401);
            }
        }

        skip |= validate_string_array(local_data->report_data, "vkCreateDevice", "pCreateInfo->enabledLayerCount", "pCreateInfo->ppEnabledLayerNames", pCreateInfo->enabledLayerCount, pCreateInfo->ppEnabledLayerNames, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_05629001);

        skip |= validate_string_array(local_data->report_data, "vkCreateDevice", "pCreateInfo->enabledExtensionCount", "pCreateInfo->ppEnabledExtensionNames", pCreateInfo->enabledExtensionCount, pCreateInfo->ppEnabledExtensionNames, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_05628e01);

        if (pCreateInfo->pEnabledFeatures != NULL)
        {
            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->robustBufferAccess", pCreateInfo->pEnabledFeatures->robustBufferAccess);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->fullDrawIndexUint32", pCreateInfo->pEnabledFeatures->fullDrawIndexUint32);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->imageCubeArray", pCreateInfo->pEnabledFeatures->imageCubeArray);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->independentBlend", pCreateInfo->pEnabledFeatures->independentBlend);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->geometryShader", pCreateInfo->pEnabledFeatures->geometryShader);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->tessellationShader", pCreateInfo->pEnabledFeatures->tessellationShader);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sampleRateShading", pCreateInfo->pEnabledFeatures->sampleRateShading);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->dualSrcBlend", pCreateInfo->pEnabledFeatures->dualSrcBlend);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->logicOp", pCreateInfo->pEnabledFeatures->logicOp);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->multiDrawIndirect", pCreateInfo->pEnabledFeatures->multiDrawIndirect);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->drawIndirectFirstInstance", pCreateInfo->pEnabledFeatures->drawIndirectFirstInstance);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->depthClamp", pCreateInfo->pEnabledFeatures->depthClamp);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->depthBiasClamp", pCreateInfo->pEnabledFeatures->depthBiasClamp);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->fillModeNonSolid", pCreateInfo->pEnabledFeatures->fillModeNonSolid);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->depthBounds", pCreateInfo->pEnabledFeatures->depthBounds);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->wideLines", pCreateInfo->pEnabledFeatures->wideLines);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->largePoints", pCreateInfo->pEnabledFeatures->largePoints);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->alphaToOne", pCreateInfo->pEnabledFeatures->alphaToOne);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->multiViewport", pCreateInfo->pEnabledFeatures->multiViewport);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->samplerAnisotropy", pCreateInfo->pEnabledFeatures->samplerAnisotropy);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->textureCompressionETC2", pCreateInfo->pEnabledFeatures->textureCompressionETC2);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->textureCompressionASTC_LDR", pCreateInfo->pEnabledFeatures->textureCompressionASTC_LDR);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->textureCompressionBC", pCreateInfo->pEnabledFeatures->textureCompressionBC);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->occlusionQueryPrecise", pCreateInfo->pEnabledFeatures->occlusionQueryPrecise);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->pipelineStatisticsQuery", pCreateInfo->pEnabledFeatures->pipelineStatisticsQuery);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->vertexPipelineStoresAndAtomics", pCreateInfo->pEnabledFeatures->vertexPipelineStoresAndAtomics);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->fragmentStoresAndAtomics", pCreateInfo->pEnabledFeatures->fragmentStoresAndAtomics);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderTessellationAndGeometryPointSize", pCreateInfo->pEnabledFeatures->shaderTessellationAndGeometryPointSize);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderImageGatherExtended", pCreateInfo->pEnabledFeatures->shaderImageGatherExtended);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderStorageImageExtendedFormats", pCreateInfo->pEnabledFeatures->shaderStorageImageExtendedFormats);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderStorageImageMultisample", pCreateInfo->pEnabledFeatures->shaderStorageImageMultisample);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderStorageImageReadWithoutFormat", pCreateInfo->pEnabledFeatures->shaderStorageImageReadWithoutFormat);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderStorageImageWriteWithoutFormat", pCreateInfo->pEnabledFeatures->shaderStorageImageWriteWithoutFormat);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderUniformBufferArrayDynamicIndexing", pCreateInfo->pEnabledFeatures->shaderUniformBufferArrayDynamicIndexing);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderSampledImageArrayDynamicIndexing", pCreateInfo->pEnabledFeatures->shaderSampledImageArrayDynamicIndexing);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderStorageBufferArrayDynamicIndexing", pCreateInfo->pEnabledFeatures->shaderStorageBufferArrayDynamicIndexing);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderStorageImageArrayDynamicIndexing", pCreateInfo->pEnabledFeatures->shaderStorageImageArrayDynamicIndexing);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderClipDistance", pCreateInfo->pEnabledFeatures->shaderClipDistance);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderCullDistance", pCreateInfo->pEnabledFeatures->shaderCullDistance);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderFloat64", pCreateInfo->pEnabledFeatures->shaderFloat64);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderInt64", pCreateInfo->pEnabledFeatures->shaderInt64);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderInt16", pCreateInfo->pEnabledFeatures->shaderInt16);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderResourceResidency", pCreateInfo->pEnabledFeatures->shaderResourceResidency);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->shaderResourceMinLod", pCreateInfo->pEnabledFeatures->shaderResourceMinLod);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseBinding", pCreateInfo->pEnabledFeatures->sparseBinding);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseResidencyBuffer", pCreateInfo->pEnabledFeatures->sparseResidencyBuffer);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseResidencyImage2D", pCreateInfo->pEnabledFeatures->sparseResidencyImage2D);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseResidencyImage3D", pCreateInfo->pEnabledFeatures->sparseResidencyImage3D);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseResidency2Samples", pCreateInfo->pEnabledFeatures->sparseResidency2Samples);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseResidency4Samples", pCreateInfo->pEnabledFeatures->sparseResidency4Samples);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseResidency8Samples", pCreateInfo->pEnabledFeatures->sparseResidency8Samples);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseResidency16Samples", pCreateInfo->pEnabledFeatures->sparseResidency16Samples);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->sparseResidencyAliased", pCreateInfo->pEnabledFeatures->sparseResidencyAliased);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->variableMultisampleRate", pCreateInfo->pEnabledFeatures->variableMultisampleRate);

            skip |= validate_bool32(local_data->report_data, "vkCreateDevice", "pCreateInfo->pEnabledFeatures->inheritedQueries", pCreateInfo->pEnabledFeatures->inheritedQueries);
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateDevice", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDevice", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDevice", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateDevice", "pDevice", pDevice, VALIDATION_ERROR_1fc13801);

    return skip;
}

// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR void VKAPI_CALL vkDestroyDevice(
    VkDevice                                    device,
    const VkAllocationCallbacks*                pAllocator);

bool parameter_validation_vkDestroyDevice(
    VkDevice                                    device,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDevice", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDevice", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDevice", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    return skip;
}

VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_pointer(local_data->report_data, "vkGetDeviceQueue", "pQueue", pQueue, VALIDATION_ERROR_2961fc01);

    PFN_manual_vkGetDeviceQueue custom_func = (PFN_manual_vkGetDeviceQueue)custom_functions["vkGetDeviceQueue"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, queueFamilyIndex, queueIndex, pQueue);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo*                         pSubmits,
    VkFence                                     fence)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(queue), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type_array(local_data->report_data, "vkQueueSubmit", "submitCount", "pSubmits", "VK_STRUCTURE_TYPE_SUBMIT_INFO", submitCount, pSubmits, VK_STRUCTURE_TYPE_SUBMIT_INFO, false, true, VALIDATION_ERROR_31a24001);

    if (pSubmits != NULL)
    {
        for (uint32_t submitIndex = 0; submitIndex < submitCount; ++submitIndex)
        {
            const VkStructureType allowed_structs_VkSubmitInfo[] = { VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR, VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV };

            skip |= validate_struct_pnext(local_data->report_data, "vkQueueSubmit", ParameterName("pSubmits[%i].pNext", ParameterName::IndexVector{ submitIndex }), "VkD3D12FenceSubmitInfoKHR, VkDeviceGroupSubmitInfoKHX, VkWin32KeyedMutexAcquireReleaseInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoNV", pSubmits[submitIndex].pNext, ARRAY_SIZE(allowed_structs_VkSubmitInfo), allowed_structs_VkSubmitInfo, GeneratedHeaderVersion, VALIDATION_ERROR_13c1c40d);

            skip |= validate_array(local_data->report_data, "vkQueueSubmit", ParameterName("pSubmits[%i].waitSemaphoreCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pWaitSemaphores", ParameterName::IndexVector{ submitIndex }), pSubmits[submitIndex].waitSemaphoreCount, pSubmits[submitIndex].pWaitSemaphores, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_13c27601);

            skip |= validate_flags_array(local_data->report_data, "vkQueueSubmit", ParameterName("pSubmits[%i].waitSemaphoreCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pWaitDstStageMask", ParameterName::IndexVector{ submitIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pSubmits[submitIndex].waitSemaphoreCount, pSubmits[submitIndex].pWaitDstStageMask, false, true);

            skip |= validate_array(local_data->report_data, "vkQueueSubmit", ParameterName("pSubmits[%i].commandBufferCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pCommandBuffers", ParameterName::IndexVector{ submitIndex }), pSubmits[submitIndex].commandBufferCount, pSubmits[submitIndex].pCommandBuffers, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_13c11401);

            skip |= validate_array(local_data->report_data, "vkQueueSubmit", ParameterName("pSubmits[%i].signalSemaphoreCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pSignalSemaphores", ParameterName::IndexVector{ submitIndex }), pSubmits[submitIndex].signalSemaphoreCount, pSubmits[submitIndex].pSignalSemaphores, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_13c23401);
        }
    }

    PFN_manual_vkQueueSubmit custom_func = (PFN_manual_vkQueueSubmit)custom_functions["vkQueueSubmit"];
    if (custom_func != nullptr) {
        skip |= custom_func(queue, submitCount, pSubmits, fence);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.QueueSubmit(queue, submitCount, pSubmits, fence);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkQueueWaitIdle(
    VkQueue                                     queue)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(queue), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkQueueWaitIdle custom_func = (PFN_manual_vkQueueWaitIdle)custom_functions["vkQueueWaitIdle"];
    if (custom_func != nullptr) {
        skip |= custom_func(queue);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.QueueWaitIdle(queue);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkDeviceWaitIdle(
    VkDevice                                    device)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkDeviceWaitIdle custom_func = (PFN_manual_vkDeviceWaitIdle)custom_functions["vkDeviceWaitIdle"];
    if (custom_func != nullptr) {
        skip |= custom_func(device);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.DeviceWaitIdle(device);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateMemory(
    VkDevice                                    device,
    const VkMemoryAllocateInfo*                 pAllocateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkAllocateMemory", "pAllocateInfo", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", pAllocateInfo, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, true, VALIDATION_ERROR_0c62b00b);

    if (pAllocateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkMemoryAllocateInfo[] = { VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR, VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR, VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV, VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX, VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR };

        skip |= validate_struct_pnext(local_data->report_data, "vkAllocateMemory", "pAllocateInfo->pNext", "VkDedicatedAllocationMemoryAllocateInfoNV, VkExportMemoryAllocateInfoKHR, VkExportMemoryAllocateInfoNV, VkExportMemoryWin32HandleInfoKHR, VkExportMemoryWin32HandleInfoNV, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoNV, VkMemoryAllocateFlagsInfoKHX, VkMemoryDedicatedAllocateInfoKHR", pAllocateInfo->pNext, ARRAY_SIZE(allowed_structs_VkMemoryAllocateInfo), allowed_structs_VkMemoryAllocateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_0c61c40d);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkAllocateMemory", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkAllocateMemory", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkAllocateMemory", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkAllocateMemory", "pMemory", pMemory, VALIDATION_ERROR_16c1aa01);

    PFN_manual_vkAllocateMemory custom_func = (PFN_manual_vkAllocateMemory)custom_functions["vkAllocateMemory"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pAllocateInfo, pAllocator, pMemory);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.AllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkFreeMemory", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkFreeMemory", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkFreeMemory", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkFreeMemory custom_func = (PFN_manual_vkFreeMemory)custom_functions["vkFreeMemory"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, memory, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.FreeMemory(device, memory, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkMapMemory", "memory", memory);

    skip |= validate_reserved_flags(local_data->report_data, "vkMapMemory", "flags", flags, VALIDATION_ERROR_31209005);

    PFN_manual_vkMapMemory custom_func = (PFN_manual_vkMapMemory)custom_functions["vkMapMemory"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, memory, offset, size, flags, ppData);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.MapMemory(device, memory, offset, size, flags, ppData);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkUnmapMemory", "memory", memory);

    PFN_manual_vkUnmapMemory custom_func = (PFN_manual_vkUnmapMemory)custom_functions["vkUnmapMemory"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, memory);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.UnmapMemory(device, memory);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type_array(local_data->report_data, "vkFlushMappedMemoryRanges", "memoryRangeCount", "pMemoryRanges", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", memoryRangeCount, pMemoryRanges, VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, true, true, VALIDATION_ERROR_2821b201);

    if (pMemoryRanges != NULL)
    {
        for (uint32_t memoryRangeIndex = 0; memoryRangeIndex < memoryRangeCount; ++memoryRangeIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkFlushMappedMemoryRanges", ParameterName("pMemoryRanges[%i].pNext", ParameterName::IndexVector{ memoryRangeIndex }), NULL, pMemoryRanges[memoryRangeIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0c21c40d);

            skip |= validate_required_handle(local_data->report_data, "vkFlushMappedMemoryRanges", ParameterName("pMemoryRanges[%i].memory", ParameterName::IndexVector{ memoryRangeIndex }), pMemoryRanges[memoryRangeIndex].memory);
        }
    }

    PFN_manual_vkFlushMappedMemoryRanges custom_func = (PFN_manual_vkFlushMappedMemoryRanges)custom_functions["vkFlushMappedMemoryRanges"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, memoryRangeCount, pMemoryRanges);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type_array(local_data->report_data, "vkInvalidateMappedMemoryRanges", "memoryRangeCount", "pMemoryRanges", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", memoryRangeCount, pMemoryRanges, VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, true, true, VALIDATION_ERROR_3101b201);

    if (pMemoryRanges != NULL)
    {
        for (uint32_t memoryRangeIndex = 0; memoryRangeIndex < memoryRangeCount; ++memoryRangeIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkInvalidateMappedMemoryRanges", ParameterName("pMemoryRanges[%i].pNext", ParameterName::IndexVector{ memoryRangeIndex }), NULL, pMemoryRanges[memoryRangeIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0c21c40d);

            skip |= validate_required_handle(local_data->report_data, "vkInvalidateMappedMemoryRanges", ParameterName("pMemoryRanges[%i].memory", ParameterName::IndexVector{ memoryRangeIndex }), pMemoryRanges[memoryRangeIndex].memory);
        }
    }

    PFN_manual_vkInvalidateMappedMemoryRanges custom_func = (PFN_manual_vkInvalidateMappedMemoryRanges)custom_functions["vkInvalidateMappedMemoryRanges"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, memoryRangeCount, pMemoryRanges);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetDeviceMemoryCommitment", "memory", memory);

    skip |= validate_required_pointer(local_data->report_data, "vkGetDeviceMemoryCommitment", "pCommittedMemoryInBytes", pCommittedMemoryInBytes, VALIDATION_ERROR_29211801);

    PFN_manual_vkGetDeviceMemoryCommitment custom_func = (PFN_manual_vkGetDeviceMemoryCommitment)custom_functions["vkGetDeviceMemoryCommitment"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, memory, pCommittedMemoryInBytes);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkBindBufferMemory", "buffer", buffer);

    skip |= validate_required_handle(local_data->report_data, "vkBindBufferMemory", "memory", memory);

    PFN_manual_vkBindBufferMemory custom_func = (PFN_manual_vkBindBufferMemory)custom_functions["vkBindBufferMemory"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, buffer, memory, memoryOffset);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.BindBufferMemory(device, buffer, memory, memoryOffset);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkBindImageMemory", "image", image);

    skip |= validate_required_handle(local_data->report_data, "vkBindImageMemory", "memory", memory);

    PFN_manual_vkBindImageMemory custom_func = (PFN_manual_vkBindImageMemory)custom_functions["vkBindImageMemory"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, image, memory, memoryOffset);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.BindImageMemory(device, image, memory, memoryOffset);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetBufferMemoryRequirements", "buffer", buffer);

    skip |= validate_required_pointer(local_data->report_data, "vkGetBufferMemoryRequirements", "pMemoryRequirements", pMemoryRequirements, VALIDATION_ERROR_28a1b401);

    PFN_manual_vkGetBufferMemoryRequirements custom_func = (PFN_manual_vkGetBufferMemoryRequirements)custom_functions["vkGetBufferMemoryRequirements"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, buffer, pMemoryRequirements);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetImageMemoryRequirements", "image", image);

    skip |= validate_required_pointer(local_data->report_data, "vkGetImageMemoryRequirements", "pMemoryRequirements", pMemoryRequirements, VALIDATION_ERROR_2a21b401);

    PFN_manual_vkGetImageMemoryRequirements custom_func = (PFN_manual_vkGetImageMemoryRequirements)custom_functions["vkGetImageMemoryRequirements"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, image, pMemoryRequirements);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetImageMemoryRequirements(device, image, pMemoryRequirements);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetImageSparseMemoryRequirements", "image", image);

    skip |= validate_array(local_data->report_data, "vkGetImageSparseMemoryRequirements", "pSparseMemoryRequirementCount", "pSparseMemoryRequirements", pSparseMemoryRequirementCount, pSparseMemoryRequirements, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2a423801);

    PFN_manual_vkGetImageSparseMemoryRequirements custom_func = (PFN_manual_vkGetImageSparseMemoryRequirements)custom_functions["vkGetImageSparseMemoryRequirements"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties", "format", "VkFormat", AllVkFormatEnums, format, VALIDATION_ERROR_2de09201);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties", "type", "VkImageType", AllVkImageTypeEnums, type, VALIDATION_ERROR_2de30401);

    skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties", "samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, samples, true, true, VALIDATION_ERROR_2de2b401);

    skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties", "usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, usage, true, false, VALIDATION_ERROR_2de30603);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties", "tiling", "VkImageTiling", AllVkImageTilingEnums, tiling, VALIDATION_ERROR_2de2fa01);

    skip |= validate_array(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties", "pPropertyCount", "pProperties", pPropertyCount, pProperties, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2de1f401);

    PFN_manual_vkGetPhysicalDeviceSparseImageFormatProperties custom_func = (PFN_manual_vkGetPhysicalDeviceSparseImageFormatProperties)custom_functions["vkGetPhysicalDeviceSparseImageFormatProperties"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkQueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    const VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(queue), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type_array(local_data->report_data, "vkQueueBindSparse", "bindInfoCount", "pBindInfo", "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO", bindInfoCount, pBindInfo, VK_STRUCTURE_TYPE_BIND_SPARSE_INFO, false, true, VALIDATION_ERROR_3160f801);

    if (pBindInfo != NULL)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            const VkStructureType allowed_structs_VkBindSparseInfo[] = { VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX };

            skip |= validate_struct_pnext(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), "VkDeviceGroupBindSparseInfoKHX", pBindInfo[bindInfoIndex].pNext, ARRAY_SIZE(allowed_structs_VkBindSparseInfo), allowed_structs_VkBindSparseInfo, GeneratedHeaderVersion, VALIDATION_ERROR_0121c40d);

            skip |= validate_array(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].waitSemaphoreCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pWaitSemaphores", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].waitSemaphoreCount, pBindInfo[bindInfoIndex].pWaitSemaphores, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_01227601);

            skip |= validate_array(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].bufferBindCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pBufferBinds", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].bufferBindCount, pBindInfo[bindInfoIndex].pBufferBinds, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_01210201);

            if (pBindInfo[bindInfoIndex].pBufferBinds != NULL)
            {
                for (uint32_t bufferBindIndex = 0; bufferBindIndex < pBindInfo[bindInfoIndex].bufferBindCount; ++bufferBindIndex)
                {
                    skip |= validate_required_handle(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pBufferBinds[%i].buffer", ParameterName::IndexVector{ bindInfoIndex, bufferBindIndex }), pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].buffer);

                    skip |= validate_array(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pBufferBinds[%i].bindCount", ParameterName::IndexVector{ bindInfoIndex, bufferBindIndex }), ParameterName("pBindInfo[%i].pBufferBinds[%i].pBinds", ParameterName::IndexVector{ bindInfoIndex, bufferBindIndex }), pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].bindCount, pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds, true, true, VALIDATION_ERROR_12c0141b, VALIDATION_ERROR_12c0fe01);

                    if (pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds != NULL)
                    {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].bindCount; ++bindIndex)
                        {
                            skip |= validate_flags(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pBufferBinds[%i].pBinds[%i].flags", ParameterName::IndexVector{ bindInfoIndex, bufferBindIndex, bindIndex }), "VkSparseMemoryBindFlagBits", AllVkSparseMemoryBindFlagBits, pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds[bindIndex].flags, false, false, VALIDATION_ERROR_13409001);
                        }
                    }
                }
            }

            skip |= validate_array(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].imageOpaqueBindCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pImageOpaqueBinds", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].imageOpaqueBindCount, pBindInfo[bindInfoIndex].pImageOpaqueBinds, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_01218c01);

            if (pBindInfo[bindInfoIndex].pImageOpaqueBinds != NULL)
            {
                for (uint32_t imageOpaqueBindIndex = 0; imageOpaqueBindIndex < pBindInfo[bindInfoIndex].imageOpaqueBindCount; ++imageOpaqueBindIndex)
                {
                    skip |= validate_required_handle(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pImageOpaqueBinds[%i].image", ParameterName::IndexVector{ bindInfoIndex, imageOpaqueBindIndex }), pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].image);

                    skip |= validate_array(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pImageOpaqueBinds[%i].bindCount", ParameterName::IndexVector{ bindInfoIndex, imageOpaqueBindIndex }), ParameterName("pBindInfo[%i].pImageOpaqueBinds[%i].pBinds", ParameterName::IndexVector{ bindInfoIndex, imageOpaqueBindIndex }), pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].bindCount, pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds, true, true, VALIDATION_ERROR_1320141b, VALIDATION_ERROR_1320fe01);

                    if (pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds != NULL)
                    {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].bindCount; ++bindIndex)
                        {
                            skip |= validate_flags(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pImageOpaqueBinds[%i].pBinds[%i].flags", ParameterName::IndexVector{ bindInfoIndex, imageOpaqueBindIndex, bindIndex }), "VkSparseMemoryBindFlagBits", AllVkSparseMemoryBindFlagBits, pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds[bindIndex].flags, false, false, VALIDATION_ERROR_13409001);
                        }
                    }
                }
            }

            skip |= validate_array(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].imageBindCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pImageBinds", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].imageBindCount, pBindInfo[bindInfoIndex].pImageBinds, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_01218001);

            if (pBindInfo[bindInfoIndex].pImageBinds != NULL)
            {
                for (uint32_t imageBindIndex = 0; imageBindIndex < pBindInfo[bindInfoIndex].imageBindCount; ++imageBindIndex)
                {
                    skip |= validate_required_handle(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pImageBinds[%i].image", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex }), pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].image);

                    skip |= validate_array(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pImageBinds[%i].bindCount", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex }), ParameterName("pBindInfo[%i].pImageBinds[%i].pBinds", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex }), pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].bindCount, pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds, true, true, VALIDATION_ERROR_1300141b, VALIDATION_ERROR_1300fe01);

                    if (pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds != NULL)
                    {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].bindCount; ++bindIndex)
                        {
                            skip |= validate_flags(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pImageBinds[%i].pBinds[%i].subresource.aspectMask", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex, bindIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds[bindIndex].subresource.aspectMask, true, false, VALIDATION_ERROR_0a400c03);

                            // No xml-driven validation

                            // No xml-driven validation

                            skip |= validate_flags(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].pImageBinds[%i].pBinds[%i].flags", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex, bindIndex }), "VkSparseMemoryBindFlagBits", AllVkSparseMemoryBindFlagBits, pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds[bindIndex].flags, false, false, VALIDATION_ERROR_12e09001);
                        }
                    }
                }
            }

            skip |= validate_array(local_data->report_data, "vkQueueBindSparse", ParameterName("pBindInfo[%i].signalSemaphoreCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pSignalSemaphores", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].signalSemaphoreCount, pBindInfo[bindInfoIndex].pSignalSemaphores, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_01223401);
        }
    }

    PFN_manual_vkQueueBindSparse custom_func = (PFN_manual_vkQueueBindSparse)custom_functions["vkQueueBindSparse"];
    if (custom_func != nullptr) {
        skip |= custom_func(queue, bindInfoCount, pBindInfo, fence);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.QueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateFence(
    VkDevice                                    device,
    const VkFenceCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateFence", "pCreateInfo", "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, true, VALIDATION_ERROR_0922b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkFenceCreateInfo[] = { VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateFence", "pCreateInfo->pNext", "VkExportFenceCreateInfoKHR, VkExportFenceWin32HandleInfoKHR", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkFenceCreateInfo), allowed_structs_VkFenceCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_0921c40d);

        skip |= validate_flags(local_data->report_data, "vkCreateFence", "pCreateInfo->flags", "VkFenceCreateFlagBits", AllVkFenceCreateFlagBits, pCreateInfo->flags, false, false, VALIDATION_ERROR_09209001);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateFence", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateFence", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateFence", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateFence", "pFence", pFence, VALIDATION_ERROR_20417001);

    PFN_manual_vkCreateFence custom_func = (PFN_manual_vkCreateFence)custom_functions["vkCreateFence"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pFence);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateFence(device, pCreateInfo, pAllocator, pFence);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyFence", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyFence", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyFence", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyFence custom_func = (PFN_manual_vkDestroyFence)custom_functions["vkDestroyFence"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, fence, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyFence(device, fence, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_handle_array(local_data->report_data, "vkResetFences", "fenceCount", "pFences", fenceCount, pFences, true, true);

    PFN_manual_vkResetFences custom_func = (PFN_manual_vkResetFences)custom_functions["vkResetFences"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, fenceCount, pFences);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ResetFences(device, fenceCount, pFences);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetFenceStatus", "fence", fence);

    PFN_manual_vkGetFenceStatus custom_func = (PFN_manual_vkGetFenceStatus)custom_functions["vkGetFenceStatus"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, fence);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetFenceStatus(device, fence);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkWaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_handle_array(local_data->report_data, "vkWaitForFences", "fenceCount", "pFences", fenceCount, pFences, true, true);

    skip |= validate_bool32(local_data->report_data, "vkWaitForFences", "waitAll", waitAll);

    PFN_manual_vkWaitForFences custom_func = (PFN_manual_vkWaitForFences)custom_functions["vkWaitForFences"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, fenceCount, pFences, waitAll, timeout);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.WaitForFences(device, fenceCount, pFences, waitAll, timeout);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateSemaphore(
    VkDevice                                    device,
    const VkSemaphoreCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateSemaphore", "pCreateInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, true, VALIDATION_ERROR_1282b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkSemaphoreCreateInfo[] = { VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateSemaphore", "pCreateInfo->pNext", "VkExportSemaphoreCreateInfoKHR, VkExportSemaphoreWin32HandleInfoKHR", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkSemaphoreCreateInfo), allowed_structs_VkSemaphoreCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_1281c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateSemaphore", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_12809005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateSemaphore", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSemaphore", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSemaphore", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateSemaphore", "pSemaphore", pSemaphore, VALIDATION_ERROR_22422801);

    PFN_manual_vkCreateSemaphore custom_func = (PFN_manual_vkCreateSemaphore)custom_functions["vkCreateSemaphore"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pSemaphore);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroySemaphore", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySemaphore", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySemaphore", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroySemaphore custom_func = (PFN_manual_vkDestroySemaphore)custom_functions["vkDestroySemaphore"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, semaphore, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroySemaphore(device, semaphore, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateEvent(
    VkDevice                                    device,
    const VkEventCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateEvent", "pCreateInfo", "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_EVENT_CREATE_INFO, true, VALIDATION_ERROR_07e2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateEvent", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_07e1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateEvent", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_07e09005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateEvent", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateEvent", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateEvent", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateEvent", "pEvent", pEvent, VALIDATION_ERROR_20215e01);

    PFN_manual_vkCreateEvent custom_func = (PFN_manual_vkCreateEvent)custom_functions["vkCreateEvent"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pEvent);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateEvent(device, pCreateInfo, pAllocator, pEvent);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyEvent", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyEvent", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyEvent", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyEvent custom_func = (PFN_manual_vkDestroyEvent)custom_functions["vkDestroyEvent"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, event, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyEvent(device, event, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetEventStatus", "event", event);

    PFN_manual_vkGetEventStatus custom_func = (PFN_manual_vkGetEventStatus)custom_functions["vkGetEventStatus"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, event);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetEventStatus(device, event);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkSetEvent(
    VkDevice                                    device,
    VkEvent                                     event)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkSetEvent", "event", event);

    PFN_manual_vkSetEvent custom_func = (PFN_manual_vkSetEvent)custom_functions["vkSetEvent"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, event);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.SetEvent(device, event);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkResetEvent(
    VkDevice                                    device,
    VkEvent                                     event)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkResetEvent", "event", event);

    PFN_manual_vkResetEvent custom_func = (PFN_manual_vkResetEvent)custom_functions["vkResetEvent"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, event);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ResetEvent(device, event);
    }
    return result;
}

// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR VkResult VKAPI_CALL vkCreateQueryPool(
    VkDevice                                    device,
    const VkQueryPoolCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool);

bool parameter_validation_vkCreateQueryPool(
    VkDevice                                    device,
    const VkQueryPoolCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;

    skip |= validate_struct_type(local_data->report_data, "vkCreateQueryPool", "pCreateInfo", "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO, true, VALIDATION_ERROR_11c2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateQueryPool", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_11c1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateQueryPool", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_11c09005);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateQueryPool", "pCreateInfo->queryType", "VkQueryType", AllVkQueryTypeEnums, pCreateInfo->queryType, VALIDATION_ERROR_11c29a01);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateQueryPool", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateQueryPool", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateQueryPool", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateQueryPool", "pQueryPool", pQueryPool, VALIDATION_ERROR_21e1fa01);

    return skip;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyQueryPool", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyQueryPool", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyQueryPool", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyQueryPool custom_func = (PFN_manual_vkDestroyQueryPool)custom_functions["vkDestroyQueryPool"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, queryPool, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyQueryPool(device, queryPool, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetQueryPoolResults", "queryPool", queryPool);

    skip |= validate_array(local_data->report_data, "vkGetQueryPoolResults", "dataSize", "pData", dataSize, pData, true, true, VALIDATION_ERROR_2fa03c1b, VALIDATION_ERROR_2fa12201);

    skip |= validate_flags(local_data->report_data, "vkGetQueryPoolResults", "flags", "VkQueryResultFlagBits", AllVkQueryResultFlagBits, flags, false, false, VALIDATION_ERROR_2fa09001);

    PFN_manual_vkGetQueryPoolResults custom_func = (PFN_manual_vkGetQueryPoolResults)custom_functions["vkGetQueryPoolResults"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateBuffer(
    VkDevice                                    device,
    const VkBufferCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateBuffer", "pCreateInfo", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, true, VALIDATION_ERROR_0142b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkBufferCreateInfo[] = { VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateBuffer", "pCreateInfo->pNext", "VkDedicatedAllocationBufferCreateInfoNV, VkExternalMemoryBufferCreateInfoKHR", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkBufferCreateInfo), allowed_structs_VkBufferCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_0141c40d);

        skip |= validate_flags(local_data->report_data, "vkCreateBuffer", "pCreateInfo->flags", "VkBufferCreateFlagBits", AllVkBufferCreateFlagBits, pCreateInfo->flags, false, false, VALIDATION_ERROR_01409001);

        skip |= validate_flags(local_data->report_data, "vkCreateBuffer", "pCreateInfo->usage", "VkBufferUsageFlagBits", AllVkBufferUsageFlagBits, pCreateInfo->usage, true, false, VALIDATION_ERROR_01430603);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateBuffer", "pCreateInfo->sharingMode", "VkSharingMode", AllVkSharingModeEnums, pCreateInfo->sharingMode, VALIDATION_ERROR_0142c001);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateBuffer", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateBuffer", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateBuffer", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateBuffer", "pBuffer", pBuffer, VALIDATION_ERROR_1ec10001);

    PFN_manual_vkCreateBuffer custom_func = (PFN_manual_vkCreateBuffer)custom_functions["vkCreateBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pBuffer);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyBuffer", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyBuffer", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyBuffer", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyBuffer custom_func = (PFN_manual_vkDestroyBuffer)custom_functions["vkDestroyBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, buffer, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyBuffer(device, buffer, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateBufferView(
    VkDevice                                    device,
    const VkBufferViewCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateBufferView", "pCreateInfo", "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO, true, VALIDATION_ERROR_01a2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateBufferView", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_01a1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateBufferView", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_01a09005);

        skip |= validate_required_handle(local_data->report_data, "vkCreateBufferView", "pCreateInfo->buffer", pCreateInfo->buffer);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateBufferView", "pCreateInfo->format", "VkFormat", AllVkFormatEnums, pCreateInfo->format, VALIDATION_ERROR_01a09201);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateBufferView", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateBufferView", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateBufferView", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateBufferView", "pView", pView, VALIDATION_ERROR_1ee26a01);

    PFN_manual_vkCreateBufferView custom_func = (PFN_manual_vkCreateBufferView)custom_functions["vkCreateBufferView"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pView);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateBufferView(device, pCreateInfo, pAllocator, pView);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyBufferView", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyBufferView", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyBufferView", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyBufferView custom_func = (PFN_manual_vkDestroyBufferView)custom_functions["vkDestroyBufferView"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, bufferView, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyBufferView(device, bufferView, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateImage(
    VkDevice                                    device,
    const VkImageCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateImage", "pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true, VALIDATION_ERROR_09e2b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkImageCreateInfo[] = { VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateImage", "pCreateInfo->pNext", "VkDedicatedAllocationImageCreateInfoNV, VkExternalMemoryImageCreateInfoKHR, VkExternalMemoryImageCreateInfoNV, VkImageFormatListCreateInfoKHR, VkImageSwapchainCreateInfoKHX", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkImageCreateInfo), allowed_structs_VkImageCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_09e1c40d);

        skip |= validate_flags(local_data->report_data, "vkCreateImage", "pCreateInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pCreateInfo->flags, false, false, VALIDATION_ERROR_09e09001);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImage", "pCreateInfo->imageType", "VkImageType", AllVkImageTypeEnums, pCreateInfo->imageType, VALIDATION_ERROR_09e0ac01);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImage", "pCreateInfo->format", "VkFormat", AllVkFormatEnums, pCreateInfo->format, VALIDATION_ERROR_09e09201);

        // No xml-driven validation

        skip |= validate_flags(local_data->report_data, "vkCreateImage", "pCreateInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pCreateInfo->samples, true, true, VALIDATION_ERROR_09e2b401);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImage", "pCreateInfo->tiling", "VkImageTiling", AllVkImageTilingEnums, pCreateInfo->tiling, VALIDATION_ERROR_09e2fa01);

        skip |= validate_flags(local_data->report_data, "vkCreateImage", "pCreateInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pCreateInfo->usage, true, false, VALIDATION_ERROR_09e30603);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImage", "pCreateInfo->sharingMode", "VkSharingMode", AllVkSharingModeEnums, pCreateInfo->sharingMode, VALIDATION_ERROR_09e2c001);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImage", "pCreateInfo->initialLayout", "VkImageLayout", AllVkImageLayoutEnums, pCreateInfo->initialLayout, VALIDATION_ERROR_09e0b801);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateImage", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateImage", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateImage", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateImage", "pImage", pImage, VALIDATION_ERROR_20c17e01);

    PFN_manual_vkCreateImage custom_func = (PFN_manual_vkCreateImage)custom_functions["vkCreateImage"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pImage);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateImage(device, pCreateInfo, pAllocator, pImage);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyImage", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyImage", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyImage", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyImage custom_func = (PFN_manual_vkDestroyImage)custom_functions["vkDestroyImage"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, image, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyImage(device, image, pAllocator);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    const VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetImageSubresourceLayout", "image", image);

    skip |= validate_required_pointer(local_data->report_data, "vkGetImageSubresourceLayout", "pSubresource", pSubresource, VALIDATION_ERROR_2a624401);

    if (pSubresource != NULL)
    {
        skip |= validate_flags(local_data->report_data, "vkGetImageSubresourceLayout", "pSubresource->aspectMask", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pSubresource->aspectMask, true, false, VALIDATION_ERROR_0a400c03);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkGetImageSubresourceLayout", "pLayout", pLayout, VALIDATION_ERROR_2a61a201);

    PFN_manual_vkGetImageSubresourceLayout custom_func = (PFN_manual_vkGetImageSubresourceLayout)custom_functions["vkGetImageSubresourceLayout"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, image, pSubresource, pLayout);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetImageSubresourceLayout(device, image, pSubresource, pLayout);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateImageView(
    VkDevice                                    device,
    const VkImageViewCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateImageView", "pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, true, VALIDATION_ERROR_0ac2b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkImageViewCreateInfo[] = { VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateImageView", "pCreateInfo->pNext", "VkImageViewUsageCreateInfoKHR, VkSamplerYcbcrConversionInfoKHR", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkImageViewCreateInfo), allowed_structs_VkImageViewCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_0ac1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateImageView", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_0ac09005);

        skip |= validate_required_handle(local_data->report_data, "vkCreateImageView", "pCreateInfo->image", pCreateInfo->image);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImageView", "pCreateInfo->viewType", "VkImageViewType", AllVkImageViewTypeEnums, pCreateInfo->viewType, VALIDATION_ERROR_0ac30801);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImageView", "pCreateInfo->format", "VkFormat", AllVkFormatEnums, pCreateInfo->format, VALIDATION_ERROR_0ac09201);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImageView", "pCreateInfo->components.r", "VkComponentSwizzle", AllVkComponentSwizzleEnums, pCreateInfo->components.r, VALIDATION_ERROR_02e2a201);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImageView", "pCreateInfo->components.g", "VkComponentSwizzle", AllVkComponentSwizzleEnums, pCreateInfo->components.g, VALIDATION_ERROR_02e09a01);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImageView", "pCreateInfo->components.b", "VkComponentSwizzle", AllVkComponentSwizzleEnums, pCreateInfo->components.b, VALIDATION_ERROR_02e01001);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateImageView", "pCreateInfo->components.a", "VkComponentSwizzle", AllVkComponentSwizzleEnums, pCreateInfo->components.a, VALIDATION_ERROR_02e00001);

        skip |= validate_flags(local_data->report_data, "vkCreateImageView", "pCreateInfo->subresourceRange.aspectMask", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCreateInfo->subresourceRange.aspectMask, true, false, VALIDATION_ERROR_0a800c03);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateImageView", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateImageView", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateImageView", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateImageView", "pView", pView, VALIDATION_ERROR_20e26a01);

    PFN_manual_vkCreateImageView custom_func = (PFN_manual_vkCreateImageView)custom_functions["vkCreateImageView"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pView);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateImageView(device, pCreateInfo, pAllocator, pView);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyImageView", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyImageView", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyImageView", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyImageView custom_func = (PFN_manual_vkDestroyImageView)custom_functions["vkDestroyImageView"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, imageView, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyImageView(device, imageView, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateShaderModule", "pCreateInfo", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, true, VALIDATION_ERROR_12a2b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkShaderModuleCreateInfo[] = { VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateShaderModule", "pCreateInfo->pNext", "VkShaderModuleValidationCacheCreateInfoEXT", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkShaderModuleCreateInfo), allowed_structs_VkShaderModuleCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_12a1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateShaderModule", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_12a09005);

        skip |= validate_array(local_data->report_data, "vkCreateShaderModule", "pCreateInfo->codeSize", "pCreateInfo->pCode", pCreateInfo->codeSize, pCreateInfo->pCode, true, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_12a10c01);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateShaderModule", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateShaderModule", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateShaderModule", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateShaderModule", "pShaderModule", pShaderModule, VALIDATION_ERROR_22622e01);

    PFN_manual_vkCreateShaderModule custom_func = (PFN_manual_vkCreateShaderModule)custom_functions["vkCreateShaderModule"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pShaderModule);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyShaderModule", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyShaderModule", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyShaderModule", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyShaderModule custom_func = (PFN_manual_vkDestroyShaderModule)custom_functions["vkDestroyShaderModule"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, shaderModule, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyShaderModule(device, shaderModule, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineCache(
    VkDevice                                    device,
    const VkPipelineCacheCreateInfo*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreatePipelineCache", "pCreateInfo", "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO, true, VALIDATION_ERROR_0f02b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreatePipelineCache", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0f01c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreatePipelineCache", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_0f009005);

        skip |= validate_array(local_data->report_data, "vkCreatePipelineCache", "pCreateInfo->initialDataSize", "pCreateInfo->pInitialData", pCreateInfo->initialDataSize, pCreateInfo->pInitialData, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_0f019601);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreatePipelineCache", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreatePipelineCache", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreatePipelineCache", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreatePipelineCache", "pPipelineCache", pPipelineCache, VALIDATION_ERROR_21a1de01);

    PFN_manual_vkCreatePipelineCache custom_func = (PFN_manual_vkCreatePipelineCache)custom_functions["vkCreatePipelineCache"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pPipelineCache);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipelineCache", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipelineCache", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipelineCache", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyPipelineCache custom_func = (PFN_manual_vkDestroyPipelineCache)custom_functions["vkDestroyPipelineCache"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pipelineCache, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyPipelineCache(device, pipelineCache, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetPipelineCacheData", "pipelineCache", pipelineCache);

    skip |= validate_array(local_data->report_data, "vkGetPipelineCacheData", "pDataSize", "pData", pDataSize, pData, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2f812201);

    PFN_manual_vkGetPipelineCacheData custom_func = (PFN_manual_vkGetPipelineCacheData)custom_functions["vkGetPipelineCacheData"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pipelineCache, pDataSize, pData);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPipelineCacheData(device, pipelineCache, pDataSize, pData);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkMergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    const VkPipelineCache*                      pSrcCaches)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkMergePipelineCaches", "dstCache", dstCache);

    skip |= validate_handle_array(local_data->report_data, "vkMergePipelineCaches", "srcCacheCount", "pSrcCaches", srcCacheCount, pSrcCaches, true, true);

    PFN_manual_vkMergePipelineCaches custom_func = (PFN_manual_vkMergePipelineCaches)custom_functions["vkMergePipelineCaches"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, dstCache, srcCacheCount, pSrcCaches);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkGraphicsPipelineCreateInfo*         pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type_array(local_data->report_data, "vkCreateGraphicsPipelines", "createInfoCount", "pCreateInfos", "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", createInfoCount, pCreateInfos, VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, true, true, VALIDATION_ERROR_20812001);

    if (pCreateInfos != NULL)
    {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex)
        {
            const VkStructureType allowed_structs_VkGraphicsPipelineCreateInfo[] = { VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT };

            skip |= validate_struct_pnext(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineDiscardRectangleStateCreateInfoEXT", pCreateInfos[createInfoIndex].pNext, ARRAY_SIZE(allowed_structs_VkGraphicsPipelineCreateInfo), allowed_structs_VkGraphicsPipelineCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_0961c40d);

            skip |= validate_flags(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlagBits", AllVkPipelineCreateFlagBits, pCreateInfos[createInfoIndex].flags, false, false, VALIDATION_ERROR_09609001);

            skip |= validate_struct_type_array(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].stageCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pStages", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, true, true, VALIDATION_ERROR_09623e01);

            if (pCreateInfos[createInfoIndex].pStages != NULL)
            {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex)
                {
                    skip |= validate_struct_pnext(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pStages[%i].pNext", ParameterName::IndexVector{ createInfoIndex, stageIndex }), NULL, pCreateInfos[createInfoIndex].pStages[stageIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_1061c40d);

                    skip |= validate_reserved_flags(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pStages[%i].flags", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].flags, VALIDATION_ERROR_10609005);

                    skip |= validate_flags(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pStages[%i].stage", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage, true, true, VALIDATION_ERROR_1062d801);

                    skip |= validate_required_handle(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pStages[%i].module", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].module);

                    skip |= validate_required_pointer(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pStages[%i].pName", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pName, VALIDATION_ERROR_1061c001);

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != NULL)
                    {
                        skip |= validate_array(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->dataSize", ParameterName::IndexVector{ createInfoIndex, stageIndex }), ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->pData", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize, pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_13612201);
                    }
                }
            }

            skip |= validate_struct_type(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pVertexInputState", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO", pCreateInfos[createInfoIndex].pVertexInputState, VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, true, VALIDATION_ERROR_10a2b00b);

            if (pCreateInfos[createInfoIndex].pVertexInputState != NULL)
            {
                skip |= validate_struct_pnext(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pVertexInputState->pNext", ParameterName::IndexVector{ createInfoIndex }), NULL, pCreateInfos[createInfoIndex].pVertexInputState->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_10a1c40d);

                skip |= validate_reserved_flags(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pVertexInputState->flags", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pVertexInputState->flags, VALIDATION_ERROR_10a09005);

                skip |= validate_array(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pVertexInputState->vertexBindingDescriptionCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pVertexInputState->pVertexBindingDescriptions", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pVertexInputState->vertexBindingDescriptionCount, pCreateInfos[createInfoIndex].pVertexInputState->pVertexBindingDescriptions, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_10a26601);

                if (pCreateInfos[createInfoIndex].pVertexInputState->pVertexBindingDescriptions != NULL)
                {
                    for (uint32_t vertexBindingDescriptionIndex = 0; vertexBindingDescriptionIndex < pCreateInfos[createInfoIndex].pVertexInputState->vertexBindingDescriptionCount; ++vertexBindingDescriptionIndex)
                    {
                        skip |= validate_ranged_enum(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pVertexInputState->pVertexBindingDescriptions[%i].inputRate", ParameterName::IndexVector{ createInfoIndex, vertexBindingDescriptionIndex }), "VkVertexInputRate", AllVkVertexInputRateEnums, pCreateInfos[createInfoIndex].pVertexInputState->pVertexBindingDescriptions[vertexBindingDescriptionIndex].inputRate, VALIDATION_ERROR_14c0ba01);
                    }
                }

                skip |= validate_array(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pVertexInputState->vertexAttributeDescriptionCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pVertexInputState->pVertexAttributeDescriptions", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pVertexInputState->vertexAttributeDescriptionCount, pCreateInfos[createInfoIndex].pVertexInputState->pVertexAttributeDescriptions, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_10a26401);

                if (pCreateInfos[createInfoIndex].pVertexInputState->pVertexAttributeDescriptions != NULL)
                {
                    for (uint32_t vertexAttributeDescriptionIndex = 0; vertexAttributeDescriptionIndex < pCreateInfos[createInfoIndex].pVertexInputState->vertexAttributeDescriptionCount; ++vertexAttributeDescriptionIndex)
                    {
                        skip |= validate_ranged_enum(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pVertexInputState->pVertexAttributeDescriptions[%i].format", ParameterName::IndexVector{ createInfoIndex, vertexAttributeDescriptionIndex }), "VkFormat", AllVkFormatEnums, pCreateInfos[createInfoIndex].pVertexInputState->pVertexAttributeDescriptions[vertexAttributeDescriptionIndex].format, VALIDATION_ERROR_14a09201);
                    }
                }
            }

            skip |= validate_struct_type(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pInputAssemblyState", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO", pCreateInfos[createInfoIndex].pInputAssemblyState, VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, true, VALIDATION_ERROR_0fc2b00b);

            if (pCreateInfos[createInfoIndex].pInputAssemblyState != NULL)
            {
                skip |= validate_struct_pnext(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pInputAssemblyState->pNext", ParameterName::IndexVector{ createInfoIndex }), NULL, pCreateInfos[createInfoIndex].pInputAssemblyState->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0fc1c40d);

                skip |= validate_reserved_flags(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pInputAssemblyState->flags", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pInputAssemblyState->flags, VALIDATION_ERROR_0fc09005);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pInputAssemblyState->topology", ParameterName::IndexVector{ createInfoIndex }), "VkPrimitiveTopology", AllVkPrimitiveTopologyEnums, pCreateInfos[createInfoIndex].pInputAssemblyState->topology, VALIDATION_ERROR_0fc30001);

                skip |= validate_bool32(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pInputAssemblyState->primitiveRestartEnable", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pInputAssemblyState->primitiveRestartEnable);
            }

            skip |= validate_struct_type(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO", pCreateInfos[createInfoIndex].pRasterizationState, VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, true, VALIDATION_ERROR_1022b00b);

            if (pCreateInfos[createInfoIndex].pRasterizationState != NULL)
            {
                const VkStructureType allowed_structs_VkPipelineRasterizationStateCreateInfo[] = { VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD };

                skip |= validate_struct_pnext(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState->pNext", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationStateRasterizationOrderAMD", pCreateInfos[createInfoIndex].pRasterizationState->pNext, ARRAY_SIZE(allowed_structs_VkPipelineRasterizationStateCreateInfo), allowed_structs_VkPipelineRasterizationStateCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_1021c40d);

                skip |= validate_reserved_flags(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState->flags", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pRasterizationState->flags, VALIDATION_ERROR_10209005);

                skip |= validate_bool32(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState->depthClampEnable", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pRasterizationState->depthClampEnable);

                skip |= validate_bool32(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState->rasterizerDiscardEnable", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pRasterizationState->rasterizerDiscardEnable);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState->polygonMode", ParameterName::IndexVector{ createInfoIndex }), "VkPolygonMode", AllVkPolygonModeEnums, pCreateInfos[createInfoIndex].pRasterizationState->polygonMode, VALIDATION_ERROR_10228601);

                skip |= validate_flags(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState->cullMode", ParameterName::IndexVector{ createInfoIndex }), "VkCullModeFlagBits", AllVkCullModeFlagBits, pCreateInfos[createInfoIndex].pRasterizationState->cullMode, false, false, VALIDATION_ERROR_10203a01);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState->frontFace", ParameterName::IndexVector{ createInfoIndex }), "VkFrontFace", AllVkFrontFaceEnums, pCreateInfos[createInfoIndex].pRasterizationState->frontFace, VALIDATION_ERROR_10209801);

                skip |= validate_bool32(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pRasterizationState->depthBiasEnable", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pRasterizationState->depthBiasEnable);
            }

            skip |= validate_struct_type(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pDynamicState", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO", pCreateInfos[createInfoIndex].pDynamicState, VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, false, VALIDATION_ERROR_0fa2b00b);

            if (pCreateInfos[createInfoIndex].pDynamicState != NULL)
            {
                skip |= validate_struct_pnext(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pDynamicState->pNext", ParameterName::IndexVector{ createInfoIndex }), NULL, pCreateInfos[createInfoIndex].pDynamicState->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0fa1c40d);

                skip |= validate_reserved_flags(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pDynamicState->flags", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pDynamicState->flags, VALIDATION_ERROR_0fa09005);

                skip |= validate_ranged_enum_array(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].pDynamicState->dynamicStateCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pDynamicState->pDynamicStates", ParameterName::IndexVector{ createInfoIndex }), "VkDynamicState", AllVkDynamicStateEnums, pCreateInfos[createInfoIndex].pDynamicState->dynamicStateCount, pCreateInfos[createInfoIndex].pDynamicState->pDynamicStates, true, true);
            }

            skip |= validate_required_handle(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].layout", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].layout);

            skip |= validate_required_handle(local_data->report_data, "vkCreateGraphicsPipelines", ParameterName("pCreateInfos[%i].renderPass", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].renderPass);
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateGraphicsPipelines", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateGraphicsPipelines", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateGraphicsPipelines", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_array(local_data->report_data, "vkCreateGraphicsPipelines", "createInfoCount", "pPipelines", createInfoCount, pPipelines, true, true, VALIDATION_ERROR_2080381b, VALIDATION_ERROR_2081e201);

    PFN_manual_vkCreateGraphicsPipelines custom_func = (PFN_manual_vkCreateGraphicsPipelines)custom_functions["vkCreateGraphicsPipelines"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkComputePipelineCreateInfo*          pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type_array(local_data->report_data, "vkCreateComputePipelines", "createInfoCount", "pCreateInfos", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", createInfoCount, pCreateInfos, VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, true, true, VALIDATION_ERROR_1f212001);

    if (pCreateInfos != NULL)
    {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ createInfoIndex }), NULL, pCreateInfos[createInfoIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0301c40d);

            skip |= validate_flags(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlagBits", AllVkPipelineCreateFlagBits, pCreateInfos[createInfoIndex].flags, false, false, VALIDATION_ERROR_03009001);

            skip |= validate_struct_type(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].stage", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", &(pCreateInfos[createInfoIndex].stage), VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, VALIDATION_ERROR_1062b00b);

            skip |= validate_struct_pnext(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].stage.pNext", ParameterName::IndexVector{ createInfoIndex }), NULL, pCreateInfos[createInfoIndex].stage.pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_1061c40d);

            skip |= validate_reserved_flags(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].stage.flags", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].stage.flags, VALIDATION_ERROR_10609005);

            skip |= validate_flags(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].stage.stage", ParameterName::IndexVector{ createInfoIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].stage.stage, true, true, VALIDATION_ERROR_1062d801);

            skip |= validate_required_handle(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].stage.module", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].stage.module);

            skip |= validate_required_pointer(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].stage.pName", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].stage.pName, VALIDATION_ERROR_1061c001);

            if (pCreateInfos[createInfoIndex].stage.pSpecializationInfo != NULL)
            {
                skip |= validate_array(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].stage.pSpecializationInfo->dataSize", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].stage.pSpecializationInfo->pData", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].stage.pSpecializationInfo->dataSize, pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pData, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_13612201);
            }

            skip |= validate_required_handle(local_data->report_data, "vkCreateComputePipelines", ParameterName("pCreateInfos[%i].layout", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].layout);
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateComputePipelines", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateComputePipelines", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateComputePipelines", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_array(local_data->report_data, "vkCreateComputePipelines", "createInfoCount", "pPipelines", createInfoCount, pPipelines, true, true, VALIDATION_ERROR_1f20381b, VALIDATION_ERROR_1f21e201);

    PFN_manual_vkCreateComputePipelines custom_func = (PFN_manual_vkCreateComputePipelines)custom_functions["vkCreateComputePipelines"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipeline", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipeline", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipeline", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyPipeline custom_func = (PFN_manual_vkDestroyPipeline)custom_functions["vkDestroyPipeline"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pipeline, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyPipeline(device, pipeline, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineLayout(
    VkDevice                                    device,
    const VkPipelineLayoutCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreatePipelineLayout", "pCreateInfo", "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, true, VALIDATION_ERROR_0fe2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreatePipelineLayout", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0fe1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreatePipelineLayout", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_0fe09005);

        skip |= validate_array(local_data->report_data, "vkCreatePipelineLayout", "pCreateInfo->setLayoutCount", "pCreateInfo->pSetLayouts", pCreateInfo->setLayoutCount, pCreateInfo->pSetLayouts, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_0fe22c01);

        skip |= validate_array(local_data->report_data, "vkCreatePipelineLayout", "pCreateInfo->pushConstantRangeCount", "pCreateInfo->pPushConstantRanges", pCreateInfo->pushConstantRangeCount, pCreateInfo->pPushConstantRanges, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_0fe1f801);

        if (pCreateInfo->pPushConstantRanges != NULL)
        {
            for (uint32_t pushConstantRangeIndex = 0; pushConstantRangeIndex < pCreateInfo->pushConstantRangeCount; ++pushConstantRangeIndex)
            {
                skip |= validate_flags(local_data->report_data, "vkCreatePipelineLayout", ParameterName("pCreateInfo->pPushConstantRanges[%i].stageFlags", ParameterName::IndexVector{ pushConstantRangeIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfo->pPushConstantRanges[pushConstantRangeIndex].stageFlags, true, false, VALIDATION_ERROR_11a2dc03);
            }
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreatePipelineLayout", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreatePipelineLayout", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreatePipelineLayout", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreatePipelineLayout", "pPipelineLayout", pPipelineLayout, VALIDATION_ERROR_21c1e001);

    PFN_manual_vkCreatePipelineLayout custom_func = (PFN_manual_vkCreatePipelineLayout)custom_functions["vkCreatePipelineLayout"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pPipelineLayout);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipelineLayout", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipelineLayout", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyPipelineLayout", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyPipelineLayout custom_func = (PFN_manual_vkDestroyPipelineLayout)custom_functions["vkDestroyPipelineLayout"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pipelineLayout, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyPipelineLayout(device, pipelineLayout, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateSampler(
    VkDevice                                    device,
    const VkSamplerCreateInfo*                  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateSampler", "pCreateInfo", "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, true, VALIDATION_ERROR_1262b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkSamplerCreateInfo[] = { VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateSampler", "pCreateInfo->pNext", "VkSamplerReductionModeCreateInfoEXT, VkSamplerYcbcrConversionInfoKHR", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkSamplerCreateInfo), allowed_structs_VkSamplerCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_1261c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateSampler", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_12609005);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSampler", "pCreateInfo->magFilter", "VkFilter", AllVkFilterEnums, pCreateInfo->magFilter, VALIDATION_ERROR_1260c401);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSampler", "pCreateInfo->minFilter", "VkFilter", AllVkFilterEnums, pCreateInfo->minFilter, VALIDATION_ERROR_1260ca01);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSampler", "pCreateInfo->mipmapMode", "VkSamplerMipmapMode", AllVkSamplerMipmapModeEnums, pCreateInfo->mipmapMode, VALIDATION_ERROR_1260cc01);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSampler", "pCreateInfo->addressModeU", "VkSamplerAddressMode", AllVkSamplerAddressModeEnums, pCreateInfo->addressModeU, VALIDATION_ERROR_12600201);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSampler", "pCreateInfo->addressModeV", "VkSamplerAddressMode", AllVkSamplerAddressModeEnums, pCreateInfo->addressModeV, VALIDATION_ERROR_12600401);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSampler", "pCreateInfo->addressModeW", "VkSamplerAddressMode", AllVkSamplerAddressModeEnums, pCreateInfo->addressModeW, VALIDATION_ERROR_12600601);

        skip |= validate_bool32(local_data->report_data, "vkCreateSampler", "pCreateInfo->anisotropyEnable", pCreateInfo->anisotropyEnable);

        skip |= validate_bool32(local_data->report_data, "vkCreateSampler", "pCreateInfo->compareEnable", pCreateInfo->compareEnable);

        skip |= validate_bool32(local_data->report_data, "vkCreateSampler", "pCreateInfo->unnormalizedCoordinates", pCreateInfo->unnormalizedCoordinates);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateSampler", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSampler", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSampler", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateSampler", "pSampler", pSampler, VALIDATION_ERROR_22222401);

    PFN_manual_vkCreateSampler custom_func = (PFN_manual_vkCreateSampler)custom_functions["vkCreateSampler"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pSampler);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateSampler(device, pCreateInfo, pAllocator, pSampler);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroySampler", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySampler", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySampler", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroySampler custom_func = (PFN_manual_vkDestroySampler)custom_functions["vkDestroySampler"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, sampler, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroySampler(device, sampler, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateDescriptorSetLayout", "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, true, VALIDATION_ERROR_0502b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateDescriptorSetLayout", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0501c40d);

        skip |= validate_flags(local_data->report_data, "vkCreateDescriptorSetLayout", "pCreateInfo->flags", "VkDescriptorSetLayoutCreateFlagBits", AllVkDescriptorSetLayoutCreateFlagBits, pCreateInfo->flags, false, false, VALIDATION_ERROR_05009001);

        skip |= validate_array(local_data->report_data, "vkCreateDescriptorSetLayout", "pCreateInfo->bindingCount", "pCreateInfo->pBindings", pCreateInfo->bindingCount, pCreateInfo->pBindings, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_0500fc01);

        if (pCreateInfo->pBindings != NULL)
        {
            for (uint32_t bindingIndex = 0; bindingIndex < pCreateInfo->bindingCount; ++bindingIndex)
            {
                skip |= validate_ranged_enum(local_data->report_data, "vkCreateDescriptorSetLayout", ParameterName("pCreateInfo->pBindings[%i].descriptorType", ParameterName::IndexVector{ bindingIndex }), "VkDescriptorType", AllVkDescriptorTypeEnums, pCreateInfo->pBindings[bindingIndex].descriptorType, VALIDATION_ERROR_04e04e01);
            }
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorSetLayout", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorSetLayout", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorSetLayout", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorSetLayout", "pSetLayout", pSetLayout, VALIDATION_ERROR_1f822a01);

    PFN_manual_vkCreateDescriptorSetLayout custom_func = (PFN_manual_vkCreateDescriptorSetLayout)custom_functions["vkCreateDescriptorSetLayout"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pSetLayout);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorSetLayout", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorSetLayout", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorSetLayout", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyDescriptorSetLayout custom_func = (PFN_manual_vkDestroyDescriptorSetLayout)custom_functions["vkDestroyDescriptorSetLayout"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, descriptorSetLayout, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorPool(
    VkDevice                                    device,
    const VkDescriptorPoolCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateDescriptorPool", "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, true, VALIDATION_ERROR_0482b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateDescriptorPool", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0481c40d);

        skip |= validate_flags(local_data->report_data, "vkCreateDescriptorPool", "pCreateInfo->flags", "VkDescriptorPoolCreateFlagBits", AllVkDescriptorPoolCreateFlagBits, pCreateInfo->flags, false, false, VALIDATION_ERROR_04809001);

        skip |= validate_array(local_data->report_data, "vkCreateDescriptorPool", "pCreateInfo->poolSizeCount", "pCreateInfo->pPoolSizes", pCreateInfo->poolSizeCount, pCreateInfo->pPoolSizes, true, true, VALIDATION_ERROR_0482881b, VALIDATION_ERROR_0481e401);

        if (pCreateInfo->pPoolSizes != NULL)
        {
            for (uint32_t poolSizeIndex = 0; poolSizeIndex < pCreateInfo->poolSizeCount; ++poolSizeIndex)
            {
                skip |= validate_ranged_enum(local_data->report_data, "vkCreateDescriptorPool", ParameterName("pCreateInfo->pPoolSizes[%i].type", ParameterName::IndexVector{ poolSizeIndex }), "VkDescriptorType", AllVkDescriptorTypeEnums, pCreateInfo->pPoolSizes[poolSizeIndex].type, VALIDATION_ERROR_04a30401);
            }
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorPool", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorPool", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorPool", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorPool", "pDescriptorPool", pDescriptorPool, VALIDATION_ERROR_1f612e01);

    PFN_manual_vkCreateDescriptorPool custom_func = (PFN_manual_vkCreateDescriptorPool)custom_functions["vkCreateDescriptorPool"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pDescriptorPool);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorPool", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorPool", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorPool", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyDescriptorPool custom_func = (PFN_manual_vkDestroyDescriptorPool)custom_functions["vkDestroyDescriptorPool"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, descriptorPool, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyDescriptorPool(device, descriptorPool, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkResetDescriptorPool", "descriptorPool", descriptorPool);

    skip |= validate_reserved_flags(local_data->report_data, "vkResetDescriptorPool", "flags", flags, VALIDATION_ERROR_32a09005);

    PFN_manual_vkResetDescriptorPool custom_func = (PFN_manual_vkResetDescriptorPool)custom_functions["vkResetDescriptorPool"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, descriptorPool, flags);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ResetDescriptorPool(device, descriptorPool, flags);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateDescriptorSets(
    VkDevice                                    device,
    const VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkAllocateDescriptorSets", "pAllocateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", pAllocateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, true, VALIDATION_ERROR_04c2b00b);

    if (pAllocateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkAllocateDescriptorSets", "pAllocateInfo->pNext", NULL, pAllocateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_04c1c40d);

        skip |= validate_required_handle(local_data->report_data, "vkAllocateDescriptorSets", "pAllocateInfo->descriptorPool", pAllocateInfo->descriptorPool);

        skip |= validate_handle_array(local_data->report_data, "vkAllocateDescriptorSets", "pAllocateInfo->descriptorSetCount", "pAllocateInfo->pSetLayouts", pAllocateInfo->descriptorSetCount, pAllocateInfo->pSetLayouts, true, true);
    }

    if (pAllocateInfo != NULL) {
        skip |= validate_array(local_data->report_data, "vkAllocateDescriptorSets", "pAllocateInfo->descriptorSetCount", "pDescriptorSets", pAllocateInfo->descriptorSetCount, pDescriptorSets, true, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_16a13001);
    }

    PFN_manual_vkAllocateDescriptorSets custom_func = (PFN_manual_vkAllocateDescriptorSets)custom_functions["vkAllocateDescriptorSets"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pAllocateInfo, pDescriptorSets);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.AllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkFreeDescriptorSets", "descriptorPool", descriptorPool);

    PFN_manual_vkFreeDescriptorSets custom_func = (PFN_manual_vkFreeDescriptorSets)custom_functions["vkFreeDescriptorSets"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, descriptorPool, descriptorSetCount, pDescriptorSets);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const VkCopyDescriptorSet*                  pDescriptorCopies)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type_array(local_data->report_data, "vkUpdateDescriptorSets", "descriptorWriteCount", "pDescriptorWrites", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", descriptorWriteCount, pDescriptorWrites, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, false, true, VALIDATION_ERROR_33c13601);

    if (pDescriptorWrites != NULL)
    {
        for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < descriptorWriteCount; ++descriptorWriteIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkUpdateDescriptorSets", ParameterName("pDescriptorWrites[%i].pNext", ParameterName::IndexVector{ descriptorWriteIndex }), NULL, pDescriptorWrites[descriptorWriteIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_15c1c40d);

            skip |= validate_ranged_enum(local_data->report_data, "vkUpdateDescriptorSets", ParameterName("pDescriptorWrites[%i].descriptorType", ParameterName::IndexVector{ descriptorWriteIndex }), "VkDescriptorType", AllVkDescriptorTypeEnums, pDescriptorWrites[descriptorWriteIndex].descriptorType, VALIDATION_ERROR_15c04e01);
        }
    }

    skip |= validate_struct_type_array(local_data->report_data, "vkUpdateDescriptorSets", "descriptorCopyCount", "pDescriptorCopies", "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", descriptorCopyCount, pDescriptorCopies, VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET, false, true, VALIDATION_ERROR_33c12c01);

    if (pDescriptorCopies != NULL)
    {
        for (uint32_t descriptorCopyIndex = 0; descriptorCopyIndex < descriptorCopyCount; ++descriptorCopyIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkUpdateDescriptorSets", ParameterName("pDescriptorCopies[%i].pNext", ParameterName::IndexVector{ descriptorCopyIndex }), NULL, pDescriptorCopies[descriptorCopyIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0321c40d);

            skip |= validate_required_handle(local_data->report_data, "vkUpdateDescriptorSets", ParameterName("pDescriptorCopies[%i].srcSet", ParameterName::IndexVector{ descriptorCopyIndex }), pDescriptorCopies[descriptorCopyIndex].srcSet);

            skip |= validate_required_handle(local_data->report_data, "vkUpdateDescriptorSets", ParameterName("pDescriptorCopies[%i].dstSet", ParameterName::IndexVector{ descriptorCopyIndex }), pDescriptorCopies[descriptorCopyIndex].dstSet);
        }
    }

    PFN_manual_vkUpdateDescriptorSets custom_func = (PFN_manual_vkUpdateDescriptorSets)custom_functions["vkUpdateDescriptorSets"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateFramebuffer(
    VkDevice                                    device,
    const VkFramebufferCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCreateFramebuffer", "pCreateInfo", "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, true, VALIDATION_ERROR_0942b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateFramebuffer", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0941c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateFramebuffer", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_09409005);

        skip |= validate_required_handle(local_data->report_data, "vkCreateFramebuffer", "pCreateInfo->renderPass", pCreateInfo->renderPass);

        skip |= validate_array(local_data->report_data, "vkCreateFramebuffer", "pCreateInfo->attachmentCount", "pCreateInfo->pAttachments", pCreateInfo->attachmentCount, pCreateInfo->pAttachments, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_0940f201);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateFramebuffer", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateFramebuffer", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateFramebuffer", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateFramebuffer", "pFramebuffer", pFramebuffer, VALIDATION_ERROR_20617801);

    PFN_manual_vkCreateFramebuffer custom_func = (PFN_manual_vkCreateFramebuffer)custom_functions["vkCreateFramebuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pFramebuffer);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyFramebuffer", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyFramebuffer", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyFramebuffer", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyFramebuffer custom_func = (PFN_manual_vkDestroyFramebuffer)custom_functions["vkDestroyFramebuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, framebuffer, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyFramebuffer(device, framebuffer, pAllocator);
    }
}

// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR VkResult VKAPI_CALL vkCreateRenderPass(
    VkDevice                                    device,
    const VkRenderPassCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass);

bool parameter_validation_vkCreateRenderPass(
    VkDevice                                    device,
    const VkRenderPassCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;

    skip |= validate_struct_type(local_data->report_data, "vkCreateRenderPass", "pCreateInfo", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, true, VALIDATION_ERROR_1222b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkRenderPassCreateInfo[] = { VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateRenderPass", "pCreateInfo->pNext", "VkRenderPassInputAttachmentAspectCreateInfoKHR, VkRenderPassMultiviewCreateInfoKHX", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkRenderPassCreateInfo), allowed_structs_VkRenderPassCreateInfo, GeneratedHeaderVersion, VALIDATION_ERROR_1221c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateRenderPass", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_12209005);

        skip |= validate_array(local_data->report_data, "vkCreateRenderPass", "pCreateInfo->attachmentCount", "pCreateInfo->pAttachments", pCreateInfo->attachmentCount, pCreateInfo->pAttachments, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_1220f201);

        if (pCreateInfo->pAttachments != NULL)
        {
            for (uint32_t attachmentIndex = 0; attachmentIndex < pCreateInfo->attachmentCount; ++attachmentIndex)
            {
                skip |= validate_flags(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].flags", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentDescriptionFlagBits", AllVkAttachmentDescriptionFlagBits, pCreateInfo->pAttachments[attachmentIndex].flags, false, false, VALIDATION_ERROR_00809001);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].format", ParameterName::IndexVector{ attachmentIndex }), "VkFormat", AllVkFormatEnums, pCreateInfo->pAttachments[attachmentIndex].format, VALIDATION_ERROR_00809201);

                skip |= validate_flags(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].samples", ParameterName::IndexVector{ attachmentIndex }), "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pCreateInfo->pAttachments[attachmentIndex].samples, true, true, VALIDATION_ERROR_0082b401);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].loadOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentLoadOp", AllVkAttachmentLoadOpEnums, pCreateInfo->pAttachments[attachmentIndex].loadOp, VALIDATION_ERROR_0080c201);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].storeOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentStoreOp", AllVkAttachmentStoreOpEnums, pCreateInfo->pAttachments[attachmentIndex].storeOp, VALIDATION_ERROR_0082e401);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].stencilLoadOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentLoadOp", AllVkAttachmentLoadOpEnums, pCreateInfo->pAttachments[attachmentIndex].stencilLoadOp, VALIDATION_ERROR_0082e001);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].stencilStoreOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentStoreOp", AllVkAttachmentStoreOpEnums, pCreateInfo->pAttachments[attachmentIndex].stencilStoreOp, VALIDATION_ERROR_0082e201);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].initialLayout", ParameterName::IndexVector{ attachmentIndex }), "VkImageLayout", AllVkImageLayoutEnums, pCreateInfo->pAttachments[attachmentIndex].initialLayout, VALIDATION_ERROR_0080b801);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pAttachments[%i].finalLayout", ParameterName::IndexVector{ attachmentIndex }), "VkImageLayout", AllVkImageLayoutEnums, pCreateInfo->pAttachments[attachmentIndex].finalLayout, VALIDATION_ERROR_00808e01);
            }
        }

        skip |= validate_array(local_data->report_data, "vkCreateRenderPass", "pCreateInfo->subpassCount", "pCreateInfo->pSubpasses", pCreateInfo->subpassCount, pCreateInfo->pSubpasses, true, true, VALIDATION_ERROR_1222e61b, VALIDATION_ERROR_12224201);

        if (pCreateInfo->pSubpasses != NULL)
        {
            for (uint32_t subpassIndex = 0; subpassIndex < pCreateInfo->subpassCount; ++subpassIndex)
            {
                skip |= validate_flags(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].flags", ParameterName::IndexVector{ subpassIndex }), "VkSubpassDescriptionFlagBits", AllVkSubpassDescriptionFlagBits, pCreateInfo->pSubpasses[subpassIndex].flags, false, false, VALIDATION_ERROR_14009001);

                skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].pipelineBindPoint", ParameterName::IndexVector{ subpassIndex }), "VkPipelineBindPoint", AllVkPipelineBindPointEnums, pCreateInfo->pSubpasses[subpassIndex].pipelineBindPoint, VALIDATION_ERROR_14027e01);

                skip |= validate_array(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].inputAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments", ParameterName::IndexVector{ subpassIndex }), pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pInputAttachments, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_14019a01);

                if (pCreateInfo->pSubpasses[subpassIndex].pInputAttachments != NULL)
                {
                    for (uint32_t inputAttachmentIndex = 0; inputAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount; ++inputAttachmentIndex)
                    {
                        skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, inputAttachmentIndex }), "VkImageLayout", AllVkImageLayoutEnums, pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].layout, VALIDATION_ERROR_00a0be01);
                    }
                }

                skip |= validate_array(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].colorAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments", ParameterName::IndexVector{ subpassIndex }), pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pColorAttachments, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_14011001);

                if (pCreateInfo->pSubpasses[subpassIndex].pColorAttachments != NULL)
                {
                    for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount; ++colorAttachmentIndex)
                    {
                        skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkImageLayout", AllVkImageLayoutEnums, pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].layout, VALIDATION_ERROR_00a0be01);
                    }
                }

                if (pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments != NULL)
                {
                    for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount; ++colorAttachmentIndex)
                    {
                        skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].pResolveAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkImageLayout", AllVkImageLayoutEnums, pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].layout, VALIDATION_ERROR_00a0be01);
                    }
                }

                if (pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment != NULL)
                {
                    skip |= validate_ranged_enum(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].pDepthStencilAttachment->layout", ParameterName::IndexVector{ subpassIndex }), "VkImageLayout", AllVkImageLayoutEnums, pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->layout, VALIDATION_ERROR_00a0be01);
                }

                skip |= validate_array(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pSubpasses[%i].preserveAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pPreserveAttachments", ParameterName::IndexVector{ subpassIndex }), pCreateInfo->pSubpasses[subpassIndex].preserveAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pPreserveAttachments, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_1401f001);
            }
        }

        skip |= validate_array(local_data->report_data, "vkCreateRenderPass", "pCreateInfo->dependencyCount", "pCreateInfo->pDependencies", pCreateInfo->dependencyCount, pCreateInfo->pDependencies, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_12212601);

        if (pCreateInfo->pDependencies != NULL)
        {
            for (uint32_t dependencyIndex = 0; dependencyIndex < pCreateInfo->dependencyCount; ++dependencyIndex)
            {
                skip |= validate_flags(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pDependencies[%i].srcStageMask", ParameterName::IndexVector{ dependencyIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcStageMask, true, false, VALIDATION_ERROR_13e2d403);

                skip |= validate_flags(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pDependencies[%i].dstStageMask", ParameterName::IndexVector{ dependencyIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstStageMask, true, false, VALIDATION_ERROR_13e07803);

                skip |= validate_flags(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pDependencies[%i].srcAccessMask", ParameterName::IndexVector{ dependencyIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcAccessMask, false, false, VALIDATION_ERROR_13e2c401);

                skip |= validate_flags(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pDependencies[%i].dstAccessMask", ParameterName::IndexVector{ dependencyIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstAccessMask, false, false, VALIDATION_ERROR_13e06801);

                skip |= validate_flags(local_data->report_data, "vkCreateRenderPass", ParameterName("pCreateInfo->pDependencies[%i].dependencyFlags", ParameterName::IndexVector{ dependencyIndex }), "VkDependencyFlagBits", AllVkDependencyFlagBits, pCreateInfo->pDependencies[dependencyIndex].dependencyFlags, false, false, VALIDATION_ERROR_13e03e01);
            }
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateRenderPass", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateRenderPass", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateRenderPass", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateRenderPass", "pRenderPass", pRenderPass, VALIDATION_ERROR_22021601);

    return skip;
}

// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR void VKAPI_CALL vkDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    const VkAllocationCallbacks*                pAllocator);

bool parameter_validation_vkDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyRenderPass", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyRenderPass", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyRenderPass", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    return skip;
}

VKAPI_ATTR void VKAPI_CALL vkGetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetRenderAreaGranularity", "renderPass", renderPass);

    skip |= validate_required_pointer(local_data->report_data, "vkGetRenderAreaGranularity", "pGranularity", pGranularity, VALIDATION_ERROR_30017a01);

    PFN_manual_vkGetRenderAreaGranularity custom_func = (PFN_manual_vkGetRenderAreaGranularity)custom_functions["vkGetRenderAreaGranularity"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, renderPass, pGranularity);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetRenderAreaGranularity(device, renderPass, pGranularity);
    }
}

// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR VkResult VKAPI_CALL vkCreateCommandPool(
    VkDevice                                    device,
    const VkCommandPoolCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool);

bool parameter_validation_vkCreateCommandPool(
    VkDevice                                    device,
    const VkCommandPoolCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;

    skip |= validate_struct_type(local_data->report_data, "vkCreateCommandPool", "pCreateInfo", "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, true, VALIDATION_ERROR_02c2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateCommandPool", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_02c1c40d);

        skip |= validate_flags(local_data->report_data, "vkCreateCommandPool", "pCreateInfo->flags", "VkCommandPoolCreateFlagBits", AllVkCommandPoolCreateFlagBits, pCreateInfo->flags, false, false, VALIDATION_ERROR_02c09001);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateCommandPool", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateCommandPool", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateCommandPool", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateCommandPool", "pCommandPool", pCommandPool, VALIDATION_ERROR_1f011601);

    return skip;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyCommandPool", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyCommandPool", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyCommandPool", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyCommandPool custom_func = (PFN_manual_vkDestroyCommandPool)custom_functions["vkDestroyCommandPool"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, commandPool, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyCommandPool(device, commandPool, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkResetCommandPool", "commandPool", commandPool);

    skip |= validate_flags(local_data->report_data, "vkResetCommandPool", "flags", "VkCommandPoolResetFlagBits", AllVkCommandPoolResetFlagBits, flags, false, false, VALIDATION_ERROR_32809001);

    PFN_manual_vkResetCommandPool custom_func = (PFN_manual_vkResetCommandPool)custom_functions["vkResetCommandPool"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, commandPool, flags);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ResetCommandPool(device, commandPool, flags);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateCommandBuffers(
    VkDevice                                    device,
    const VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkAllocateCommandBuffers", "pAllocateInfo", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", pAllocateInfo, VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, true, VALIDATION_ERROR_0262b00b);

    if (pAllocateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkAllocateCommandBuffers", "pAllocateInfo->pNext", NULL, pAllocateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0261c40d);

        skip |= validate_required_handle(local_data->report_data, "vkAllocateCommandBuffers", "pAllocateInfo->commandPool", pAllocateInfo->commandPool);

        skip |= validate_ranged_enum(local_data->report_data, "vkAllocateCommandBuffers", "pAllocateInfo->level", "VkCommandBufferLevel", AllVkCommandBufferLevelEnums, pAllocateInfo->level, VALIDATION_ERROR_0260c001);
    }

    if (pAllocateInfo != NULL) {
        skip |= validate_array(local_data->report_data, "vkAllocateCommandBuffers", "pAllocateInfo->commandBufferCount", "pCommandBuffers", pAllocateInfo->commandBufferCount, pCommandBuffers, true, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_16811401);
    }

    PFN_manual_vkAllocateCommandBuffers custom_func = (PFN_manual_vkAllocateCommandBuffers)custom_functions["vkAllocateCommandBuffers"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pAllocateInfo, pCommandBuffers);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkFreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkFreeCommandBuffers", "commandPool", commandPool);

    PFN_manual_vkFreeCommandBuffers custom_func = (PFN_manual_vkFreeCommandBuffers)custom_functions["vkFreeCommandBuffers"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, commandPool, commandBufferCount, pCommandBuffers);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkBeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    const VkCommandBufferBeginInfo*             pBeginInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkBeginCommandBuffer", "pBeginInfo", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", pBeginInfo, VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, true, VALIDATION_ERROR_0282b00b);

    if (pBeginInfo != NULL)
    {
        const VkStructureType allowed_structs_VkCommandBufferBeginInfo[] = { VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX };

        skip |= validate_struct_pnext(local_data->report_data, "vkBeginCommandBuffer", "pBeginInfo->pNext", "VkDeviceGroupCommandBufferBeginInfoKHX", pBeginInfo->pNext, ARRAY_SIZE(allowed_structs_VkCommandBufferBeginInfo), allowed_structs_VkCommandBufferBeginInfo, GeneratedHeaderVersion, VALIDATION_ERROR_0281c40d);

        skip |= validate_flags(local_data->report_data, "vkBeginCommandBuffer", "pBeginInfo->flags", "VkCommandBufferUsageFlagBits", AllVkCommandBufferUsageFlagBits, pBeginInfo->flags, false, false, VALIDATION_ERROR_02809001);
    }

    PFN_manual_vkBeginCommandBuffer custom_func = (PFN_manual_vkBeginCommandBuffer)custom_functions["vkBeginCommandBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pBeginInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.BeginCommandBuffer(commandBuffer, pBeginInfo);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkEndCommandBuffer(
    VkCommandBuffer                             commandBuffer)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkEndCommandBuffer custom_func = (PFN_manual_vkEndCommandBuffer)custom_functions["vkEndCommandBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.EndCommandBuffer(commandBuffer);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_flags(local_data->report_data, "vkResetCommandBuffer", "flags", "VkCommandBufferResetFlagBits", AllVkCommandBufferResetFlagBits, flags, false, false, VALIDATION_ERROR_32609001);

    PFN_manual_vkResetCommandBuffer custom_func = (PFN_manual_vkResetCommandBuffer)custom_functions["vkResetCommandBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, flags);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ResetCommandBuffer(commandBuffer, flags);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkCmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdBindPipeline", "pipelineBindPoint", "VkPipelineBindPoint", AllVkPipelineBindPointEnums, pipelineBindPoint, VALIDATION_ERROR_18027e01);

    skip |= validate_required_handle(local_data->report_data, "vkCmdBindPipeline", "pipeline", pipeline);

    PFN_manual_vkCmdBindPipeline custom_func = (PFN_manual_vkCmdBindPipeline)custom_functions["vkCmdBindPipeline"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pipelineBindPoint, pipeline);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewport*                           pViewports)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_array(local_data->report_data, "vkCmdSetViewport", "viewportCount", "pViewports", viewportCount, pViewports, true, true, VALIDATION_ERROR_1e030a1b, VALIDATION_ERROR_1e03fa01);

    if (pViewports != NULL)
    {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex)
        {
            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdSetViewport custom_func = (PFN_manual_vkCmdSetViewport)custom_functions["vkCmdSetViewport"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, firstViewport, viewportCount, pViewports);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const VkRect2D*                             pScissors)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_array(local_data->report_data, "vkCmdSetScissor", "scissorCount", "pScissors", scissorCount, pScissors, true, true, VALIDATION_ERROR_1d82b61b, VALIDATION_ERROR_1d822601);

    if (pScissors != NULL)
    {
        for (uint32_t scissorIndex = 0; scissorIndex < scissorCount; ++scissorIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdSetScissor custom_func = (PFN_manual_vkCmdSetScissor)custom_functions["vkCmdSetScissor"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, firstScissor, scissorCount, pScissors);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkCmdSetLineWidth custom_func = (PFN_manual_vkCmdSetLineWidth)custom_functions["vkCmdSetLineWidth"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, lineWidth);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetLineWidth(commandBuffer, lineWidth);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkCmdSetDepthBias custom_func = (PFN_manual_vkCmdSetDepthBias)custom_functions["vkCmdSetDepthBias"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    const float                                 blendConstants[4])
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_pointer(local_data->report_data, "vkCmdSetBlendConstants", "blendConstants", blendConstants, VALIDATION_ERROR_UNDEFINED);

    PFN_manual_vkCmdSetBlendConstants custom_func = (PFN_manual_vkCmdSetBlendConstants)custom_functions["vkCmdSetBlendConstants"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, blendConstants);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetBlendConstants(commandBuffer, blendConstants);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkCmdSetDepthBounds custom_func = (PFN_manual_vkCmdSetDepthBounds)custom_functions["vkCmdSetDepthBounds"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, minDepthBounds, maxDepthBounds);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_flags(local_data->report_data, "vkCmdSetStencilCompareMask", "faceMask", "VkStencilFaceFlagBits", AllVkStencilFaceFlagBits, faceMask, true, false, VALIDATION_ERROR_1da08403);

    PFN_manual_vkCmdSetStencilCompareMask custom_func = (PFN_manual_vkCmdSetStencilCompareMask)custom_functions["vkCmdSetStencilCompareMask"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, faceMask, compareMask);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_flags(local_data->report_data, "vkCmdSetStencilWriteMask", "faceMask", "VkStencilFaceFlagBits", AllVkStencilFaceFlagBits, faceMask, true, false, VALIDATION_ERROR_1de08403);

    PFN_manual_vkCmdSetStencilWriteMask custom_func = (PFN_manual_vkCmdSetStencilWriteMask)custom_functions["vkCmdSetStencilWriteMask"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, faceMask, writeMask);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_flags(local_data->report_data, "vkCmdSetStencilReference", "faceMask", "VkStencilFaceFlagBits", AllVkStencilFaceFlagBits, faceMask, true, false, VALIDATION_ERROR_1dc08403);

    PFN_manual_vkCmdSetStencilReference custom_func = (PFN_manual_vkCmdSetStencilReference)custom_functions["vkCmdSetStencilReference"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, faceMask, reference);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetStencilReference(commandBuffer, faceMask, reference);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const uint32_t*                             pDynamicOffsets)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdBindDescriptorSets", "pipelineBindPoint", "VkPipelineBindPoint", AllVkPipelineBindPointEnums, pipelineBindPoint, VALIDATION_ERROR_17c27e01);

    skip |= validate_required_handle(local_data->report_data, "vkCmdBindDescriptorSets", "layout", layout);

    skip |= validate_handle_array(local_data->report_data, "vkCmdBindDescriptorSets", "descriptorSetCount", "pDescriptorSets", descriptorSetCount, pDescriptorSets, true, true);

    skip |= validate_array(local_data->report_data, "vkCmdBindDescriptorSets", "dynamicOffsetCount", "pDynamicOffsets", dynamicOffsetCount, pDynamicOffsets, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_17c15401);

    PFN_manual_vkCmdBindDescriptorSets custom_func = (PFN_manual_vkCmdBindDescriptorSets)custom_functions["vkCmdBindDescriptorSets"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdBindIndexBuffer", "buffer", buffer);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdBindIndexBuffer", "indexType", "VkIndexType", AllVkIndexTypeEnums, indexType, VALIDATION_ERROR_17e0b201);

    PFN_manual_vkCmdBindIndexBuffer custom_func = (PFN_manual_vkCmdBindIndexBuffer)custom_functions["vkCmdBindIndexBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, buffer, offset, indexType);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_handle_array(local_data->report_data, "vkCmdBindVertexBuffers", "bindingCount", "pBuffers", bindingCount, pBuffers, true, true);

    skip |= validate_array(local_data->report_data, "vkCmdBindVertexBuffers", "bindingCount", "pOffsets", bindingCount, pOffsets, true, true, VALIDATION_ERROR_1820181b, VALIDATION_ERROR_1821d201);

    PFN_manual_vkCmdBindVertexBuffers custom_func = (PFN_manual_vkCmdBindVertexBuffers)custom_functions["vkCmdBindVertexBuffers"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkCmdDraw custom_func = (PFN_manual_vkCmdDraw)custom_functions["vkCmdDraw"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkCmdDrawIndexed custom_func = (PFN_manual_vkCmdDrawIndexed)custom_functions["vkCmdDrawIndexed"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdDrawIndirect", "buffer", buffer);

    PFN_manual_vkCmdDrawIndirect custom_func = (PFN_manual_vkCmdDrawIndirect)custom_functions["vkCmdDrawIndirect"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, buffer, offset, drawCount, stride);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdDrawIndexedIndirect", "buffer", buffer);

    PFN_manual_vkCmdDrawIndexedIndirect custom_func = (PFN_manual_vkCmdDrawIndexedIndirect)custom_functions["vkCmdDrawIndexedIndirect"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, buffer, offset, drawCount, stride);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkCmdDispatch custom_func = (PFN_manual_vkCmdDispatch)custom_functions["vkCmdDispatch"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, groupCountX, groupCountY, groupCountZ);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdDispatchIndirect", "buffer", buffer);

    PFN_manual_vkCmdDispatchIndirect custom_func = (PFN_manual_vkCmdDispatchIndirect)custom_functions["vkCmdDispatchIndirect"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, buffer, offset);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDispatchIndirect(commandBuffer, buffer, offset);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferCopy*                         pRegions)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyBuffer", "srcBuffer", srcBuffer);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyBuffer", "dstBuffer", dstBuffer);

    skip |= validate_array(local_data->report_data, "vkCmdCopyBuffer", "regionCount", "pRegions", regionCount, pRegions, true, true, VALIDATION_ERROR_18c2ac1b, VALIDATION_ERROR_18c21001);

    if (pRegions != NULL)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdCopyBuffer custom_func = (PFN_manual_vkCmdCopyBuffer)custom_functions["vkCmdCopyBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageCopy*                          pRegions)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyImage", "srcImage", srcImage);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdCopyImage", "srcImageLayout", "VkImageLayout", AllVkImageLayoutEnums, srcImageLayout, VALIDATION_ERROR_1902d001);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyImage", "dstImage", dstImage);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdCopyImage", "dstImageLayout", "VkImageLayout", AllVkImageLayoutEnums, dstImageLayout, VALIDATION_ERROR_19007401);

    skip |= validate_array(local_data->report_data, "vkCmdCopyImage", "regionCount", "pRegions", regionCount, pRegions, true, true, VALIDATION_ERROR_1902ac1b, VALIDATION_ERROR_19021001);

    if (pRegions != NULL)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= validate_flags(local_data->report_data, "vkCmdCopyImage", ParameterName("pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, true, false, VALIDATION_ERROR_0a600c03);

            // No xml-driven validation

            skip |= validate_flags(local_data->report_data, "vkCmdCopyImage", ParameterName("pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, true, false, VALIDATION_ERROR_0a600c03);

            // No xml-driven validation

            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdCopyImage custom_func = (PFN_manual_vkCmdCopyImage)custom_functions["vkCmdCopyImage"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageBlit*                          pRegions,
    VkFilter                                    filter)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdBlitImage", "srcImage", srcImage);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdBlitImage", "srcImageLayout", "VkImageLayout", AllVkImageLayoutEnums, srcImageLayout, VALIDATION_ERROR_1842d001);

    skip |= validate_required_handle(local_data->report_data, "vkCmdBlitImage", "dstImage", dstImage);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdBlitImage", "dstImageLayout", "VkImageLayout", AllVkImageLayoutEnums, dstImageLayout, VALIDATION_ERROR_18407401);

    skip |= validate_array(local_data->report_data, "vkCmdBlitImage", "regionCount", "pRegions", regionCount, pRegions, true, true, VALIDATION_ERROR_1842ac1b, VALIDATION_ERROR_18421001);

    if (pRegions != NULL)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= validate_flags(local_data->report_data, "vkCmdBlitImage", ParameterName("pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, true, false, VALIDATION_ERROR_0a600c03);

            skip |= validate_flags(local_data->report_data, "vkCmdBlitImage", ParameterName("pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, true, false, VALIDATION_ERROR_0a600c03);
        }
    }

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdBlitImage", "filter", "VkFilter", AllVkFilterEnums, filter, VALIDATION_ERROR_18408c01);

    PFN_manual_vkCmdBlitImage custom_func = (PFN_manual_vkCmdBlitImage)custom_functions["vkCmdBlitImage"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyBufferToImage", "srcBuffer", srcBuffer);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyBufferToImage", "dstImage", dstImage);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdCopyBufferToImage", "dstImageLayout", "VkImageLayout", AllVkImageLayoutEnums, dstImageLayout, VALIDATION_ERROR_18e07401);

    skip |= validate_array(local_data->report_data, "vkCmdCopyBufferToImage", "regionCount", "pRegions", regionCount, pRegions, true, true, VALIDATION_ERROR_18e2ac1b, VALIDATION_ERROR_18e21001);

    if (pRegions != NULL)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= validate_flags(local_data->report_data, "vkCmdCopyBufferToImage", ParameterName("pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].imageSubresource.aspectMask, true, false, VALIDATION_ERROR_0a600c03);

            // No xml-driven validation

            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdCopyBufferToImage custom_func = (PFN_manual_vkCmdCopyBufferToImage)custom_functions["vkCmdCopyBufferToImage"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyImageToBuffer", "srcImage", srcImage);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdCopyImageToBuffer", "srcImageLayout", "VkImageLayout", AllVkImageLayoutEnums, srcImageLayout, VALIDATION_ERROR_1922d001);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyImageToBuffer", "dstBuffer", dstBuffer);

    skip |= validate_array(local_data->report_data, "vkCmdCopyImageToBuffer", "regionCount", "pRegions", regionCount, pRegions, true, true, VALIDATION_ERROR_1922ac1b, VALIDATION_ERROR_19221001);

    if (pRegions != NULL)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= validate_flags(local_data->report_data, "vkCmdCopyImageToBuffer", ParameterName("pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].imageSubresource.aspectMask, true, false, VALIDATION_ERROR_0a600c03);

            // No xml-driven validation

            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdCopyImageToBuffer custom_func = (PFN_manual_vkCmdCopyImageToBuffer)custom_functions["vkCmdCopyImageToBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const void*                                 pData)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdUpdateBuffer", "dstBuffer", dstBuffer);

    skip |= validate_array(local_data->report_data, "vkCmdUpdateBuffer", "dataSize", "pData", dataSize, pData, true, true, VALIDATION_ERROR_1e403c1b, VALIDATION_ERROR_1e412201);

    PFN_manual_vkCmdUpdateBuffer custom_func = (PFN_manual_vkCmdUpdateBuffer)custom_functions["vkCmdUpdateBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdFillBuffer", "dstBuffer", dstBuffer);

    PFN_manual_vkCmdFillBuffer custom_func = (PFN_manual_vkCmdFillBuffer)custom_functions["vkCmdFillBuffer"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, dstBuffer, dstOffset, size, data);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdClearColorImage", "image", image);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdClearColorImage", "imageLayout", "VkImageLayout", AllVkImageLayoutEnums, imageLayout, VALIDATION_ERROR_1880a601);

    skip |= validate_required_pointer(local_data->report_data, "vkCmdClearColorImage", "pColor", pColor, VALIDATION_ERROR_18810e01);

    if (pColor != NULL)
    {
        // No xml-driven validation
    }

    skip |= validate_array(local_data->report_data, "vkCmdClearColorImage", "rangeCount", "pRanges", rangeCount, pRanges, true, true, VALIDATION_ERROR_1882a41b, VALIDATION_ERROR_18820601);

    if (pRanges != NULL)
    {
        for (uint32_t rangeIndex = 0; rangeIndex < rangeCount; ++rangeIndex)
        {
            skip |= validate_flags(local_data->report_data, "vkCmdClearColorImage", ParameterName("pRanges[%i].aspectMask", ParameterName::IndexVector{ rangeIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRanges[rangeIndex].aspectMask, true, false, VALIDATION_ERROR_0a800c03);
        }
    }

    PFN_manual_vkCmdClearColorImage custom_func = (PFN_manual_vkCmdClearColorImage)custom_functions["vkCmdClearColorImage"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdClearDepthStencilImage", "image", image);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdClearDepthStencilImage", "imageLayout", "VkImageLayout", AllVkImageLayoutEnums, imageLayout, VALIDATION_ERROR_18a0a601);

    skip |= validate_required_pointer(local_data->report_data, "vkCmdClearDepthStencilImage", "pDepthStencil", pDepthStencil, VALIDATION_ERROR_18a12801);

    if (pDepthStencil != NULL)
    {
        // No xml-driven validation
    }

    skip |= validate_array(local_data->report_data, "vkCmdClearDepthStencilImage", "rangeCount", "pRanges", rangeCount, pRanges, true, true, VALIDATION_ERROR_18a2a41b, VALIDATION_ERROR_18a20601);

    if (pRanges != NULL)
    {
        for (uint32_t rangeIndex = 0; rangeIndex < rangeCount; ++rangeIndex)
        {
            skip |= validate_flags(local_data->report_data, "vkCmdClearDepthStencilImage", ParameterName("pRanges[%i].aspectMask", ParameterName::IndexVector{ rangeIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRanges[rangeIndex].aspectMask, true, false, VALIDATION_ERROR_0a800c03);
        }
    }

    PFN_manual_vkCmdClearDepthStencilImage custom_func = (PFN_manual_vkCmdClearDepthStencilImage)custom_functions["vkCmdClearDepthStencilImage"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    const VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    const VkClearRect*                          pRects)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_array(local_data->report_data, "vkCmdClearAttachments", "attachmentCount", "pAttachments", attachmentCount, pAttachments, true, true, VALIDATION_ERROR_18600e1b, VALIDATION_ERROR_1860f201);

    if (pAttachments != NULL)
    {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex)
        {
            skip |= validate_flags(local_data->report_data, "vkCmdClearAttachments", ParameterName("pAttachments[%i].aspectMask", ParameterName::IndexVector{ attachmentIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pAttachments[attachmentIndex].aspectMask, true, false, VALIDATION_ERROR_01c00c03);

            // No xml-driven validation

            // No xml-driven validation
        }
    }

    skip |= validate_array(local_data->report_data, "vkCmdClearAttachments", "rectCount", "pRects", rectCount, pRects, true, true, VALIDATION_ERROR_1862aa1b, VALIDATION_ERROR_18620e01);

    if (pRects != NULL)
    {
        for (uint32_t rectIndex = 0; rectIndex < rectCount; ++rectIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdClearAttachments custom_func = (PFN_manual_vkCmdClearAttachments)custom_functions["vkCmdClearAttachments"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageResolve*                       pRegions)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdResolveImage", "srcImage", srcImage);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdResolveImage", "srcImageLayout", "VkImageLayout", AllVkImageLayoutEnums, srcImageLayout, VALIDATION_ERROR_1c82d001);

    skip |= validate_required_handle(local_data->report_data, "vkCmdResolveImage", "dstImage", dstImage);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdResolveImage", "dstImageLayout", "VkImageLayout", AllVkImageLayoutEnums, dstImageLayout, VALIDATION_ERROR_1c807401);

    skip |= validate_array(local_data->report_data, "vkCmdResolveImage", "regionCount", "pRegions", regionCount, pRegions, true, true, VALIDATION_ERROR_1c82ac1b, VALIDATION_ERROR_1c821001);

    if (pRegions != NULL)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= validate_flags(local_data->report_data, "vkCmdResolveImage", ParameterName("pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, true, false, VALIDATION_ERROR_0a600c03);

            // No xml-driven validation

            skip |= validate_flags(local_data->report_data, "vkCmdResolveImage", ParameterName("pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, true, false, VALIDATION_ERROR_0a600c03);

            // No xml-driven validation

            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdResolveImage custom_func = (PFN_manual_vkCmdResolveImage)custom_functions["vkCmdResolveImage"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdSetEvent", "event", event);

    skip |= validate_flags(local_data->report_data, "vkCmdSetEvent", "stageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, stageMask, true, false, VALIDATION_ERROR_1d42de03);

    PFN_manual_vkCmdSetEvent custom_func = (PFN_manual_vkCmdSetEvent)custom_functions["vkCmdSetEvent"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, event, stageMask);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetEvent(commandBuffer, event, stageMask);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdResetEvent", "event", event);

    skip |= validate_flags(local_data->report_data, "vkCmdResetEvent", "stageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, stageMask, true, false, VALIDATION_ERROR_1c42de03);

    PFN_manual_vkCmdResetEvent custom_func = (PFN_manual_vkCmdResetEvent)custom_functions["vkCmdResetEvent"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, event, stageMask);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdResetEvent(commandBuffer, event, stageMask);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_handle_array(local_data->report_data, "vkCmdWaitEvents", "eventCount", "pEvents", eventCount, pEvents, true, true);

    skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", "srcStageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, srcStageMask, true, false, VALIDATION_ERROR_1e62d403);

    skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", "dstStageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, dstStageMask, true, false, VALIDATION_ERROR_1e607803);

    skip |= validate_struct_type_array(local_data->report_data, "vkCmdWaitEvents", "memoryBarrierCount", "pMemoryBarriers", "VK_STRUCTURE_TYPE_MEMORY_BARRIER", memoryBarrierCount, pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER, false, true, VALIDATION_ERROR_1e61ac01);

    if (pMemoryBarriers != NULL)
    {
        for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < memoryBarrierCount; ++memoryBarrierIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkCmdWaitEvents", ParameterName("pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ memoryBarrierIndex }), NULL, pMemoryBarriers[memoryBarrierIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0c81c40d);

            skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", ParameterName("pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].srcAccessMask, false, false, VALIDATION_ERROR_0c82c401);

            skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", ParameterName("pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].dstAccessMask, false, false, VALIDATION_ERROR_0c806801);
        }
    }

    skip |= validate_struct_type_array(local_data->report_data, "vkCmdWaitEvents", "bufferMemoryBarrierCount", "pBufferMemoryBarriers", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", bufferMemoryBarrierCount, pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, false, true, VALIDATION_ERROR_1e610401);

    if (pBufferMemoryBarriers != NULL)
    {
        for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkCmdWaitEvents", ParameterName("pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), NULL, pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0181c40d);

            skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", ParameterName("pBufferMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, false, false, VALIDATION_ERROR_0182c401);

            skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", ParameterName("pBufferMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, false, false, VALIDATION_ERROR_01806801);

            skip |= validate_required_handle(local_data->report_data, "vkCmdWaitEvents", ParameterName("pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
        }
    }

    skip |= validate_struct_type_array(local_data->report_data, "vkCmdWaitEvents", "imageMemoryBarrierCount", "pImageMemoryBarriers", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", imageMemoryBarrierCount, pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, false, true, VALIDATION_ERROR_1e618a01);

    if (pImageMemoryBarriers != NULL)
    {
        for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
        {
            const VkStructureType allowed_structs_VkImageMemoryBarrier[] = { VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

            skip |= validate_struct_pnext(local_data->report_data, "vkCmdWaitEvents", ParameterName("pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkSampleLocationsInfoEXT", pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, ARRAY_SIZE(allowed_structs_VkImageMemoryBarrier), allowed_structs_VkImageMemoryBarrier, GeneratedHeaderVersion, VALIDATION_ERROR_0a01c40d);

            skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", ParameterName("pImageMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, false, false, VALIDATION_ERROR_0a02c401);

            skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", ParameterName("pImageMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, false, false, VALIDATION_ERROR_0a006801);

            skip |= validate_ranged_enum(local_data->report_data, "vkCmdWaitEvents", ParameterName("pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", AllVkImageLayoutEnums, pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, VALIDATION_ERROR_0a00dc01);

            skip |= validate_ranged_enum(local_data->report_data, "vkCmdWaitEvents", ParameterName("pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", AllVkImageLayoutEnums, pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, VALIDATION_ERROR_0a00d401);

            skip |= validate_required_handle(local_data->report_data, "vkCmdWaitEvents", ParameterName("pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ imageMemoryBarrierIndex }), pImageMemoryBarriers[imageMemoryBarrierIndex].image);

            skip |= validate_flags(local_data->report_data, "vkCmdWaitEvents", ParameterName("pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, true, false, VALIDATION_ERROR_0a800c03);
        }
    }

    PFN_manual_vkCmdWaitEvents custom_func = (PFN_manual_vkCmdWaitEvents)custom_functions["vkCmdWaitEvents"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", "srcStageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, srcStageMask, true, false, VALIDATION_ERROR_1b82d403);

    skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", "dstStageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, dstStageMask, true, false, VALIDATION_ERROR_1b807803);

    skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", "dependencyFlags", "VkDependencyFlagBits", AllVkDependencyFlagBits, dependencyFlags, false, false, VALIDATION_ERROR_1b803e01);

    skip |= validate_struct_type_array(local_data->report_data, "vkCmdPipelineBarrier", "memoryBarrierCount", "pMemoryBarriers", "VK_STRUCTURE_TYPE_MEMORY_BARRIER", memoryBarrierCount, pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER, false, true, VALIDATION_ERROR_1b81ac01);

    if (pMemoryBarriers != NULL)
    {
        for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < memoryBarrierCount; ++memoryBarrierIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ memoryBarrierIndex }), NULL, pMemoryBarriers[memoryBarrierIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0c81c40d);

            skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].srcAccessMask, false, false, VALIDATION_ERROR_0c82c401);

            skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].dstAccessMask, false, false, VALIDATION_ERROR_0c806801);
        }
    }

    skip |= validate_struct_type_array(local_data->report_data, "vkCmdPipelineBarrier", "bufferMemoryBarrierCount", "pBufferMemoryBarriers", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", bufferMemoryBarrierCount, pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, false, true, VALIDATION_ERROR_1b810401);

    if (pBufferMemoryBarriers != NULL)
    {
        for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), NULL, pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0181c40d);

            skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pBufferMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, false, false, VALIDATION_ERROR_0182c401);

            skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pBufferMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, false, false, VALIDATION_ERROR_01806801);

            skip |= validate_required_handle(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
        }
    }

    skip |= validate_struct_type_array(local_data->report_data, "vkCmdPipelineBarrier", "imageMemoryBarrierCount", "pImageMemoryBarriers", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", imageMemoryBarrierCount, pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, false, true, VALIDATION_ERROR_1b818a01);

    if (pImageMemoryBarriers != NULL)
    {
        for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
        {
            const VkStructureType allowed_structs_VkImageMemoryBarrier[] = { VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

            skip |= validate_struct_pnext(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkSampleLocationsInfoEXT", pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, ARRAY_SIZE(allowed_structs_VkImageMemoryBarrier), allowed_structs_VkImageMemoryBarrier, GeneratedHeaderVersion, VALIDATION_ERROR_0a01c40d);

            skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pImageMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, false, false, VALIDATION_ERROR_0a02c401);

            skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pImageMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, false, false, VALIDATION_ERROR_0a006801);

            skip |= validate_ranged_enum(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", AllVkImageLayoutEnums, pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, VALIDATION_ERROR_0a00dc01);

            skip |= validate_ranged_enum(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", AllVkImageLayoutEnums, pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, VALIDATION_ERROR_0a00d401);

            skip |= validate_required_handle(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ imageMemoryBarrierIndex }), pImageMemoryBarriers[imageMemoryBarrierIndex].image);

            skip |= validate_flags(local_data->report_data, "vkCmdPipelineBarrier", ParameterName("pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, true, false, VALIDATION_ERROR_0a800c03);
        }
    }

    PFN_manual_vkCmdPipelineBarrier custom_func = (PFN_manual_vkCmdPipelineBarrier)custom_functions["vkCmdPipelineBarrier"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdBeginQuery", "queryPool", queryPool);

    skip |= validate_flags(local_data->report_data, "vkCmdBeginQuery", "flags", "VkQueryControlFlagBits", AllVkQueryControlFlagBits, flags, false, false, VALIDATION_ERROR_17809001);

    PFN_manual_vkCmdBeginQuery custom_func = (PFN_manual_vkCmdBeginQuery)custom_functions["vkCmdBeginQuery"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, queryPool, query, flags);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdBeginQuery(commandBuffer, queryPool, query, flags);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdEndQuery", "queryPool", queryPool);

    PFN_manual_vkCmdEndQuery custom_func = (PFN_manual_vkCmdEndQuery)custom_functions["vkCmdEndQuery"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, queryPool, query);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdEndQuery(commandBuffer, queryPool, query);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdResetQueryPool", "queryPool", queryPool);

    PFN_manual_vkCmdResetQueryPool custom_func = (PFN_manual_vkCmdResetQueryPool)custom_functions["vkCmdResetQueryPool"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, queryPool, firstQuery, queryCount);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_flags(local_data->report_data, "vkCmdWriteTimestamp", "pipelineStage", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pipelineStage, true, true, VALIDATION_ERROR_1e828401);

    skip |= validate_required_handle(local_data->report_data, "vkCmdWriteTimestamp", "queryPool", queryPool);

    PFN_manual_vkCmdWriteTimestamp custom_func = (PFN_manual_vkCmdWriteTimestamp)custom_functions["vkCmdWriteTimestamp"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pipelineStage, queryPool, query);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyQueryPoolResults", "queryPool", queryPool);

    skip |= validate_required_handle(local_data->report_data, "vkCmdCopyQueryPoolResults", "dstBuffer", dstBuffer);

    skip |= validate_flags(local_data->report_data, "vkCmdCopyQueryPoolResults", "flags", "VkQueryResultFlagBits", AllVkQueryResultFlagBits, flags, false, false, VALIDATION_ERROR_19409001);

    PFN_manual_vkCmdCopyQueryPoolResults custom_func = (PFN_manual_vkCmdCopyQueryPoolResults)custom_functions["vkCmdCopyQueryPoolResults"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const void*                                 pValues)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkCmdPushConstants", "layout", layout);

    skip |= validate_flags(local_data->report_data, "vkCmdPushConstants", "stageFlags", "VkShaderStageFlagBits", AllVkShaderStageFlagBits, stageFlags, true, false, VALIDATION_ERROR_1bc2dc03);

    skip |= validate_array(local_data->report_data, "vkCmdPushConstants", "size", "pValues", size, pValues, true, true, VALIDATION_ERROR_1bc2c21b, VALIDATION_ERROR_1bc26201);

    PFN_manual_vkCmdPushConstants custom_func = (PFN_manual_vkCmdPushConstants)custom_functions["vkCmdPushConstants"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, layout, stageFlags, offset, size, pValues);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkCmdBeginRenderPass", "pRenderPassBegin", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", pRenderPassBegin, VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, true, VALIDATION_ERROR_1202b00b);

    if (pRenderPassBegin != NULL)
    {
        const VkStructureType allowed_structs_VkRenderPassBeginInfo[] = { VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX, VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT };

        skip |= validate_struct_pnext(local_data->report_data, "vkCmdBeginRenderPass", "pRenderPassBegin->pNext", "VkDeviceGroupRenderPassBeginInfoKHX, VkRenderPassSampleLocationsBeginInfoEXT", pRenderPassBegin->pNext, ARRAY_SIZE(allowed_structs_VkRenderPassBeginInfo), allowed_structs_VkRenderPassBeginInfo, GeneratedHeaderVersion, VALIDATION_ERROR_1201c40d);

        skip |= validate_required_handle(local_data->report_data, "vkCmdBeginRenderPass", "pRenderPassBegin->renderPass", pRenderPassBegin->renderPass);

        skip |= validate_required_handle(local_data->report_data, "vkCmdBeginRenderPass", "pRenderPassBegin->framebuffer", pRenderPassBegin->framebuffer);

        // No xml-driven validation

        // No xml-driven validation
    }

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdBeginRenderPass", "contents", "VkSubpassContents", AllVkSubpassContentsEnums, contents, VALIDATION_ERROR_17a03201);

    PFN_manual_vkCmdBeginRenderPass custom_func = (PFN_manual_vkCmdBeginRenderPass)custom_functions["vkCmdBeginRenderPass"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pRenderPassBegin, contents);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdNextSubpass", "contents", "VkSubpassContents", AllVkSubpassContentsEnums, contents, VALIDATION_ERROR_1b603201);

    PFN_manual_vkCmdNextSubpass custom_func = (PFN_manual_vkCmdNextSubpass)custom_functions["vkCmdNextSubpass"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, contents);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdNextSubpass(commandBuffer, contents);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderPass(
    VkCommandBuffer                             commandBuffer)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    // No xml-driven validation

    PFN_manual_vkCmdEndRenderPass custom_func = (PFN_manual_vkCmdEndRenderPass)custom_functions["vkCmdEndRenderPass"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdEndRenderPass(commandBuffer);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_handle_array(local_data->report_data, "vkCmdExecuteCommands", "commandBufferCount", "pCommandBuffers", commandBufferCount, pCommandBuffers, true, true);

    PFN_manual_vkCmdExecuteCommands custom_func = (PFN_manual_vkCmdExecuteCommands)custom_functions["vkCmdExecuteCommands"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, commandBufferCount, pCommandBuffers);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
    }
}



VKAPI_ATTR void VKAPI_CALL vkDestroySurfaceKHR(
    VkInstance                                  instance,
    VkSurfaceKHR                                surface,
    const VkAllocationCallbacks*                pAllocator)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkDestroySurfaceKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroySurfaceKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySurfaceKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySurfaceKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroySurfaceKHR custom_func = (PFN_manual_vkDestroySurfaceKHR)custom_functions["vkDestroySurfaceKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, surface, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroySurfaceKHR(instance, surface, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    VkSurfaceKHR                                surface,
    VkBool32*                                   pSupported)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceSupportKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetPhysicalDeviceSurfaceSupportKHR", "surface", surface);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceSurfaceSupportKHR", "pSupported", pSupported, VALIDATION_ERROR_2ee24601);

    PFN_manual_vkGetPhysicalDeviceSurfaceSupportKHR custom_func = (PFN_manual_vkGetPhysicalDeviceSurfaceSupportKHR)custom_functions["vkGetPhysicalDeviceSurfaceSupportKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, queueFamilyIndex, surface, pSupported);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", "surface", surface);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", "pSurfaceCapabilities", pSurfaceCapabilities, VALIDATION_ERROR_2e624a01);

    PFN_manual_vkGetPhysicalDeviceSurfaceCapabilitiesKHR custom_func = (PFN_manual_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)custom_functions["vkGetPhysicalDeviceSurfaceCapabilitiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, surface, pSurfaceCapabilities);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormatKHR*                         pSurfaceFormats)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceFormatsKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetPhysicalDeviceSurfaceFormatsKHR", "surface", surface);

    skip |= validate_array(local_data->report_data, "vkGetPhysicalDeviceSurfaceFormatsKHR", "pSurfaceFormatCount", "pSurfaceFormats", pSurfaceFormatCount, pSurfaceFormats, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2ea24e01);

    PFN_manual_vkGetPhysicalDeviceSurfaceFormatsKHR custom_func = (PFN_manual_vkGetPhysicalDeviceSurfaceFormatsKHR)custom_functions["vkGetPhysicalDeviceSurfaceFormatsKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfacePresentModesKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetPhysicalDeviceSurfacePresentModesKHR", "surface", surface);

    skip |= validate_array(local_data->report_data, "vkGetPhysicalDeviceSurfacePresentModesKHR", "pPresentModeCount", "pPresentModes", pPresentModeCount, pPresentModes, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2ec1ea01);

    PFN_manual_vkGetPhysicalDeviceSurfacePresentModesKHR custom_func = (PFN_manual_vkGetPhysicalDeviceSurfacePresentModesKHR)custom_functions["vkGetPhysicalDeviceSurfacePresentModesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, surface, pPresentModeCount, pPresentModes);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
    }
    return result;
}



VKAPI_ATTR VkResult VKAPI_CALL vkCreateSwapchainKHR(
    VkDevice                                    device,
    const VkSwapchainCreateInfoKHR*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateSwapchainKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkCreateSwapchainKHR", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, true, VALIDATION_ERROR_1462b00b);

    if (pCreateInfo != NULL)
    {
        const VkStructureType allowed_structs_VkSwapchainCreateInfoKHR[] = { VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX, VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT };

        skip |= validate_struct_pnext(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->pNext", "VkDeviceGroupSwapchainCreateInfoKHX, VkSwapchainCounterCreateInfoEXT", pCreateInfo->pNext, ARRAY_SIZE(allowed_structs_VkSwapchainCreateInfoKHR), allowed_structs_VkSwapchainCreateInfoKHR, GeneratedHeaderVersion, VALIDATION_ERROR_1461c40d);

        skip |= validate_flags(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->flags", "VkSwapchainCreateFlagBitsKHR", AllVkSwapchainCreateFlagBitsKHR, pCreateInfo->flags, false, false, VALIDATION_ERROR_14609001);

        skip |= validate_required_handle(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->surface", pCreateInfo->surface);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->imageFormat", "VkFormat", AllVkFormatEnums, pCreateInfo->imageFormat, VALIDATION_ERROR_1460a401);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->imageColorSpace", "VkColorSpaceKHR", AllVkColorSpaceKHREnums, pCreateInfo->imageColorSpace, VALIDATION_ERROR_1460a201);

        // No xml-driven validation

        skip |= validate_flags(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->imageUsage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pCreateInfo->imageUsage, true, false, VALIDATION_ERROR_1460ae03);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->imageSharingMode", "VkSharingMode", AllVkSharingModeEnums, pCreateInfo->imageSharingMode, VALIDATION_ERROR_1460a801);

        skip |= validate_flags(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->preTransform", "VkSurfaceTransformFlagBitsKHR", AllVkSurfaceTransformFlagBitsKHR, pCreateInfo->preTransform, true, true, VALIDATION_ERROR_14629401);

        skip |= validate_flags(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->compositeAlpha", "VkCompositeAlphaFlagBitsKHR", AllVkCompositeAlphaFlagBitsKHR, pCreateInfo->compositeAlpha, true, true, VALIDATION_ERROR_14602e01);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->presentMode", "VkPresentModeKHR", AllVkPresentModeKHREnums, pCreateInfo->presentMode, VALIDATION_ERROR_14629601);

        skip |= validate_bool32(local_data->report_data, "vkCreateSwapchainKHR", "pCreateInfo->clipped", pCreateInfo->clipped);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateSwapchainKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSwapchainKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSwapchainKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateSwapchainKHR", "pSwapchain", pSwapchain, VALIDATION_ERROR_22a25201);

    PFN_manual_vkCreateSwapchainKHR custom_func = (PFN_manual_vkCreateSwapchainKHR)custom_functions["vkCreateSwapchainKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pSwapchain);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroySwapchainKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkDestroySwapchainKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkDestroySwapchainKHR", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroySwapchainKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySwapchainKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySwapchainKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroySwapchainKHR custom_func = (PFN_manual_vkDestroySwapchainKHR)custom_functions["vkDestroySwapchainKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchain, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroySwapchainKHR(device, swapchain, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainImagesKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pSwapchainImageCount,
    VkImage*                                    pSwapchainImages)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetSwapchainImagesKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkGetSwapchainImagesKHR", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetSwapchainImagesKHR", "swapchain", swapchain);

    skip |= validate_array(local_data->report_data, "vkGetSwapchainImagesKHR", "pSwapchainImageCount", "pSwapchainImages", pSwapchainImageCount, pSwapchainImages, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_30825601);

    PFN_manual_vkGetSwapchainImagesKHR custom_func = (PFN_manual_vkGetSwapchainImagesKHR)custom_functions["vkGetSwapchainImagesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchain, pSwapchainImageCount, pSwapchainImages);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkAcquireNextImageKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t*                                   pImageIndex)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkAcquireNextImageKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkAcquireNextImageKHR", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkAcquireNextImageKHR", "swapchain", swapchain);

    skip |= validate_required_pointer(local_data->report_data, "vkAcquireNextImageKHR", "pImageIndex", pImageIndex, VALIDATION_ERROR_16418601);

    PFN_manual_vkAcquireNextImageKHR custom_func = (PFN_manual_vkAcquireNextImageKHR)custom_functions["vkAcquireNextImageKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchain, timeout, semaphore, fence, pImageIndex);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkQueuePresentKHR(
    VkQueue                                     queue,
    const VkPresentInfoKHR*                     pPresentInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(queue), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkQueuePresentKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkQueuePresentKHR", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkQueuePresentKHR", "pPresentInfo", "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR", pPresentInfo, VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, true, VALIDATION_ERROR_1122b00b);

    if (pPresentInfo != NULL)
    {
        const VkStructureType allowed_structs_VkPresentInfoKHR[] = { VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX, VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR, VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR, VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE };

        skip |= validate_struct_pnext(local_data->report_data, "vkQueuePresentKHR", "pPresentInfo->pNext", "VkDeviceGroupPresentInfoKHX, VkDisplayPresentInfoKHR, VkPresentRegionsKHR, VkPresentTimesInfoGOOGLE", pPresentInfo->pNext, ARRAY_SIZE(allowed_structs_VkPresentInfoKHR), allowed_structs_VkPresentInfoKHR, GeneratedHeaderVersion, VALIDATION_ERROR_1121c40d);

        skip |= validate_array(local_data->report_data, "vkQueuePresentKHR", "pPresentInfo->waitSemaphoreCount", "pPresentInfo->pWaitSemaphores", pPresentInfo->waitSemaphoreCount, pPresentInfo->pWaitSemaphores, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_11227601);

        skip |= validate_handle_array(local_data->report_data, "vkQueuePresentKHR", "pPresentInfo->swapchainCount", "pPresentInfo->pSwapchains", pPresentInfo->swapchainCount, pPresentInfo->pSwapchains, true, true);

        skip |= validate_array(local_data->report_data, "vkQueuePresentKHR", "pPresentInfo->swapchainCount", "pPresentInfo->pImageIndices", pPresentInfo->swapchainCount, pPresentInfo->pImageIndices, true, true, VALIDATION_ERROR_1122f21b, VALIDATION_ERROR_11218801);

        skip |= validate_array(local_data->report_data, "vkQueuePresentKHR", "pPresentInfo->swapchainCount", "pPresentInfo->pResults", pPresentInfo->swapchainCount, pPresentInfo->pResults, true, false, VALIDATION_ERROR_1122f21b, VALIDATION_ERROR_11221e01);
    }

    PFN_manual_vkQueuePresentKHR custom_func = (PFN_manual_vkQueuePresentKHR)custom_functions["vkQueuePresentKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(queue, pPresentInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.QueuePresentKHR(queue, pPresentInfo);
    }
    return result;
}



VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPropertiesKHR*                     pProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceDisplayPropertiesKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceDisplayPropertiesKHR", VK_KHR_DISPLAY_EXTENSION_NAME);

    skip |= validate_array(local_data->report_data, "vkGetPhysicalDeviceDisplayPropertiesKHR", "pPropertyCount", "pProperties", pPropertyCount, pProperties, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2b81f401);

    PFN_manual_vkGetPhysicalDeviceDisplayPropertiesKHR custom_func = (PFN_manual_vkGetPhysicalDeviceDisplayPropertiesKHR)custom_functions["vkGetPhysicalDeviceDisplayPropertiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pPropertyCount, pProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlanePropertiesKHR*                pProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR", VK_KHR_DISPLAY_EXTENSION_NAME);

    skip |= validate_array(local_data->report_data, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR", "pPropertyCount", "pProperties", pPropertyCount, pProperties, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2b61f401);

    PFN_manual_vkGetPhysicalDeviceDisplayPlanePropertiesKHR custom_func = (PFN_manual_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)custom_functions["vkGetPhysicalDeviceDisplayPlanePropertiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pPropertyCount, pProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    planeIndex,
    uint32_t*                                   pDisplayCount,
    VkDisplayKHR*                               pDisplays)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetDisplayPlaneSupportedDisplaysKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkGetDisplayPlaneSupportedDisplaysKHR", VK_KHR_DISPLAY_EXTENSION_NAME);

    skip |= validate_array(local_data->report_data, "vkGetDisplayPlaneSupportedDisplaysKHR", "pDisplayCount", "pDisplays", pDisplayCount, pDisplays, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_29c15201);

    PFN_manual_vkGetDisplayPlaneSupportedDisplaysKHR custom_func = (PFN_manual_vkGetDisplayPlaneSupportedDisplaysKHR)custom_functions["vkGetDisplayPlaneSupportedDisplaysKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, planeIndex, pDisplayCount, pDisplays);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModePropertiesKHR*                 pProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetDisplayModePropertiesKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkGetDisplayModePropertiesKHR", VK_KHR_DISPLAY_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetDisplayModePropertiesKHR", "display", display);

    skip |= validate_array(local_data->report_data, "vkGetDisplayModePropertiesKHR", "pPropertyCount", "pProperties", pPropertyCount, pProperties, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2981f401);

    PFN_manual_vkGetDisplayModePropertiesKHR custom_func = (PFN_manual_vkGetDisplayModePropertiesKHR)custom_functions["vkGetDisplayModePropertiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, display, pPropertyCount, pProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayModeKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    const VkDisplayModeCreateInfoKHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDisplayModeKHR*                           pMode)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateDisplayModeKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkCreateDisplayModeKHR", VK_KHR_DISPLAY_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkCreateDisplayModeKHR", "display", display);

    skip |= validate_struct_type(local_data->report_data, "vkCreateDisplayModeKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR, true, VALIDATION_ERROR_0722b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateDisplayModeKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0721c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateDisplayModeKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_07209005);

        // No xml-driven validation
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateDisplayModeKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDisplayModeKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDisplayModeKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateDisplayModeKHR", "pMode", pMode, VALIDATION_ERROR_1fe1bc01);

    PFN_manual_vkCreateDisplayModeKHR custom_func = (PFN_manual_vkCreateDisplayModeKHR)custom_functions["vkCreateDisplayModeKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, display, pCreateInfo, pAllocator, pMode);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayModeKHR                            mode,
    uint32_t                                    planeIndex,
    VkDisplayPlaneCapabilitiesKHR*              pCapabilities)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetDisplayPlaneCapabilitiesKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkGetDisplayPlaneCapabilitiesKHR", VK_KHR_DISPLAY_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetDisplayPlaneCapabilitiesKHR", "mode", mode);

    skip |= validate_required_pointer(local_data->report_data, "vkGetDisplayPlaneCapabilitiesKHR", "pCapabilities", pCapabilities, VALIDATION_ERROR_29a10a01);

    PFN_manual_vkGetDisplayPlaneCapabilitiesKHR custom_func = (PFN_manual_vkGetDisplayPlaneCapabilitiesKHR)custom_functions["vkGetDisplayPlaneCapabilitiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, mode, planeIndex, pCapabilities);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                                  instance,
    const VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateDisplayPlaneSurfaceKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkCreateDisplayPlaneSurfaceKHR", VK_KHR_DISPLAY_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR, true, VALIDATION_ERROR_0782b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0781c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_07809005);

        skip |= validate_required_handle(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pCreateInfo->displayMode", pCreateInfo->displayMode);

        skip |= validate_flags(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pCreateInfo->transform", "VkSurfaceTransformFlagBitsKHR", AllVkSurfaceTransformFlagBitsKHR, pCreateInfo->transform, true, true, VALIDATION_ERROR_07830201);

        skip |= validate_flags(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pCreateInfo->alphaMode", "VkDisplayPlaneAlphaFlagBitsKHR", AllVkDisplayPlaneAlphaFlagBitsKHR, pCreateInfo->alphaMode, true, true, VALIDATION_ERROR_07800a01);

        // No xml-driven validation
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateDisplayPlaneSurfaceKHR", "pSurface", pSurface, VALIDATION_ERROR_20024801);

    PFN_manual_vkCreateDisplayPlaneSurfaceKHR custom_func = (PFN_manual_vkCreateDisplayPlaneSurfaceKHR)custom_functions["vkCreateDisplayPlaneSurfaceKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}



VKAPI_ATTR VkResult VKAPI_CALL vkCreateSharedSwapchainsKHR(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    const VkSwapchainCreateInfoKHR*             pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchains)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkCreateSharedSwapchainsKHR", VK_KHR_DISPLAY_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkCreateSharedSwapchainsKHR", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_display_swapchain) skip |= OutputExtensionError(local_data, "vkCreateSharedSwapchainsKHR", VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME);

    skip |= validate_array(local_data->report_data, "vkCreateSharedSwapchainsKHR", "swapchainCount", "pCreateInfos", swapchainCount, pCreateInfos, true, true, VALIDATION_ERROR_2282f21b, VALIDATION_ERROR_22812001);

    if (pCreateInfos != NULL)
    {
        for (uint32_t swapchainIndex = 0; swapchainIndex < swapchainCount; ++swapchainIndex)
        {
            const VkStructureType allowed_structs_VkSwapchainCreateInfoKHR[] = { VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX, VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT };

            skip |= validate_struct_pnext(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ swapchainIndex }), "VkDeviceGroupSwapchainCreateInfoKHX, VkSwapchainCounterCreateInfoEXT", pCreateInfos[swapchainIndex].pNext, ARRAY_SIZE(allowed_structs_VkSwapchainCreateInfoKHR), allowed_structs_VkSwapchainCreateInfoKHR, GeneratedHeaderVersion, VALIDATION_ERROR_1461c40d);

            skip |= validate_flags(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ swapchainIndex }), "VkSwapchainCreateFlagBitsKHR", AllVkSwapchainCreateFlagBitsKHR, pCreateInfos[swapchainIndex].flags, false, false, VALIDATION_ERROR_14609001);

            skip |= validate_required_handle(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].surface", ParameterName::IndexVector{ swapchainIndex }), pCreateInfos[swapchainIndex].surface);

            skip |= validate_ranged_enum(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].imageFormat", ParameterName::IndexVector{ swapchainIndex }), "VkFormat", AllVkFormatEnums, pCreateInfos[swapchainIndex].imageFormat, VALIDATION_ERROR_1460a401);

            skip |= validate_ranged_enum(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].imageColorSpace", ParameterName::IndexVector{ swapchainIndex }), "VkColorSpaceKHR", AllVkColorSpaceKHREnums, pCreateInfos[swapchainIndex].imageColorSpace, VALIDATION_ERROR_1460a201);

            // No xml-driven validation

            skip |= validate_flags(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].imageUsage", ParameterName::IndexVector{ swapchainIndex }), "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pCreateInfos[swapchainIndex].imageUsage, true, false, VALIDATION_ERROR_1460ae03);

            skip |= validate_ranged_enum(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].imageSharingMode", ParameterName::IndexVector{ swapchainIndex }), "VkSharingMode", AllVkSharingModeEnums, pCreateInfos[swapchainIndex].imageSharingMode, VALIDATION_ERROR_1460a801);

            skip |= validate_flags(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].preTransform", ParameterName::IndexVector{ swapchainIndex }), "VkSurfaceTransformFlagBitsKHR", AllVkSurfaceTransformFlagBitsKHR, pCreateInfos[swapchainIndex].preTransform, true, true, VALIDATION_ERROR_14629401);

            skip |= validate_flags(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].compositeAlpha", ParameterName::IndexVector{ swapchainIndex }), "VkCompositeAlphaFlagBitsKHR", AllVkCompositeAlphaFlagBitsKHR, pCreateInfos[swapchainIndex].compositeAlpha, true, true, VALIDATION_ERROR_14602e01);

            skip |= validate_ranged_enum(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].presentMode", ParameterName::IndexVector{ swapchainIndex }), "VkPresentModeKHR", AllVkPresentModeKHREnums, pCreateInfos[swapchainIndex].presentMode, VALIDATION_ERROR_14629601);

            skip |= validate_bool32(local_data->report_data, "vkCreateSharedSwapchainsKHR", ParameterName("pCreateInfos[%i].clipped", ParameterName::IndexVector{ swapchainIndex }), pCreateInfos[swapchainIndex].clipped);
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateSharedSwapchainsKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSharedSwapchainsKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSharedSwapchainsKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_array(local_data->report_data, "vkCreateSharedSwapchainsKHR", "swapchainCount", "pSwapchains", swapchainCount, pSwapchains, true, true, VALIDATION_ERROR_2282f21b, VALIDATION_ERROR_22825801);

    PFN_manual_vkCreateSharedSwapchainsKHR custom_func = (PFN_manual_vkCreateSharedSwapchainsKHR)custom_functions["vkCreateSharedSwapchainsKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
    }
    return result;
}



#ifdef VK_USE_PLATFORM_XLIB_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkCreateXlibSurfaceKHR(
    VkInstance                                  instance,
    const VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateXlibSurfaceKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_xlib_surface) skip |= OutputExtensionError(local_data, "vkCreateXlibSurfaceKHR", VK_KHR_XLIB_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateXlibSurfaceKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR, true, VALIDATION_ERROR_1602b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateXlibSurfaceKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_1601c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateXlibSurfaceKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_16009005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateXlibSurfaceKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateXlibSurfaceKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateXlibSurfaceKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateXlibSurfaceKHR", "pSurface", pSurface, VALIDATION_ERROR_23424801);

    PFN_manual_vkCreateXlibSurfaceKHR custom_func = (PFN_manual_vkCreateXlibSurfaceKHR)custom_functions["vkCreateXlibSurfaceKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    Display*                                    dpy,
    VisualID                                    visualID)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkBool32 result = VK_FALSE;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceXlibPresentationSupportKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_xlib_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceXlibPresentationSupportKHR", VK_KHR_XLIB_SURFACE_EXTENSION_NAME);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceXlibPresentationSupportKHR", "dpy", dpy, VALIDATION_ERROR_2f606601);

    PFN_manual_vkGetPhysicalDeviceXlibPresentationSupportKHR custom_func = (PFN_manual_vkGetPhysicalDeviceXlibPresentationSupportKHR)custom_functions["vkGetPhysicalDeviceXlibPresentationSupportKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, queueFamilyIndex, dpy, visualID);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID);
    }
    return result;
}

#endif // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkCreateXcbSurfaceKHR(
    VkInstance                                  instance,
    const VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateXcbSurfaceKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_xcb_surface) skip |= OutputExtensionError(local_data, "vkCreateXcbSurfaceKHR", VK_KHR_XCB_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateXcbSurfaceKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR, true, VALIDATION_ERROR_15e2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateXcbSurfaceKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_15e1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateXcbSurfaceKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_15e09005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateXcbSurfaceKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateXcbSurfaceKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateXcbSurfaceKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateXcbSurfaceKHR", "pSurface", pSurface, VALIDATION_ERROR_23224801);

    PFN_manual_vkCreateXcbSurfaceKHR custom_func = (PFN_manual_vkCreateXcbSurfaceKHR)custom_functions["vkCreateXcbSurfaceKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    xcb_connection_t*                           connection,
    xcb_visualid_t                              visual_id)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkBool32 result = VK_FALSE;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceXcbPresentationSupportKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_xcb_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceXcbPresentationSupportKHR", VK_KHR_XCB_SURFACE_EXTENSION_NAME);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceXcbPresentationSupportKHR", "connection", connection, VALIDATION_ERROR_2f403001);

    PFN_manual_vkGetPhysicalDeviceXcbPresentationSupportKHR custom_func = (PFN_manual_vkGetPhysicalDeviceXcbPresentationSupportKHR)custom_functions["vkGetPhysicalDeviceXcbPresentationSupportKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, queueFamilyIndex, connection, visual_id);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id);
    }
    return result;
}

#endif // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkCreateWaylandSurfaceKHR(
    VkInstance                                  instance,
    const VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateWaylandSurfaceKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_wayland_surface) skip |= OutputExtensionError(local_data, "vkCreateWaylandSurfaceKHR", VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateWaylandSurfaceKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR, true, VALIDATION_ERROR_1542b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateWaylandSurfaceKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_1541c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateWaylandSurfaceKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_15409005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateWaylandSurfaceKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateWaylandSurfaceKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateWaylandSurfaceKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateWaylandSurfaceKHR", "pSurface", pSurface, VALIDATION_ERROR_22e24801);

    PFN_manual_vkCreateWaylandSurfaceKHR custom_func = (PFN_manual_vkCreateWaylandSurfaceKHR)custom_functions["vkCreateWaylandSurfaceKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    struct wl_display*                          display)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkBool32 result = VK_FALSE;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceWaylandPresentationSupportKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_wayland_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceWaylandPresentationSupportKHR", VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceWaylandPresentationSupportKHR", "display", display, VALIDATION_ERROR_2f006001);

    PFN_manual_vkGetPhysicalDeviceWaylandPresentationSupportKHR custom_func = (PFN_manual_vkGetPhysicalDeviceWaylandPresentationSupportKHR)custom_functions["vkGetPhysicalDeviceWaylandPresentationSupportKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, queueFamilyIndex, display);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display);
    }
    return result;
}

#endif // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_MIR_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkCreateMirSurfaceKHR(
    VkInstance                                  instance,
    const VkMirSurfaceCreateInfoKHR*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateMirSurfaceKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_mir_surface) skip |= OutputExtensionError(local_data, "vkCreateMirSurfaceKHR", VK_KHR_MIR_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateMirSurfaceKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR, true, VALIDATION_ERROR_0ca2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateMirSurfaceKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0ca1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateMirSurfaceKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_0ca09005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateMirSurfaceKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateMirSurfaceKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateMirSurfaceKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateMirSurfaceKHR", "pSurface", pSurface, VALIDATION_ERROR_21624801);

    PFN_manual_vkCreateMirSurfaceKHR custom_func = (PFN_manual_vkCreateMirSurfaceKHR)custom_functions["vkCreateMirSurfaceKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateMirSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    MirConnection*                              connection)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkBool32 result = VK_FALSE;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceMirPresentationSupportKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_mir_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceMirPresentationSupportKHR", VK_KHR_MIR_SURFACE_EXTENSION_NAME);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceMirPresentationSupportKHR", "connection", connection, VALIDATION_ERROR_2d203001);

    PFN_manual_vkGetPhysicalDeviceMirPresentationSupportKHR custom_func = (PFN_manual_vkGetPhysicalDeviceMirPresentationSupportKHR)custom_functions["vkGetPhysicalDeviceMirPresentationSupportKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, queueFamilyIndex, connection);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceMirPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection);
    }
    return result;
}

#endif // VK_USE_PLATFORM_MIR_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkCreateAndroidSurfaceKHR(
    VkInstance                                  instance,
    const VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateAndroidSurfaceKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_android_surface) skip |= OutputExtensionError(local_data, "vkCreateAndroidSurfaceKHR", VK_KHR_ANDROID_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateAndroidSurfaceKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR, true, VALIDATION_ERROR_0042b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateAndroidSurfaceKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0041c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateAndroidSurfaceKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_00409005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateAndroidSurfaceKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateAndroidSurfaceKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateAndroidSurfaceKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateAndroidSurfaceKHR", "pSurface", pSurface, VALIDATION_ERROR_1ea24801);

    PFN_manual_vkCreateAndroidSurfaceKHR custom_func = (PFN_manual_vkCreateAndroidSurfaceKHR)custom_functions["vkCreateAndroidSurfaceKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkCreateWin32SurfaceKHR(
    VkInstance                                  instance,
    const VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateWin32SurfaceKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_win32_surface) skip |= OutputExtensionError(local_data, "vkCreateWin32SurfaceKHR", VK_KHR_WIN32_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateWin32SurfaceKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR, true, VALIDATION_ERROR_15a2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateWin32SurfaceKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_15a1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateWin32SurfaceKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_15a09005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateWin32SurfaceKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateWin32SurfaceKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateWin32SurfaceKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateWin32SurfaceKHR", "pSurface", pSurface, VALIDATION_ERROR_23024801);

    PFN_manual_vkCreateWin32SurfaceKHR custom_func = (PFN_manual_vkCreateWin32SurfaceKHR)custom_functions["vkCreateWin32SurfaceKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkBool32 result = VK_FALSE;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceWin32PresentationSupportKHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_win32_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceWin32PresentationSupportKHR", VK_KHR_WIN32_SURFACE_EXTENSION_NAME);

    // No xml-driven validation

    PFN_manual_vkGetPhysicalDeviceWin32PresentationSupportKHR custom_func = (PFN_manual_vkGetPhysicalDeviceWin32PresentationSupportKHR)custom_functions["vkGetPhysicalDeviceWin32PresentationSupportKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, queueFamilyIndex);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex);
    }
    return result;
}

#endif // VK_USE_PLATFORM_WIN32_KHR



VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures2KHR*               pFeatures)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceFeatures2KHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceFeatures2KHR", "pFeatures", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR", pFeatures, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR, true, VALIDATION_ERROR_0e42b00b);

    PFN_manual_vkGetPhysicalDeviceFeatures2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceFeatures2KHR)custom_functions["vkGetPhysicalDeviceFeatures2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pFeatures);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties2KHR*             pProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceProperties2KHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceProperties2KHR", "pProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR", pProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR, true, VALIDATION_ERROR_3402b00b);

    PFN_manual_vkGetPhysicalDeviceProperties2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceProperties2KHR)custom_functions["vkGetPhysicalDeviceProperties2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties2KHR*                     pFormatProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceFormatProperties2KHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceFormatProperties2KHR", "format", "VkFormat", AllVkFormatEnums, format, VALIDATION_ERROR_2c609201);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceFormatProperties2KHR", "pFormatProperties", "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR", pFormatProperties, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR, true, VALIDATION_ERROR_3422b00b);

    PFN_manual_vkGetPhysicalDeviceFormatProperties2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceFormatProperties2KHR)custom_functions["vkGetPhysicalDeviceFormatProperties2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, format, pFormatProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2KHR*  pImageFormatInfo,
    VkImageFormatProperties2KHR*                pImageFormatProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", "pImageFormatInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR", pImageFormatInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR, true, VALIDATION_ERROR_0e62b00b);

    if (pImageFormatInfo != NULL)
    {
        const VkStructureType allowed_structs_VkPhysicalDeviceImageFormatInfo2KHR[] = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR };

        skip |= validate_struct_pnext(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", "pImageFormatInfo->pNext", "VkPhysicalDeviceExternalImageFormatInfoKHR", pImageFormatInfo->pNext, ARRAY_SIZE(allowed_structs_VkPhysicalDeviceImageFormatInfo2KHR), allowed_structs_VkPhysicalDeviceImageFormatInfo2KHR, GeneratedHeaderVersion, VALIDATION_ERROR_0e61c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", "pImageFormatInfo->format", "VkFormat", AllVkFormatEnums, pImageFormatInfo->format, VALIDATION_ERROR_0e609201);

        skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", "pImageFormatInfo->type", "VkImageType", AllVkImageTypeEnums, pImageFormatInfo->type, VALIDATION_ERROR_0e630401);

        skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", "pImageFormatInfo->tiling", "VkImageTiling", AllVkImageTilingEnums, pImageFormatInfo->tiling, VALIDATION_ERROR_0e62fa01);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", "pImageFormatInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pImageFormatInfo->usage, true, false, VALIDATION_ERROR_0e630603);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", "pImageFormatInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pImageFormatInfo->flags, false, false, VALIDATION_ERROR_0e609001);
    }

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceImageFormatProperties2KHR", "pImageFormatProperties", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR", pImageFormatProperties, VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR, true, VALIDATION_ERROR_3442b00b);

    PFN_manual_vkGetPhysicalDeviceImageFormatProperties2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceImageFormatProperties2KHR)custom_functions["vkGetPhysicalDeviceImageFormatProperties2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pImageFormatInfo, pImageFormatProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2KHR*                pQueueFamilyProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceQueueFamilyProperties2KHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    skip |= validate_struct_type_array(local_data->report_data, "vkGetPhysicalDeviceQueueFamilyProperties2KHR", "pQueueFamilyPropertyCount", "pQueueFamilyProperties", "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR", pQueueFamilyPropertyCount, pQueueFamilyProperties, VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR, true, false, false, VALIDATION_ERROR_2dc20001);

    PFN_manual_vkGetPhysicalDeviceQueueFamilyProperties2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceQueueFamilyProperties2KHR)custom_functions["vkGetPhysicalDeviceQueueFamilyProperties2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties2KHR*       pMemoryProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceMemoryProperties2KHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceMemoryProperties2KHR", "pMemoryProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR", pMemoryProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR, true, VALIDATION_ERROR_3462b00b);

    PFN_manual_vkGetPhysicalDeviceMemoryProperties2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceMemoryProperties2KHR)custom_functions["vkGetPhysicalDeviceMemoryProperties2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pMemoryProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2KHR* pFormatInfo,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties2KHR*          pProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "pFormatInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR", pFormatInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR, true, VALIDATION_ERROR_0ec2b00b);

    if (pFormatInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "pFormatInfo->pNext", NULL, pFormatInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0ec1c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "pFormatInfo->format", "VkFormat", AllVkFormatEnums, pFormatInfo->format, VALIDATION_ERROR_0ec09201);

        skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "pFormatInfo->type", "VkImageType", AllVkImageTypeEnums, pFormatInfo->type, VALIDATION_ERROR_0ec30401);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "pFormatInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pFormatInfo->samples, true, true, VALIDATION_ERROR_0ec2b401);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "pFormatInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pFormatInfo->usage, true, false, VALIDATION_ERROR_0ec30603);

        skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "pFormatInfo->tiling", "VkImageTiling", AllVkImageTilingEnums, pFormatInfo->tiling, VALIDATION_ERROR_0ec2fa01);
    }

    skip |= validate_struct_type_array(local_data->report_data, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "pPropertyCount", "pProperties", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR", pPropertyCount, pProperties, VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR, true, false, false, VALIDATION_ERROR_2e01f401);

    PFN_manual_vkGetPhysicalDeviceSparseImageFormatProperties2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)custom_functions["vkGetPhysicalDeviceSparseImageFormatProperties2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    }
}





VKAPI_ATTR void VKAPI_CALL vkTrimCommandPoolKHR(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolTrimFlagsKHR                   flags)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_maintenance1) skip |= OutputExtensionError(local_data, "vkTrimCommandPoolKHR", VK_KHR_MAINTENANCE1_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkTrimCommandPoolKHR", "commandPool", commandPool);

    skip |= validate_reserved_flags(local_data->report_data, "vkTrimCommandPoolKHR", "flags", flags, VALIDATION_ERROR_33409005);

    PFN_manual_vkTrimCommandPoolKHR custom_func = (PFN_manual_vkTrimCommandPoolKHR)custom_functions["vkTrimCommandPoolKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, commandPool, flags);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.TrimCommandPoolKHR(device, commandPool, flags);
    }
}



VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalBufferInfoKHR* pExternalBufferInfo,
    VkExternalBufferPropertiesKHR*              pExternalBufferProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_memory_capabilities) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", "pExternalBufferInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR", pExternalBufferInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR, true, VALIDATION_ERROR_0dc2b00b);

    if (pExternalBufferInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", "pExternalBufferInfo->pNext", NULL, pExternalBufferInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0dc1c40d);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", "pExternalBufferInfo->flags", "VkBufferCreateFlagBits", AllVkBufferCreateFlagBits, pExternalBufferInfo->flags, false, false, VALIDATION_ERROR_0dc09001);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", "pExternalBufferInfo->usage", "VkBufferUsageFlagBits", AllVkBufferUsageFlagBits, pExternalBufferInfo->usage, true, false, VALIDATION_ERROR_0dc30603);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", "pExternalBufferInfo->handleType", "VkExternalMemoryHandleTypeFlagBitsKHR", AllVkExternalMemoryHandleTypeFlagBitsKHR, pExternalBufferInfo->handleType, true, true, VALIDATION_ERROR_0dc09c01);
    }

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", "pExternalBufferProperties", "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR", pExternalBufferProperties, VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR, true, VALIDATION_ERROR_34c2b00b);

    PFN_manual_vkGetPhysicalDeviceExternalBufferPropertiesKHR custom_func = (PFN_manual_vkGetPhysicalDeviceExternalBufferPropertiesKHR)custom_functions["vkGetPhysicalDeviceExternalBufferPropertiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
    }
}





#ifdef VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandleKHR(
    VkDevice                                    device,
    const VkMemoryGetWin32HandleInfoKHR*        pGetWin32HandleInfo,
    HANDLE*                                     pHandle)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_memory) skip |= OutputExtensionError(local_data, "vkGetMemoryWin32HandleKHR", VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_memory_win32) skip |= OutputExtensionError(local_data, "vkGetMemoryWin32HandleKHR", VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetMemoryWin32HandleKHR", "pGetWin32HandleInfo", "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR", pGetWin32HandleInfo, VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR, true, VALIDATION_ERROR_3b42b00b);

    if (pGetWin32HandleInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetMemoryWin32HandleKHR", "pGetWin32HandleInfo->pNext", NULL, pGetWin32HandleInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3b41c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetMemoryWin32HandleKHR", "pGetWin32HandleInfo->memory", pGetWin32HandleInfo->memory);

        skip |= validate_flags(local_data->report_data, "vkGetMemoryWin32HandleKHR", "pGetWin32HandleInfo->handleType", "VkExternalMemoryHandleTypeFlagBitsKHR", AllVkExternalMemoryHandleTypeFlagBitsKHR, pGetWin32HandleInfo->handleType, true, true, VALIDATION_ERROR_3b409c01);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkGetMemoryWin32HandleKHR", "pHandle", pHandle, VALIDATION_ERROR_2ae17c01);

    PFN_manual_vkGetMemoryWin32HandleKHR custom_func = (PFN_manual_vkGetMemoryWin32HandleKHR)custom_functions["vkGetMemoryWin32HandleKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pGetWin32HandleInfo, pHandle);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    HANDLE                                      handle,
    VkMemoryWin32HandlePropertiesKHR*           pMemoryWin32HandleProperties)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_memory) skip |= OutputExtensionError(local_data, "vkGetMemoryWin32HandlePropertiesKHR", VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_memory_win32) skip |= OutputExtensionError(local_data, "vkGetMemoryWin32HandlePropertiesKHR", VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);

    skip |= validate_flags(local_data->report_data, "vkGetMemoryWin32HandlePropertiesKHR", "handleType", "VkExternalMemoryHandleTypeFlagBitsKHR", AllVkExternalMemoryHandleTypeFlagBitsKHR, handleType, true, true, VALIDATION_ERROR_2b209c01);

    skip |= validate_struct_type(local_data->report_data, "vkGetMemoryWin32HandlePropertiesKHR", "pMemoryWin32HandleProperties", "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR", pMemoryWin32HandleProperties, VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR, true, VALIDATION_ERROR_UNDEFINED);

    PFN_manual_vkGetMemoryWin32HandlePropertiesKHR custom_func = (PFN_manual_vkGetMemoryWin32HandlePropertiesKHR)custom_functions["vkGetMemoryWin32HandlePropertiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, handleType, handle, pMemoryWin32HandleProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties);
    }
    return result;
}

#endif // VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryFdKHR(
    VkDevice                                    device,
    const VkMemoryGetFdInfoKHR*                 pGetFdInfo,
    int*                                        pFd)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_memory) skip |= OutputExtensionError(local_data, "vkGetMemoryFdKHR", VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_memory_fd) skip |= OutputExtensionError(local_data, "vkGetMemoryFdKHR", VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetMemoryFdKHR", "pGetFdInfo", "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR", pGetFdInfo, VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, true, VALIDATION_ERROR_3b22b00b);

    if (pGetFdInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetMemoryFdKHR", "pGetFdInfo->pNext", NULL, pGetFdInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3b21c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetMemoryFdKHR", "pGetFdInfo->memory", pGetFdInfo->memory);

        skip |= validate_flags(local_data->report_data, "vkGetMemoryFdKHR", "pGetFdInfo->handleType", "VkExternalMemoryHandleTypeFlagBitsKHR", AllVkExternalMemoryHandleTypeFlagBitsKHR, pGetFdInfo->handleType, true, true, VALIDATION_ERROR_3b209c01);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkGetMemoryFdKHR", "pFd", pFd, VALIDATION_ERROR_2aa16c01);

    PFN_manual_vkGetMemoryFdKHR custom_func = (PFN_manual_vkGetMemoryFdKHR)custom_functions["vkGetMemoryFdKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pGetFdInfo, pFd);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetMemoryFdKHR(device, pGetFdInfo, pFd);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryFdPropertiesKHR(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    int                                         fd,
    VkMemoryFdPropertiesKHR*                    pMemoryFdProperties)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_memory) skip |= OutputExtensionError(local_data, "vkGetMemoryFdPropertiesKHR", VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_memory_fd) skip |= OutputExtensionError(local_data, "vkGetMemoryFdPropertiesKHR", VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME);

    skip |= validate_flags(local_data->report_data, "vkGetMemoryFdPropertiesKHR", "handleType", "VkExternalMemoryHandleTypeFlagBitsKHR", AllVkExternalMemoryHandleTypeFlagBitsKHR, handleType, true, true, VALIDATION_ERROR_2ac09c01);

    skip |= validate_struct_type(local_data->report_data, "vkGetMemoryFdPropertiesKHR", "pMemoryFdProperties", "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR", pMemoryFdProperties, VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR, true, VALIDATION_ERROR_UNDEFINED);

    PFN_manual_vkGetMemoryFdPropertiesKHR custom_func = (PFN_manual_vkGetMemoryFdPropertiesKHR)custom_functions["vkGetMemoryFdPropertiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, handleType, fd, pMemoryFdProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties);
    }
    return result;
}



#ifdef VK_USE_PLATFORM_WIN32_KHR

#endif // VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfoKHR* pExternalSemaphoreInfo,
    VkExternalSemaphorePropertiesKHR*           pExternalSemaphoreProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_semaphore_capabilities) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", "pExternalSemaphoreInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR", pExternalSemaphoreInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR, true, VALIDATION_ERROR_0e02b00b);

    if (pExternalSemaphoreInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", "pExternalSemaphoreInfo->pNext", NULL, pExternalSemaphoreInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0e01c40d);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", "pExternalSemaphoreInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBitsKHR", AllVkExternalSemaphoreHandleTypeFlagBitsKHR, pExternalSemaphoreInfo->handleType, true, true, VALIDATION_ERROR_0e009c01);
    }

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", "pExternalSemaphoreProperties", "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR", pExternalSemaphoreProperties, VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR, true, VALIDATION_ERROR_3522b00b);

    PFN_manual_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR custom_func = (PFN_manual_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)custom_functions["vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
    }
}





#ifdef VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkImportSemaphoreWin32HandleKHR(
    VkDevice                                    device,
    const VkImportSemaphoreWin32HandleInfoKHR*  pImportSemaphoreWin32HandleInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_semaphore) skip |= OutputExtensionError(local_data, "vkImportSemaphoreWin32HandleKHR", VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_semaphore_win32) skip |= OutputExtensionError(local_data, "vkImportSemaphoreWin32HandleKHR", VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkImportSemaphoreWin32HandleKHR", "pImportSemaphoreWin32HandleInfo", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR", pImportSemaphoreWin32HandleInfo, VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR, true, VALIDATION_ERROR_0b62b00b);

    if (pImportSemaphoreWin32HandleInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkImportSemaphoreWin32HandleKHR", "pImportSemaphoreWin32HandleInfo->pNext", NULL, pImportSemaphoreWin32HandleInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0b61c40d);

        skip |= validate_required_handle(local_data->report_data, "vkImportSemaphoreWin32HandleKHR", "pImportSemaphoreWin32HandleInfo->semaphore", pImportSemaphoreWin32HandleInfo->semaphore);

        skip |= validate_flags(local_data->report_data, "vkImportSemaphoreWin32HandleKHR", "pImportSemaphoreWin32HandleInfo->flags", "VkSemaphoreImportFlagBitsKHR", AllVkSemaphoreImportFlagBitsKHR, pImportSemaphoreWin32HandleInfo->flags, false, false, VALIDATION_ERROR_0b609001);

        skip |= validate_flags(local_data->report_data, "vkImportSemaphoreWin32HandleKHR", "pImportSemaphoreWin32HandleInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBitsKHR", AllVkExternalSemaphoreHandleTypeFlagBitsKHR, pImportSemaphoreWin32HandleInfo->handleType, false, true, VALIDATION_ERROR_0b609c01);
    }

    PFN_manual_vkImportSemaphoreWin32HandleKHR custom_func = (PFN_manual_vkImportSemaphoreWin32HandleKHR)custom_functions["vkImportSemaphoreWin32HandleKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pImportSemaphoreWin32HandleInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetSemaphoreWin32HandleKHR(
    VkDevice                                    device,
    const VkSemaphoreGetWin32HandleInfoKHR*     pGetWin32HandleInfo,
    HANDLE*                                     pHandle)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_semaphore) skip |= OutputExtensionError(local_data, "vkGetSemaphoreWin32HandleKHR", VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_semaphore_win32) skip |= OutputExtensionError(local_data, "vkGetSemaphoreWin32HandleKHR", VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetSemaphoreWin32HandleKHR", "pGetWin32HandleInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR", pGetWin32HandleInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR, true, VALIDATION_ERROR_3b02b00b);

    if (pGetWin32HandleInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetSemaphoreWin32HandleKHR", "pGetWin32HandleInfo->pNext", NULL, pGetWin32HandleInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3b01c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetSemaphoreWin32HandleKHR", "pGetWin32HandleInfo->semaphore", pGetWin32HandleInfo->semaphore);

        skip |= validate_flags(local_data->report_data, "vkGetSemaphoreWin32HandleKHR", "pGetWin32HandleInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBitsKHR", AllVkExternalSemaphoreHandleTypeFlagBitsKHR, pGetWin32HandleInfo->handleType, true, true, VALIDATION_ERROR_3b009c01);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkGetSemaphoreWin32HandleKHR", "pHandle", pHandle, VALIDATION_ERROR_30417c01);

    PFN_manual_vkGetSemaphoreWin32HandleKHR custom_func = (PFN_manual_vkGetSemaphoreWin32HandleKHR)custom_functions["vkGetSemaphoreWin32HandleKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pGetWin32HandleInfo, pHandle);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
    }
    return result;
}

#endif // VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkImportSemaphoreFdKHR(
    VkDevice                                    device,
    const VkImportSemaphoreFdInfoKHR*           pImportSemaphoreFdInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_semaphore) skip |= OutputExtensionError(local_data, "vkImportSemaphoreFdKHR", VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_semaphore_fd) skip |= OutputExtensionError(local_data, "vkImportSemaphoreFdKHR", VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkImportSemaphoreFdKHR", "pImportSemaphoreFdInfo", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR", pImportSemaphoreFdInfo, VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR, true, VALIDATION_ERROR_0b42b00b);

    if (pImportSemaphoreFdInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkImportSemaphoreFdKHR", "pImportSemaphoreFdInfo->pNext", NULL, pImportSemaphoreFdInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0b41c40d);

        skip |= validate_required_handle(local_data->report_data, "vkImportSemaphoreFdKHR", "pImportSemaphoreFdInfo->semaphore", pImportSemaphoreFdInfo->semaphore);

        skip |= validate_flags(local_data->report_data, "vkImportSemaphoreFdKHR", "pImportSemaphoreFdInfo->flags", "VkSemaphoreImportFlagBitsKHR", AllVkSemaphoreImportFlagBitsKHR, pImportSemaphoreFdInfo->flags, false, false, VALIDATION_ERROR_0b409001);

        skip |= validate_flags(local_data->report_data, "vkImportSemaphoreFdKHR", "pImportSemaphoreFdInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBitsKHR", AllVkExternalSemaphoreHandleTypeFlagBitsKHR, pImportSemaphoreFdInfo->handleType, true, true, VALIDATION_ERROR_0b409c01);
    }

    PFN_manual_vkImportSemaphoreFdKHR custom_func = (PFN_manual_vkImportSemaphoreFdKHR)custom_functions["vkImportSemaphoreFdKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pImportSemaphoreFdInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetSemaphoreFdKHR(
    VkDevice                                    device,
    const VkSemaphoreGetFdInfoKHR*              pGetFdInfo,
    int*                                        pFd)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_semaphore) skip |= OutputExtensionError(local_data, "vkGetSemaphoreFdKHR", VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_semaphore_fd) skip |= OutputExtensionError(local_data, "vkGetSemaphoreFdKHR", VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetSemaphoreFdKHR", "pGetFdInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR", pGetFdInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR, true, VALIDATION_ERROR_3ae2b00b);

    if (pGetFdInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetSemaphoreFdKHR", "pGetFdInfo->pNext", NULL, pGetFdInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3ae1c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetSemaphoreFdKHR", "pGetFdInfo->semaphore", pGetFdInfo->semaphore);

        skip |= validate_flags(local_data->report_data, "vkGetSemaphoreFdKHR", "pGetFdInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBitsKHR", AllVkExternalSemaphoreHandleTypeFlagBitsKHR, pGetFdInfo->handleType, true, true, VALIDATION_ERROR_3ae09c01);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkGetSemaphoreFdKHR", "pFd", pFd, VALIDATION_ERROR_30216c01);

    PFN_manual_vkGetSemaphoreFdKHR custom_func = (PFN_manual_vkGetSemaphoreFdKHR)custom_functions["vkGetSemaphoreFdKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pGetFdInfo, pFd);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetSemaphoreFdKHR(device, pGetFdInfo, pFd);
    }
    return result;
}



VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetKHR(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkCmdPushDescriptorSetKHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_push_descriptor) skip |= OutputExtensionError(local_data, "vkCmdPushDescriptorSetKHR", VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME);

    skip |= validate_ranged_enum(local_data->report_data, "vkCmdPushDescriptorSetKHR", "pipelineBindPoint", "VkPipelineBindPoint", AllVkPipelineBindPointEnums, pipelineBindPoint, VALIDATION_ERROR_1be27e01);

    skip |= validate_required_handle(local_data->report_data, "vkCmdPushDescriptorSetKHR", "layout", layout);

    skip |= validate_array(local_data->report_data, "vkCmdPushDescriptorSetKHR", "descriptorWriteCount", "pDescriptorWrites", descriptorWriteCount, pDescriptorWrites, true, true, VALIDATION_ERROR_1be0541b, VALIDATION_ERROR_1be13601);

    if (pDescriptorWrites != NULL)
    {
        for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < descriptorWriteCount; ++descriptorWriteIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkCmdPushDescriptorSetKHR", ParameterName("pDescriptorWrites[%i].pNext", ParameterName::IndexVector{ descriptorWriteIndex }), NULL, pDescriptorWrites[descriptorWriteIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_15c1c40d);

            skip |= validate_ranged_enum(local_data->report_data, "vkCmdPushDescriptorSetKHR", ParameterName("pDescriptorWrites[%i].descriptorType", ParameterName::IndexVector{ descriptorWriteIndex }), "VkDescriptorType", AllVkDescriptorTypeEnums, pDescriptorWrites[descriptorWriteIndex].descriptorType, VALIDATION_ERROR_15c04e01);
        }
    }

    PFN_manual_vkCmdPushDescriptorSetKHR custom_func = (PFN_manual_vkCmdPushDescriptorSetKHR)custom_functions["vkCmdPushDescriptorSetKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    }
}







VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    const VkDescriptorUpdateTemplateCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplateKHR*              pDescriptorUpdateTemplate)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_descriptor_update_template) skip |= OutputExtensionError(local_data, "vkCreateDescriptorUpdateTemplateKHR", VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR, true, VALIDATION_ERROR_0522b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0521c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_05209005);

        skip |= validate_array(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pCreateInfo->descriptorUpdateEntryCount", "pCreateInfo->pDescriptorUpdateEntries", pCreateInfo->descriptorUpdateEntryCount, pCreateInfo->pDescriptorUpdateEntries, true, true, VALIDATION_ERROR_0520501b, VALIDATION_ERROR_05213201);

        if (pCreateInfo->pDescriptorUpdateEntries != NULL)
        {
            for (uint32_t descriptorUpdateEntryIndex = 0; descriptorUpdateEntryIndex < pCreateInfo->descriptorUpdateEntryCount; ++descriptorUpdateEntryIndex)
            {
                skip |= validate_ranged_enum(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", ParameterName("pCreateInfo->pDescriptorUpdateEntries[%i].descriptorType", ParameterName::IndexVector{ descriptorUpdateEntryIndex }), "VkDescriptorType", AllVkDescriptorTypeEnums, pCreateInfo->pDescriptorUpdateEntries[descriptorUpdateEntryIndex].descriptorType, VALIDATION_ERROR_05404e01);
            }
        }

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pCreateInfo->templateType", "VkDescriptorUpdateTemplateTypeKHR", AllVkDescriptorUpdateTemplateTypeKHREnums, pCreateInfo->templateType, VALIDATION_ERROR_0522f801);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pCreateInfo->pipelineBindPoint", "VkPipelineBindPoint", AllVkPipelineBindPointEnums, pCreateInfo->pipelineBindPoint, VALIDATION_ERROR_05227e01);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateDescriptorUpdateTemplateKHR", "pDescriptorUpdateTemplate", pDescriptorUpdateTemplate, VALIDATION_ERROR_1fa13401);

    PFN_manual_vkCreateDescriptorUpdateTemplateKHR custom_func = (PFN_manual_vkCreateDescriptorUpdateTemplateKHR)custom_functions["vkCreateDescriptorUpdateTemplateKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_descriptor_update_template) skip |= OutputExtensionError(local_data, "vkDestroyDescriptorUpdateTemplateKHR", VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorUpdateTemplateKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorUpdateTemplateKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDescriptorUpdateTemplateKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyDescriptorUpdateTemplateKHR custom_func = (PFN_manual_vkDestroyDescriptorUpdateTemplateKHR)custom_functions["vkDestroyDescriptorUpdateTemplateKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, descriptorUpdateTemplate, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
    }
}

VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
    const void*                                 pData)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_descriptor_update_template) skip |= OutputExtensionError(local_data, "vkUpdateDescriptorSetWithTemplateKHR", VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkUpdateDescriptorSetWithTemplateKHR", "descriptorSet", descriptorSet);

    skip |= validate_required_handle(local_data->report_data, "vkUpdateDescriptorSetWithTemplateKHR", "descriptorUpdateTemplate", descriptorUpdateTemplate);

    PFN_manual_vkUpdateDescriptorSetWithTemplateKHR custom_func = (PFN_manual_vkUpdateDescriptorSetWithTemplateKHR)custom_functions["vkUpdateDescriptorSetWithTemplateKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, descriptorSet, descriptorUpdateTemplate, pData);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer                             commandBuffer,
    VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    const void*                                 pData)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_descriptor_update_template) skip |= OutputExtensionError(local_data, "vkCmdPushDescriptorSetWithTemplateKHR", VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkCmdPushDescriptorSetWithTemplateKHR", "descriptorUpdateTemplate", descriptorUpdateTemplate);

    skip |= validate_required_handle(local_data->report_data, "vkCmdPushDescriptorSetWithTemplateKHR", "layout", layout);

    PFN_manual_vkCmdPushDescriptorSetWithTemplateKHR custom_func = (PFN_manual_vkCmdPushDescriptorSetWithTemplateKHR)custom_functions["vkCmdPushDescriptorSetWithTemplateKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
    }
}



VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainStatusKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_surface_capabilities_2) skip |= OutputExtensionError(local_data, "vkGetSwapchainStatusKHR", VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetSwapchainStatusKHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkGetSwapchainStatusKHR", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_shared_presentable_image) skip |= OutputExtensionError(local_data, "vkGetSwapchainStatusKHR", VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetSwapchainStatusKHR", "swapchain", swapchain);

    PFN_manual_vkGetSwapchainStatusKHR custom_func = (PFN_manual_vkGetSwapchainStatusKHR)custom_functions["vkGetSwapchainStatusKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchain);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetSwapchainStatusKHR(device, swapchain);
    }
    return result;
}



VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalFenceInfoKHR* pExternalFenceInfo,
    VkExternalFencePropertiesKHR*               pExternalFenceProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceExternalFencePropertiesKHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_fence_capabilities) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceExternalFencePropertiesKHR", VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceExternalFencePropertiesKHR", "pExternalFenceInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR", pExternalFenceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR, true, VALIDATION_ERROR_3962b00b);

    if (pExternalFenceInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetPhysicalDeviceExternalFencePropertiesKHR", "pExternalFenceInfo->pNext", NULL, pExternalFenceInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3961c40d);

        skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceExternalFencePropertiesKHR", "pExternalFenceInfo->handleType", "VkExternalFenceHandleTypeFlagBitsKHR", AllVkExternalFenceHandleTypeFlagBitsKHR, pExternalFenceInfo->handleType, true, true, VALIDATION_ERROR_39609c01);
    }

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceExternalFencePropertiesKHR", "pExternalFenceProperties", "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR", pExternalFenceProperties, VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR, true, VALIDATION_ERROR_3982b00b);

    PFN_manual_vkGetPhysicalDeviceExternalFencePropertiesKHR custom_func = (PFN_manual_vkGetPhysicalDeviceExternalFencePropertiesKHR)custom_functions["vkGetPhysicalDeviceExternalFencePropertiesKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
    }
}





#ifdef VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkImportFenceWin32HandleKHR(
    VkDevice                                    device,
    const VkImportFenceWin32HandleInfoKHR*      pImportFenceWin32HandleInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_fence) skip |= OutputExtensionError(local_data, "vkImportFenceWin32HandleKHR", VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_fence_win32) skip |= OutputExtensionError(local_data, "vkImportFenceWin32HandleKHR", VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkImportFenceWin32HandleKHR", "pImportFenceWin32HandleInfo", "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR", pImportFenceWin32HandleInfo, VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR, true, VALIDATION_ERROR_3a42b00b);

    if (pImportFenceWin32HandleInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkImportFenceWin32HandleKHR", "pImportFenceWin32HandleInfo->pNext", NULL, pImportFenceWin32HandleInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3a41c40d);

        skip |= validate_required_handle(local_data->report_data, "vkImportFenceWin32HandleKHR", "pImportFenceWin32HandleInfo->fence", pImportFenceWin32HandleInfo->fence);

        skip |= validate_flags(local_data->report_data, "vkImportFenceWin32HandleKHR", "pImportFenceWin32HandleInfo->flags", "VkFenceImportFlagBitsKHR", AllVkFenceImportFlagBitsKHR, pImportFenceWin32HandleInfo->flags, false, false, VALIDATION_ERROR_3a409001);

        skip |= validate_flags(local_data->report_data, "vkImportFenceWin32HandleKHR", "pImportFenceWin32HandleInfo->handleType", "VkExternalFenceHandleTypeFlagBitsKHR", AllVkExternalFenceHandleTypeFlagBitsKHR, pImportFenceWin32HandleInfo->handleType, false, true, VALIDATION_ERROR_3a409c01);
    }

    PFN_manual_vkImportFenceWin32HandleKHR custom_func = (PFN_manual_vkImportFenceWin32HandleKHR)custom_functions["vkImportFenceWin32HandleKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pImportFenceWin32HandleInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceWin32HandleKHR(
    VkDevice                                    device,
    const VkFenceGetWin32HandleInfoKHR*         pGetWin32HandleInfo,
    HANDLE*                                     pHandle)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_fence) skip |= OutputExtensionError(local_data, "vkGetFenceWin32HandleKHR", VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_fence_win32) skip |= OutputExtensionError(local_data, "vkGetFenceWin32HandleKHR", VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetFenceWin32HandleKHR", "pGetWin32HandleInfo", "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR", pGetWin32HandleInfo, VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR, true, VALIDATION_ERROR_3a82b00b);

    if (pGetWin32HandleInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetFenceWin32HandleKHR", "pGetWin32HandleInfo->pNext", NULL, pGetWin32HandleInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3a81c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetFenceWin32HandleKHR", "pGetWin32HandleInfo->fence", pGetWin32HandleInfo->fence);

        skip |= validate_flags(local_data->report_data, "vkGetFenceWin32HandleKHR", "pGetWin32HandleInfo->handleType", "VkExternalFenceHandleTypeFlagBitsKHR", AllVkExternalFenceHandleTypeFlagBitsKHR, pGetWin32HandleInfo->handleType, true, true, VALIDATION_ERROR_3a809c01);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkGetFenceWin32HandleKHR", "pHandle", pHandle, VALIDATION_ERROR_3ac17c01);

    PFN_manual_vkGetFenceWin32HandleKHR custom_func = (PFN_manual_vkGetFenceWin32HandleKHR)custom_functions["vkGetFenceWin32HandleKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pGetWin32HandleInfo, pHandle);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
    }
    return result;
}

#endif // VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkImportFenceFdKHR(
    VkDevice                                    device,
    const VkImportFenceFdInfoKHR*               pImportFenceFdInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_fence) skip |= OutputExtensionError(local_data, "vkImportFenceFdKHR", VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_fence_fd) skip |= OutputExtensionError(local_data, "vkImportFenceFdKHR", VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkImportFenceFdKHR", "pImportFenceFdInfo", "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR", pImportFenceFdInfo, VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR, true, VALIDATION_ERROR_39c2b00b);

    if (pImportFenceFdInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkImportFenceFdKHR", "pImportFenceFdInfo->pNext", NULL, pImportFenceFdInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_39c1c40d);

        skip |= validate_required_handle(local_data->report_data, "vkImportFenceFdKHR", "pImportFenceFdInfo->fence", pImportFenceFdInfo->fence);

        skip |= validate_flags(local_data->report_data, "vkImportFenceFdKHR", "pImportFenceFdInfo->flags", "VkFenceImportFlagBitsKHR", AllVkFenceImportFlagBitsKHR, pImportFenceFdInfo->flags, false, false, VALIDATION_ERROR_39c09001);

        skip |= validate_flags(local_data->report_data, "vkImportFenceFdKHR", "pImportFenceFdInfo->handleType", "VkExternalFenceHandleTypeFlagBitsKHR", AllVkExternalFenceHandleTypeFlagBitsKHR, pImportFenceFdInfo->handleType, true, true, VALIDATION_ERROR_39c09c01);
    }

    PFN_manual_vkImportFenceFdKHR custom_func = (PFN_manual_vkImportFenceFdKHR)custom_functions["vkImportFenceFdKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pImportFenceFdInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ImportFenceFdKHR(device, pImportFenceFdInfo);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceFdKHR(
    VkDevice                                    device,
    const VkFenceGetFdInfoKHR*                  pGetFdInfo,
    int*                                        pFd)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_fence) skip |= OutputExtensionError(local_data, "vkGetFenceFdKHR", VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_external_fence_fd) skip |= OutputExtensionError(local_data, "vkGetFenceFdKHR", VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetFenceFdKHR", "pGetFdInfo", "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR", pGetFdInfo, VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR, true, VALIDATION_ERROR_39e2b00b);

    if (pGetFdInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetFenceFdKHR", "pGetFdInfo->pNext", NULL, pGetFdInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_39e1c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetFenceFdKHR", "pGetFdInfo->fence", pGetFdInfo->fence);

        skip |= validate_flags(local_data->report_data, "vkGetFenceFdKHR", "pGetFdInfo->handleType", "VkExternalFenceHandleTypeFlagBitsKHR", AllVkExternalFenceHandleTypeFlagBitsKHR, pGetFdInfo->handleType, true, true, VALIDATION_ERROR_39e09c01);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkGetFenceFdKHR", "pFd", pFd, VALIDATION_ERROR_3a216c01);

    PFN_manual_vkGetFenceFdKHR custom_func = (PFN_manual_vkGetFenceFdKHR)custom_functions["vkGetFenceFdKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pGetFdInfo, pFd);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetFenceFdKHR(device, pGetFdInfo, pFd);
    }
    return result;
}





VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    VkSurfaceCapabilities2KHR*                  pSurfaceCapabilities)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceCapabilities2KHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_get_surface_capabilities_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceCapabilities2KHR", VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceSurfaceCapabilities2KHR", "pSurfaceInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR", pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR, true, VALIDATION_ERROR_0ee2b00b);

    if (pSurfaceInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetPhysicalDeviceSurfaceCapabilities2KHR", "pSurfaceInfo->pNext", NULL, pSurfaceInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0ee1c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetPhysicalDeviceSurfaceCapabilities2KHR", "pSurfaceInfo->surface", pSurfaceInfo->surface);
    }

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceSurfaceCapabilities2KHR", "pSurfaceCapabilities", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR", pSurfaceCapabilities, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR, true, VALIDATION_ERROR_3482b00b);

    PFN_manual_vkGetPhysicalDeviceSurfaceCapabilities2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceSurfaceCapabilities2KHR)custom_functions["vkGetPhysicalDeviceSurfaceCapabilities2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormat2KHR*                        pSurfaceFormats)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceFormats2KHR", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_get_surface_capabilities_2) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceFormats2KHR", VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceSurfaceFormats2KHR", "pSurfaceInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR", pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR, true, VALIDATION_ERROR_0ee2b00b);

    if (pSurfaceInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetPhysicalDeviceSurfaceFormats2KHR", "pSurfaceInfo->pNext", NULL, pSurfaceInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0ee1c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetPhysicalDeviceSurfaceFormats2KHR", "pSurfaceInfo->surface", pSurfaceInfo->surface);
    }

    skip |= validate_struct_type_array(local_data->report_data, "vkGetPhysicalDeviceSurfaceFormats2KHR", "pSurfaceFormatCount", "pSurfaceFormats", "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR", pSurfaceFormatCount, pSurfaceFormats, VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR, true, false, false, VALIDATION_ERROR_2e824e01);

    PFN_manual_vkGetPhysicalDeviceSurfaceFormats2KHR custom_func = (PFN_manual_vkGetPhysicalDeviceSurfaceFormats2KHR)custom_functions["vkGetPhysicalDeviceSurfaceFormats2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
    }
    return result;
}











VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkImageMemoryRequirementsInfo2KHR*    pInfo,
    VkMemoryRequirements2KHR*                   pMemoryRequirements)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_memory_requirements_2) skip |= OutputExtensionError(local_data, "vkGetImageMemoryRequirements2KHR", VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetImageMemoryRequirements2KHR", "pInfo", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR", pInfo, VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR, true, VALIDATION_ERROR_3bc2b00b);

    if (pInfo != NULL)
    {
        const VkStructureType allowed_structs_VkImageMemoryRequirementsInfo2KHR[] = { VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR };

        skip |= validate_struct_pnext(local_data->report_data, "vkGetImageMemoryRequirements2KHR", "pInfo->pNext", "VkImagePlaneMemoryRequirementsInfoKHR", pInfo->pNext, ARRAY_SIZE(allowed_structs_VkImageMemoryRequirementsInfo2KHR), allowed_structs_VkImageMemoryRequirementsInfo2KHR, GeneratedHeaderVersion, VALIDATION_ERROR_3bc1c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetImageMemoryRequirements2KHR", "pInfo->image", pInfo->image);
    }

    skip |= validate_struct_type(local_data->report_data, "vkGetImageMemoryRequirements2KHR", "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR, true, VALIDATION_ERROR_3c02b00b);

    PFN_manual_vkGetImageMemoryRequirements2KHR custom_func = (PFN_manual_vkGetImageMemoryRequirements2KHR)custom_functions["vkGetImageMemoryRequirements2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pInfo, pMemoryRequirements);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkBufferMemoryRequirementsInfo2KHR*   pInfo,
    VkMemoryRequirements2KHR*                   pMemoryRequirements)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_memory_requirements_2) skip |= OutputExtensionError(local_data, "vkGetBufferMemoryRequirements2KHR", VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetBufferMemoryRequirements2KHR", "pInfo", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR", pInfo, VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR, true, VALIDATION_ERROR_3ba2b00b);

    if (pInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetBufferMemoryRequirements2KHR", "pInfo->pNext", NULL, pInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3ba1c40d);

        skip |= validate_required_handle(local_data->report_data, "vkGetBufferMemoryRequirements2KHR", "pInfo->buffer", pInfo->buffer);
    }

    skip |= validate_struct_type(local_data->report_data, "vkGetBufferMemoryRequirements2KHR", "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR, true, VALIDATION_ERROR_3c02b00b);

    PFN_manual_vkGetBufferMemoryRequirements2KHR custom_func = (PFN_manual_vkGetBufferMemoryRequirements2KHR)custom_functions["vkGetBufferMemoryRequirements2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pInfo, pMemoryRequirements);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkImageSparseMemoryRequirementsInfo2KHR* pInfo,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2KHR*        pSparseMemoryRequirements)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_memory_requirements_2) skip |= OutputExtensionError(local_data, "vkGetImageSparseMemoryRequirements2KHR", VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetImageSparseMemoryRequirements2KHR", "pInfo", "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR", pInfo, VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR, true, VALIDATION_ERROR_UNDEFINED);

    if (pInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkGetImageSparseMemoryRequirements2KHR", "pInfo->pNext", NULL, pInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_UNDEFINED);

        skip |= validate_required_handle(local_data->report_data, "vkGetImageSparseMemoryRequirements2KHR", "pInfo->image", pInfo->image);
    }

    skip |= validate_struct_type_array(local_data->report_data, "vkGetImageSparseMemoryRequirements2KHR", "pSparseMemoryRequirementCount", "pSparseMemoryRequirements", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR", pSparseMemoryRequirementCount, pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR, true, false, false, VALIDATION_ERROR_UNDEFINED);

    PFN_manual_vkGetImageSparseMemoryRequirements2KHR custom_func = (PFN_manual_vkGetImageSparseMemoryRequirements2KHR)custom_functions["vkGetImageSparseMemoryRequirements2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    }
}





VKAPI_ATTR VkResult VKAPI_CALL vkCreateSamplerYcbcrConversionKHR(
    VkDevice                                    device,
    const VkSamplerYcbcrConversionCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSamplerYcbcrConversionKHR*                pYcbcrConversion)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkCreateSamplerYcbcrConversionKHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_get_memory_requirements_2) skip |= OutputExtensionError(local_data, "vkCreateSamplerYcbcrConversionKHR", VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_bind_memory_2) skip |= OutputExtensionError(local_data, "vkCreateSamplerYcbcrConversionKHR", VK_KHR_BIND_MEMORY_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_maintenance1) skip |= OutputExtensionError(local_data, "vkCreateSamplerYcbcrConversionKHR", VK_KHR_MAINTENANCE1_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_sampler_ycbcr_conversion) skip |= OutputExtensionError(local_data, "vkCreateSamplerYcbcrConversionKHR", VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo", "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR, true, VALIDATION_ERROR_3f82b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3f81c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->format", "VkFormat", AllVkFormatEnums, pCreateInfo->format, VALIDATION_ERROR_3f809201);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->ycbcrModel", "VkSamplerYcbcrModelConversionKHR", AllVkSamplerYcbcrModelConversionKHREnums, pCreateInfo->ycbcrModel, VALIDATION_ERROR_3f83d401);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->ycbcrRange", "VkSamplerYcbcrRangeKHR", AllVkSamplerYcbcrRangeKHREnums, pCreateInfo->ycbcrRange, VALIDATION_ERROR_3f83d601);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->components.r", "VkComponentSwizzle", AllVkComponentSwizzleEnums, pCreateInfo->components.r, VALIDATION_ERROR_02e2a201);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->components.g", "VkComponentSwizzle", AllVkComponentSwizzleEnums, pCreateInfo->components.g, VALIDATION_ERROR_02e09a01);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->components.b", "VkComponentSwizzle", AllVkComponentSwizzleEnums, pCreateInfo->components.b, VALIDATION_ERROR_02e01001);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->components.a", "VkComponentSwizzle", AllVkComponentSwizzleEnums, pCreateInfo->components.a, VALIDATION_ERROR_02e00001);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->xChromaOffset", "VkChromaLocationKHR", AllVkChromaLocationKHREnums, pCreateInfo->xChromaOffset, VALIDATION_ERROR_3f83d801);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->yChromaOffset", "VkChromaLocationKHR", AllVkChromaLocationKHREnums, pCreateInfo->yChromaOffset, VALIDATION_ERROR_3f83da01);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->chromaFilter", "VkFilter", AllVkFilterEnums, pCreateInfo->chromaFilter, VALIDATION_ERROR_3f83dc01);

        skip |= validate_bool32(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pCreateInfo->forceExplicitReconstruction", pCreateInfo->forceExplicitReconstruction);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateSamplerYcbcrConversionKHR", "pYcbcrConversion", pYcbcrConversion, VALIDATION_ERROR_3fe3e001);

    PFN_manual_vkCreateSamplerYcbcrConversionKHR custom_func = (PFN_manual_vkCreateSamplerYcbcrConversionKHR)custom_functions["vkCreateSamplerYcbcrConversionKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pYcbcrConversion);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroySamplerYcbcrConversionKHR(
    VkDevice                                    device,
    VkSamplerYcbcrConversionKHR                 ycbcrConversion,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkDestroySamplerYcbcrConversionKHR", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_get_memory_requirements_2) skip |= OutputExtensionError(local_data, "vkDestroySamplerYcbcrConversionKHR", VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_bind_memory_2) skip |= OutputExtensionError(local_data, "vkDestroySamplerYcbcrConversionKHR", VK_KHR_BIND_MEMORY_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_maintenance1) skip |= OutputExtensionError(local_data, "vkDestroySamplerYcbcrConversionKHR", VK_KHR_MAINTENANCE1_EXTENSION_NAME);

    if (!local_data->extensions.vk_khr_sampler_ycbcr_conversion) skip |= OutputExtensionError(local_data, "vkDestroySamplerYcbcrConversionKHR", VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroySamplerYcbcrConversionKHR", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySamplerYcbcrConversionKHR", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroySamplerYcbcrConversionKHR", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroySamplerYcbcrConversionKHR custom_func = (PFN_manual_vkDestroySamplerYcbcrConversionKHR)custom_functions["vkDestroySamplerYcbcrConversionKHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, ycbcrConversion, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
    }
}



VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory2KHR(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindBufferMemoryInfoKHR*            pBindInfos)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_bind_memory_2) skip |= OutputExtensionError(local_data, "vkBindBufferMemory2KHR", VK_KHR_BIND_MEMORY_2_EXTENSION_NAME);

    skip |= validate_struct_type_array(local_data->report_data, "vkBindBufferMemory2KHR", "bindInfoCount", "pBindInfos", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR", bindInfoCount, pBindInfos, VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR, true, true, VALIDATION_ERROR_1720fa01);

    if (pBindInfos != NULL)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            const VkStructureType allowed_structs_VkBindBufferMemoryInfoKHR[] = { VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHX };

            skip |= validate_struct_pnext(local_data->report_data, "vkBindBufferMemory2KHR", ParameterName("pBindInfos[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), "VkBindBufferMemoryDeviceGroupInfoKHX", pBindInfos[bindInfoIndex].pNext, ARRAY_SIZE(allowed_structs_VkBindBufferMemoryInfoKHR), allowed_structs_VkBindBufferMemoryInfoKHR, GeneratedHeaderVersion, VALIDATION_ERROR_00c1c40d);

            skip |= validate_required_handle(local_data->report_data, "vkBindBufferMemory2KHR", ParameterName("pBindInfos[%i].buffer", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].buffer);

            skip |= validate_required_handle(local_data->report_data, "vkBindBufferMemory2KHR", ParameterName("pBindInfos[%i].memory", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].memory);
        }
    }

    PFN_manual_vkBindBufferMemory2KHR custom_func = (PFN_manual_vkBindBufferMemory2KHR)custom_functions["vkBindBufferMemory2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, bindInfoCount, pBindInfos);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.BindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory2KHR(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindImageMemoryInfoKHR*             pBindInfos)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_bind_memory_2) skip |= OutputExtensionError(local_data, "vkBindImageMemory2KHR", VK_KHR_BIND_MEMORY_2_EXTENSION_NAME);

    skip |= validate_struct_type_array(local_data->report_data, "vkBindImageMemory2KHR", "bindInfoCount", "pBindInfos", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR", bindInfoCount, pBindInfos, VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR, true, true, VALIDATION_ERROR_1760fa01);

    if (pBindInfos != NULL)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            const VkStructureType allowed_structs_VkBindImageMemoryInfoKHR[] = { VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHX, VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX, VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR };

            skip |= validate_struct_pnext(local_data->report_data, "vkBindImageMemory2KHR", ParameterName("pBindInfos[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), "VkBindImageMemoryDeviceGroupInfoKHX, VkBindImageMemorySwapchainInfoKHX, VkBindImagePlaneMemoryInfoKHR", pBindInfos[bindInfoIndex].pNext, ARRAY_SIZE(allowed_structs_VkBindImageMemoryInfoKHR), allowed_structs_VkBindImageMemoryInfoKHR, GeneratedHeaderVersion, VALIDATION_ERROR_00e1c40d);

            skip |= validate_required_handle(local_data->report_data, "vkBindImageMemory2KHR", ParameterName("pBindInfos[%i].image", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].image);
        }
    }

    PFN_manual_vkBindImageMemory2KHR custom_func = (PFN_manual_vkBindImageMemory2KHR)custom_functions["vkBindImageMemory2KHR"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, bindInfoCount, pBindInfos);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.BindImageMemory2KHR(device, bindInfoCount, pBindInfos);
    }
    return result;
}



// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR VkResult VKAPI_CALL vkCreateDebugReportCallbackEXT(
    VkInstance                                  instance,
    const VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDebugReportCallbackEXT*                   pCallback);

bool parameter_validation_vkCreateDebugReportCallbackEXT(
    VkInstance                                  instance,
    const VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDebugReportCallbackEXT*                   pCallback)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;

    if (!local_data->extensions.vk_ext_debug_report) skip |= OutputExtensionError(local_data, "vkCreateDebugReportCallbackEXT", VK_EXT_DEBUG_REPORT_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateDebugReportCallbackEXT", "pCreateInfo", "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, true, VALIDATION_ERROR_03c2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateDebugReportCallbackEXT", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_03c1c40d);

        skip |= validate_flags(local_data->report_data, "vkCreateDebugReportCallbackEXT", "pCreateInfo->flags", "VkDebugReportFlagBitsEXT", AllVkDebugReportFlagBitsEXT, pCreateInfo->flags, false, false, VALIDATION_ERROR_03c09001);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDebugReportCallbackEXT", "pCreateInfo->pfnCallback", reinterpret_cast<const void*>(pCreateInfo->pfnCallback), VALIDATION_ERROR_UNDEFINED);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateDebugReportCallbackEXT", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDebugReportCallbackEXT", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateDebugReportCallbackEXT", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateDebugReportCallbackEXT", "pCallback", pCallback, VALIDATION_ERROR_1f410801);

    return skip;
}

// Generated function handles validation only -- API definition is in non-generated source
extern VKAPI_ATTR void VKAPI_CALL vkDestroyDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackEXT                    callback,
    const VkAllocationCallbacks*                pAllocator);

bool parameter_validation_vkDestroyDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackEXT                    callback,
    const VkAllocationCallbacks*                pAllocator)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;

    if (!local_data->extensions.vk_ext_debug_report) skip |= OutputExtensionError(local_data, "vkDestroyDebugReportCallbackEXT", VK_EXT_DEBUG_REPORT_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkDestroyDebugReportCallbackEXT", "callback", callback);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDebugReportCallbackEXT", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDebugReportCallbackEXT", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyDebugReportCallbackEXT", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    return skip;
}

VKAPI_ATTR void VKAPI_CALL vkDebugReportMessageEXT(
    VkInstance                                  instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_debug_report) skip |= OutputExtensionError(local_data, "vkDebugReportMessageEXT", VK_EXT_DEBUG_REPORT_EXTENSION_NAME);

    skip |= validate_flags(local_data->report_data, "vkDebugReportMessageEXT", "flags", "VkDebugReportFlagBitsEXT", AllVkDebugReportFlagBitsEXT, flags, true, false, VALIDATION_ERROR_23a09003);

    skip |= validate_ranged_enum(local_data->report_data, "vkDebugReportMessageEXT", "objectType", "VkDebugReportObjectTypeEXT", AllVkDebugReportObjectTypeEXTEnums, objectType, VALIDATION_ERROR_23a0da01);

    skip |= validate_required_pointer(local_data->report_data, "vkDebugReportMessageEXT", "pLayerPrefix", pLayerPrefix, VALIDATION_ERROR_23a1a001);

    skip |= validate_required_pointer(local_data->report_data, "vkDebugReportMessageEXT", "pMessage", pMessage, VALIDATION_ERROR_23a1b801);

    PFN_manual_vkDebugReportMessageEXT custom_func = (PFN_manual_vkDebugReportMessageEXT)custom_functions["vkDebugReportMessageEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
    }
}















VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectTagEXT(
    VkDevice                                    device,
    const VkDebugMarkerObjectTagInfoEXT*        pTagInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_debug_report) skip |= OutputExtensionError(local_data, "vkDebugMarkerSetObjectTagEXT", VK_EXT_DEBUG_REPORT_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_debug_marker) skip |= OutputExtensionError(local_data, "vkDebugMarkerSetObjectTagEXT", VK_EXT_DEBUG_MARKER_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkDebugMarkerSetObjectTagEXT", "pTagInfo", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT", pTagInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT, true, VALIDATION_ERROR_03a2b00b);

    if (pTagInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkDebugMarkerSetObjectTagEXT", "pTagInfo->pNext", NULL, pTagInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_03a1c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkDebugMarkerSetObjectTagEXT", "pTagInfo->objectType", "VkDebugReportObjectTypeEXT", AllVkDebugReportObjectTypeEXTEnums, pTagInfo->objectType, VALIDATION_ERROR_03a0da01);

        skip |= validate_array(local_data->report_data, "vkDebugMarkerSetObjectTagEXT", "pTagInfo->tagSize", "pTagInfo->pTag", pTagInfo->tagSize, pTagInfo->pTag, true, true, VALIDATION_ERROR_03a2f41b, VALIDATION_ERROR_03a25a01);
    }

    PFN_manual_vkDebugMarkerSetObjectTagEXT custom_func = (PFN_manual_vkDebugMarkerSetObjectTagEXT)custom_functions["vkDebugMarkerSetObjectTagEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pTagInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.DebugMarkerSetObjectTagEXT(device, pTagInfo);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectNameEXT(
    VkDevice                                    device,
    const VkDebugMarkerObjectNameInfoEXT*       pNameInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_debug_report) skip |= OutputExtensionError(local_data, "vkDebugMarkerSetObjectNameEXT", VK_EXT_DEBUG_REPORT_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_debug_marker) skip |= OutputExtensionError(local_data, "vkDebugMarkerSetObjectNameEXT", VK_EXT_DEBUG_MARKER_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkDebugMarkerSetObjectNameEXT", "pNameInfo", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT", pNameInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT, true, VALIDATION_ERROR_0382b00b);

    if (pNameInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkDebugMarkerSetObjectNameEXT", "pNameInfo->pNext", NULL, pNameInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0381c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkDebugMarkerSetObjectNameEXT", "pNameInfo->objectType", "VkDebugReportObjectTypeEXT", AllVkDebugReportObjectTypeEXTEnums, pNameInfo->objectType, VALIDATION_ERROR_0380da01);

        skip |= validate_required_pointer(local_data->report_data, "vkDebugMarkerSetObjectNameEXT", "pNameInfo->pObjectName", pNameInfo->pObjectName, VALIDATION_ERROR_0381ce01);
    }

    PFN_manual_vkDebugMarkerSetObjectNameEXT custom_func = (PFN_manual_vkDebugMarkerSetObjectNameEXT)custom_functions["vkDebugMarkerSetObjectNameEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pNameInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.DebugMarkerSetObjectNameEXT(device, pNameInfo);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_debug_report) skip |= OutputExtensionError(local_data, "vkCmdDebugMarkerBeginEXT", VK_EXT_DEBUG_REPORT_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_debug_marker) skip |= OutputExtensionError(local_data, "vkCmdDebugMarkerBeginEXT", VK_EXT_DEBUG_MARKER_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCmdDebugMarkerBeginEXT", "pMarkerInfo", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT", pMarkerInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, true, VALIDATION_ERROR_0362b00b);

    if (pMarkerInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCmdDebugMarkerBeginEXT", "pMarkerInfo->pNext", NULL, pMarkerInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0361c40d);

        skip |= validate_required_pointer(local_data->report_data, "vkCmdDebugMarkerBeginEXT", "pMarkerInfo->pMarkerName", pMarkerInfo->pMarkerName, VALIDATION_ERROR_0361a801);
    }

    PFN_manual_vkCmdDebugMarkerBeginEXT custom_func = (PFN_manual_vkCmdDebugMarkerBeginEXT)custom_functions["vkCmdDebugMarkerBeginEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pMarkerInfo);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_debug_report) skip |= OutputExtensionError(local_data, "vkCmdDebugMarkerInsertEXT", VK_EXT_DEBUG_REPORT_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_debug_marker) skip |= OutputExtensionError(local_data, "vkCmdDebugMarkerInsertEXT", VK_EXT_DEBUG_MARKER_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCmdDebugMarkerInsertEXT", "pMarkerInfo", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT", pMarkerInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, true, VALIDATION_ERROR_0362b00b);

    if (pMarkerInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCmdDebugMarkerInsertEXT", "pMarkerInfo->pNext", NULL, pMarkerInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0361c40d);

        skip |= validate_required_pointer(local_data->report_data, "vkCmdDebugMarkerInsertEXT", "pMarkerInfo->pMarkerName", pMarkerInfo->pMarkerName, VALIDATION_ERROR_0361a801);
    }

    PFN_manual_vkCmdDebugMarkerInsertEXT custom_func = (PFN_manual_vkCmdDebugMarkerInsertEXT)custom_functions["vkCmdDebugMarkerInsertEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pMarkerInfo);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
    }
}







VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_amd_draw_indirect_count) skip |= OutputExtensionError(local_data, "vkCmdDrawIndirectCountAMD", VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkCmdDrawIndirectCountAMD", "buffer", buffer);

    skip |= validate_required_handle(local_data->report_data, "vkCmdDrawIndirectCountAMD", "countBuffer", countBuffer);

    PFN_manual_vkCmdDrawIndirectCountAMD custom_func = (PFN_manual_vkCmdDrawIndirectCountAMD)custom_functions["vkCmdDrawIndirectCountAMD"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_amd_draw_indirect_count) skip |= OutputExtensionError(local_data, "vkCmdDrawIndexedIndirectCountAMD", VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkCmdDrawIndexedIndirectCountAMD", "buffer", buffer);

    skip |= validate_required_handle(local_data->report_data, "vkCmdDrawIndexedIndirectCountAMD", "countBuffer", countBuffer);

    PFN_manual_vkCmdDrawIndexedIndirectCountAMD custom_func = (PFN_manual_vkCmdDrawIndexedIndirectCountAMD)custom_functions["vkCmdDrawIndexedIndirectCountAMD"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    }
}











VKAPI_ATTR VkResult VKAPI_CALL vkGetShaderInfoAMD(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    VkShaderStageFlagBits                       shaderStage,
    VkShaderInfoTypeAMD                         infoType,
    size_t*                                     pInfoSize,
    void*                                       pInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_amd_shader_info) skip |= OutputExtensionError(local_data, "vkGetShaderInfoAMD", VK_AMD_SHADER_INFO_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetShaderInfoAMD", "pipeline", pipeline);

    skip |= validate_flags(local_data->report_data, "vkGetShaderInfoAMD", "shaderStage", "VkShaderStageFlagBits", AllVkShaderStageFlagBits, shaderStage, true, true, VALIDATION_ERROR_40e3ec01);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetShaderInfoAMD", "infoType", "VkShaderInfoTypeAMD", AllVkShaderInfoTypeAMDEnums, infoType, VALIDATION_ERROR_40e3ee01);

    skip |= validate_array(local_data->report_data, "vkGetShaderInfoAMD", "pInfoSize", "pInfo", pInfoSize, pInfo, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_40e39c01);

    PFN_manual_vkGetShaderInfoAMD custom_func = (PFN_manual_vkGetShaderInfoAMD)custom_functions["vkGetShaderInfoAMD"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
    }
    return result;
}









VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nv_external_memory_capabilities) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", "format", "VkFormat", AllVkFormatEnums, format, VALIDATION_ERROR_2bc09201);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", "type", "VkImageType", AllVkImageTypeEnums, type, VALIDATION_ERROR_2bc30401);

    skip |= validate_ranged_enum(local_data->report_data, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", "tiling", "VkImageTiling", AllVkImageTilingEnums, tiling, VALIDATION_ERROR_2bc2fa01);

    skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", "usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, usage, true, false, VALIDATION_ERROR_2bc30603);

    skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", "flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, flags, false, false, VALIDATION_ERROR_2bc09001);

    skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", "externalHandleType", "VkExternalMemoryHandleTypeFlagBitsNV", AllVkExternalMemoryHandleTypeFlagBitsNV, externalHandleType, false, false, VALIDATION_ERROR_2bc08201);

    skip |= validate_required_pointer(local_data->report_data, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", "pExternalImageFormatProperties", pExternalImageFormatProperties, VALIDATION_ERROR_2bc16601);

    PFN_manual_vkGetPhysicalDeviceExternalImageFormatPropertiesNV custom_func = (PFN_manual_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)custom_functions["vkGetPhysicalDeviceExternalImageFormatPropertiesNV"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
    }
    return result;
}





#ifdef VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandleNV(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE*                                     pHandle)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nv_external_memory) skip |= OutputExtensionError(local_data, "vkGetMemoryWin32HandleNV", VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME);

    if (!local_data->extensions.vk_nv_external_memory_win32) skip |= OutputExtensionError(local_data, "vkGetMemoryWin32HandleNV", VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetMemoryWin32HandleNV", "memory", memory);

    skip |= validate_flags(local_data->report_data, "vkGetMemoryWin32HandleNV", "handleType", "VkExternalMemoryHandleTypeFlagBitsNV", AllVkExternalMemoryHandleTypeFlagBitsNV, handleType, true, false, VALIDATION_ERROR_2b009c03);

    skip |= validate_required_pointer(local_data->report_data, "vkGetMemoryWin32HandleNV", "pHandle", pHandle, VALIDATION_ERROR_2b017c01);

    PFN_manual_vkGetMemoryWin32HandleNV custom_func = (PFN_manual_vkGetMemoryWin32HandleNV)custom_functions["vkGetMemoryWin32HandleNV"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, memory, handleType, pHandle);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetMemoryWin32HandleNV(device, memory, handleType, pHandle);
    }
    return result;
}

#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR

#endif // VK_USE_PLATFORM_WIN32_KHR

VKAPI_ATTR void VKAPI_CALL vkGetDeviceGroupPeerMemoryFeaturesKHX(
    VkDevice                                    device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    VkPeerMemoryFeatureFlagsKHX*                pPeerMemoryFeatures)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khx_device_group_creation) skip |= OutputExtensionError(local_data, "vkGetDeviceGroupPeerMemoryFeaturesKHX", VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group) skip |= OutputExtensionError(local_data, "vkGetDeviceGroupPeerMemoryFeaturesKHX", VK_KHX_DEVICE_GROUP_EXTENSION_NAME);

    // No xml-driven validation

    PFN_manual_vkGetDeviceGroupPeerMemoryFeaturesKHX custom_func = (PFN_manual_vkGetDeviceGroupPeerMemoryFeaturesKHX)custom_functions["vkGetDeviceGroupPeerMemoryFeaturesKHX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetDeviceGroupPeerMemoryFeaturesKHX(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdSetDeviceMaskKHX(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    deviceMask)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khx_device_group_creation) skip |= OutputExtensionError(local_data, "vkCmdSetDeviceMaskKHX", VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group) skip |= OutputExtensionError(local_data, "vkCmdSetDeviceMaskKHX", VK_KHX_DEVICE_GROUP_EXTENSION_NAME);

    // No xml-driven validation

    PFN_manual_vkCmdSetDeviceMaskKHX custom_func = (PFN_manual_vkCmdSetDeviceMaskKHX)custom_functions["vkCmdSetDeviceMaskKHX"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, deviceMask);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetDeviceMaskKHX(commandBuffer, deviceMask);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdDispatchBaseKHX(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khx_device_group_creation) skip |= OutputExtensionError(local_data, "vkCmdDispatchBaseKHX", VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group) skip |= OutputExtensionError(local_data, "vkCmdDispatchBaseKHX", VK_KHX_DEVICE_GROUP_EXTENSION_NAME);

    // No xml-driven validation

    PFN_manual_vkCmdDispatchBaseKHX custom_func = (PFN_manual_vkCmdDispatchBaseKHX)custom_functions["vkCmdDispatchBaseKHX"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdDispatchBaseKHX(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetDeviceGroupPresentCapabilitiesKHX(
    VkDevice                                    device,
    VkDeviceGroupPresentCapabilitiesKHX*        pDeviceGroupPresentCapabilities)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetDeviceGroupPresentCapabilitiesKHX", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group_creation) skip |= OutputExtensionError(local_data, "vkGetDeviceGroupPresentCapabilitiesKHX", VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group) skip |= OutputExtensionError(local_data, "vkGetDeviceGroupPresentCapabilitiesKHX", VK_KHX_DEVICE_GROUP_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkGetDeviceGroupPresentCapabilitiesKHX", "pDeviceGroupPresentCapabilities", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX", pDeviceGroupPresentCapabilities, VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX, true, VALIDATION_ERROR_34a2b00b);

    PFN_manual_vkGetDeviceGroupPresentCapabilitiesKHX custom_func = (PFN_manual_vkGetDeviceGroupPresentCapabilitiesKHX)custom_functions["vkGetDeviceGroupPresentCapabilitiesKHX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pDeviceGroupPresentCapabilities);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetDeviceGroupPresentCapabilitiesKHX(device, pDeviceGroupPresentCapabilities);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetDeviceGroupSurfacePresentModesKHX(
    VkDevice                                    device,
    VkSurfaceKHR                                surface,
    VkDeviceGroupPresentModeFlagsKHX*           pModes)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkGetDeviceGroupSurfacePresentModesKHX", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group_creation) skip |= OutputExtensionError(local_data, "vkGetDeviceGroupSurfacePresentModesKHX", VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group) skip |= OutputExtensionError(local_data, "vkGetDeviceGroupSurfacePresentModesKHX", VK_KHX_DEVICE_GROUP_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetDeviceGroupSurfacePresentModesKHX", "surface", surface);

    PFN_manual_vkGetDeviceGroupSurfacePresentModesKHX custom_func = (PFN_manual_vkGetDeviceGroupSurfacePresentModesKHX)custom_functions["vkGetDeviceGroupSurfacePresentModesKHX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, surface, pModes);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetDeviceGroupSurfacePresentModesKHX(device, surface, pModes);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDevicePresentRectanglesKHX(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pRectCount,
    VkRect2D*                                   pRects)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_required_handle(local_data->report_data, "vkGetPhysicalDevicePresentRectanglesKHX", "surface", surface);

    skip |= validate_array(local_data->report_data, "vkGetPhysicalDevicePresentRectanglesKHX", "pRectCount", "pRects", pRectCount, pRects, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2d420e01);

    PFN_manual_vkGetPhysicalDevicePresentRectanglesKHX custom_func = (PFN_manual_vkGetPhysicalDevicePresentRectanglesKHX)custom_functions["vkGetPhysicalDevicePresentRectanglesKHX"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, surface, pRectCount, pRects);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDevicePresentRectanglesKHX(physicalDevice, surface, pRectCount, pRects);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkAcquireNextImage2KHX(
    VkDevice                                    device,
    const VkAcquireNextImageInfoKHX*            pAcquireInfo,
    uint32_t*                                   pImageIndex)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkAcquireNextImage2KHX", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group_creation) skip |= OutputExtensionError(local_data, "vkAcquireNextImage2KHX", VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME);

    if (!local_data->extensions.vk_khx_device_group) skip |= OutputExtensionError(local_data, "vkAcquireNextImage2KHX", VK_KHX_DEVICE_GROUP_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkAcquireNextImage2KHX", "pAcquireInfo", "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX", pAcquireInfo, VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX, true, VALIDATION_ERROR_0002b00b);

    if (pAcquireInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkAcquireNextImage2KHX", "pAcquireInfo->pNext", NULL, pAcquireInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0001c40d);

        skip |= validate_required_handle(local_data->report_data, "vkAcquireNextImage2KHX", "pAcquireInfo->swapchain", pAcquireInfo->swapchain);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkAcquireNextImage2KHX", "pImageIndex", pImageIndex, VALIDATION_ERROR_16218601);

    PFN_manual_vkAcquireNextImage2KHX custom_func = (PFN_manual_vkAcquireNextImage2KHX)custom_functions["vkAcquireNextImage2KHX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pAcquireInfo, pImageIndex);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.AcquireNextImage2KHX(device, pAcquireInfo, pImageIndex);
    }
    return result;
}





#ifdef VK_USE_PLATFORM_VI_NN

VKAPI_ATTR VkResult VKAPI_CALL vkCreateViSurfaceNN(
    VkInstance                                  instance,
    const VkViSurfaceCreateInfoNN*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateViSurfaceNN", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_nn_vi_surface) skip |= OutputExtensionError(local_data, "vkCreateViSurfaceNN", VK_NN_VI_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateViSurfaceNN", "pCreateInfo", "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN", pCreateInfo, VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN, true, VALIDATION_ERROR_14e2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateViSurfaceNN", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_14e1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateViSurfaceNN", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_14e09005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateViSurfaceNN", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateViSurfaceNN", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateViSurfaceNN", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateViSurfaceNN", "pSurface", pSurface, VALIDATION_ERROR_22c24801);

    PFN_manual_vkCreateViSurfaceNN custom_func = (PFN_manual_vkCreateViSurfaceNN)custom_functions["vkCreateViSurfaceNN"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

#endif // VK_USE_PLATFORM_VI_NN





VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDeviceGroupsKHX(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupPropertiesKHX*         pPhysicalDeviceGroupProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khx_device_group_creation) skip |= OutputExtensionError(local_data, "vkEnumeratePhysicalDeviceGroupsKHX", VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME);

    skip |= validate_struct_type_array(local_data->report_data, "vkEnumeratePhysicalDeviceGroupsKHX", "pPhysicalDeviceGroupCount", "pPhysicalDeviceGroupProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX", pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX, true, false, false, VALIDATION_ERROR_27e1da01);

    PFN_manual_vkEnumeratePhysicalDeviceGroupsKHX custom_func = (PFN_manual_vkEnumeratePhysicalDeviceGroupsKHX)custom_functions["vkEnumeratePhysicalDeviceGroupsKHX"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.EnumeratePhysicalDeviceGroupsKHX(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    }
    return result;
}



VKAPI_ATTR void VKAPI_CALL vkCmdProcessCommandsNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCmdProcessCommandsInfoNVX*          pProcessCommandsInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nvx_device_generated_commands) skip |= OutputExtensionError(local_data, "vkCmdProcessCommandsNVX", VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCmdProcessCommandsNVX", "pProcessCommandsInfo", "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX", pProcessCommandsInfo, VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX, true, VALIDATION_ERROR_0222b00b);

    if (pProcessCommandsInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCmdProcessCommandsNVX", "pProcessCommandsInfo->pNext", NULL, pProcessCommandsInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0221c40d);

        skip |= validate_required_handle(local_data->report_data, "vkCmdProcessCommandsNVX", "pProcessCommandsInfo->objectTable", pProcessCommandsInfo->objectTable);

        skip |= validate_required_handle(local_data->report_data, "vkCmdProcessCommandsNVX", "pProcessCommandsInfo->indirectCommandsLayout", pProcessCommandsInfo->indirectCommandsLayout);

        skip |= validate_array(local_data->report_data, "vkCmdProcessCommandsNVX", "pProcessCommandsInfo->indirectCommandsTokenCount", "pProcessCommandsInfo->pIndirectCommandsTokens", pProcessCommandsInfo->indirectCommandsTokenCount, pProcessCommandsInfo->pIndirectCommandsTokens, true, true, VALIDATION_ERROR_0220b61b, VALIDATION_ERROR_02219401);

        if (pProcessCommandsInfo->pIndirectCommandsTokens != NULL)
        {
            for (uint32_t indirectCommandsTokenIndex = 0; indirectCommandsTokenIndex < pProcessCommandsInfo->indirectCommandsTokenCount; ++indirectCommandsTokenIndex)
            {
                skip |= validate_ranged_enum(local_data->report_data, "vkCmdProcessCommandsNVX", ParameterName("pProcessCommandsInfo->pIndirectCommandsTokens[%i].tokenType", ParameterName::IndexVector{ indirectCommandsTokenIndex }), "VkIndirectCommandsTokenTypeNVX", AllVkIndirectCommandsTokenTypeNVXEnums, pProcessCommandsInfo->pIndirectCommandsTokens[indirectCommandsTokenIndex].tokenType, VALIDATION_ERROR_0bc2fe01);

                skip |= validate_required_handle(local_data->report_data, "vkCmdProcessCommandsNVX", ParameterName("pProcessCommandsInfo->pIndirectCommandsTokens[%i].buffer", ParameterName::IndexVector{ indirectCommandsTokenIndex }), pProcessCommandsInfo->pIndirectCommandsTokens[indirectCommandsTokenIndex].buffer);
            }
        }
    }

    PFN_manual_vkCmdProcessCommandsNVX custom_func = (PFN_manual_vkCmdProcessCommandsNVX)custom_functions["vkCmdProcessCommandsNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pProcessCommandsInfo);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo);
    }
}

VKAPI_ATTR void VKAPI_CALL vkCmdReserveSpaceForCommandsNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX*  pReserveSpaceInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nvx_device_generated_commands) skip |= OutputExtensionError(local_data, "vkCmdReserveSpaceForCommandsNVX", VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCmdReserveSpaceForCommandsNVX", "pReserveSpaceInfo", "VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX", pReserveSpaceInfo, VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX, true, VALIDATION_ERROR_0242b00b);

    if (pReserveSpaceInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCmdReserveSpaceForCommandsNVX", "pReserveSpaceInfo->pNext", NULL, pReserveSpaceInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0241c40d);

        skip |= validate_required_handle(local_data->report_data, "vkCmdReserveSpaceForCommandsNVX", "pReserveSpaceInfo->objectTable", pReserveSpaceInfo->objectTable);

        skip |= validate_required_handle(local_data->report_data, "vkCmdReserveSpaceForCommandsNVX", "pReserveSpaceInfo->indirectCommandsLayout", pReserveSpaceInfo->indirectCommandsLayout);
    }

    PFN_manual_vkCmdReserveSpaceForCommandsNVX custom_func = (PFN_manual_vkCmdReserveSpaceForCommandsNVX)custom_functions["vkCmdReserveSpaceForCommandsNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pReserveSpaceInfo);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateIndirectCommandsLayoutNVX(
    VkDevice                                    device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkIndirectCommandsLayoutNVX*                pIndirectCommandsLayout)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nvx_device_generated_commands) skip |= OutputExtensionError(local_data, "vkCreateIndirectCommandsLayoutNVX", VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pCreateInfo", "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX", pCreateInfo, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX, true, VALIDATION_ERROR_0b82b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0b81c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pCreateInfo->pipelineBindPoint", "VkPipelineBindPoint", AllVkPipelineBindPointEnums, pCreateInfo->pipelineBindPoint, VALIDATION_ERROR_0b827e01);

        skip |= validate_flags(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pCreateInfo->flags", "VkIndirectCommandsLayoutUsageFlagBitsNVX", AllVkIndirectCommandsLayoutUsageFlagBitsNVX, pCreateInfo->flags, true, false, VALIDATION_ERROR_0b809003);

        skip |= validate_array(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pCreateInfo->tokenCount", "pCreateInfo->pTokens", pCreateInfo->tokenCount, pCreateInfo->pTokens, true, true, VALIDATION_ERROR_0b82fc1b, VALIDATION_ERROR_0b826001);

        if (pCreateInfo->pTokens != NULL)
        {
            for (uint32_t tokenIndex = 0; tokenIndex < pCreateInfo->tokenCount; ++tokenIndex)
            {
                skip |= validate_ranged_enum(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", ParameterName("pCreateInfo->pTokens[%i].tokenType", ParameterName::IndexVector{ tokenIndex }), "VkIndirectCommandsTokenTypeNVX", AllVkIndirectCommandsTokenTypeNVXEnums, pCreateInfo->pTokens[tokenIndex].tokenType, VALIDATION_ERROR_0ba2fe01);
            }
        }
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateIndirectCommandsLayoutNVX", "pIndirectCommandsLayout", pIndirectCommandsLayout, VALIDATION_ERROR_21019201);

    PFN_manual_vkCreateIndirectCommandsLayoutNVX custom_func = (PFN_manual_vkCreateIndirectCommandsLayoutNVX)custom_functions["vkCreateIndirectCommandsLayoutNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyIndirectCommandsLayoutNVX(
    VkDevice                                    device,
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nvx_device_generated_commands) skip |= OutputExtensionError(local_data, "vkDestroyIndirectCommandsLayoutNVX", VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkDestroyIndirectCommandsLayoutNVX", "indirectCommandsLayout", indirectCommandsLayout);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyIndirectCommandsLayoutNVX", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyIndirectCommandsLayoutNVX", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyIndirectCommandsLayoutNVX", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyIndirectCommandsLayoutNVX custom_func = (PFN_manual_vkDestroyIndirectCommandsLayoutNVX)custom_functions["vkDestroyIndirectCommandsLayoutNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, indirectCommandsLayout, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkCreateObjectTableNVX(
    VkDevice                                    device,
    const VkObjectTableCreateInfoNVX*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkObjectTableNVX*                           pObjectTable)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nvx_device_generated_commands) skip |= OutputExtensionError(local_data, "vkCreateObjectTableNVX", VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateObjectTableNVX", "pCreateInfo", "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX", pCreateInfo, VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX, true, VALIDATION_ERROR_0cc2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateObjectTableNVX", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0cc1c40d);

        skip |= validate_ranged_enum_array(local_data->report_data, "vkCreateObjectTableNVX", "pCreateInfo->objectCount", "pCreateInfo->pObjectEntryTypes", "VkObjectEntryTypeNVX", AllVkObjectEntryTypeNVXEnums, pCreateInfo->objectCount, pCreateInfo->pObjectEntryTypes, true, true);

        skip |= validate_array(local_data->report_data, "vkCreateObjectTableNVX", "pCreateInfo->objectCount", "pCreateInfo->pObjectEntryCounts", pCreateInfo->objectCount, pCreateInfo->pObjectEntryCounts, true, true, VALIDATION_ERROR_0cc0d61b, VALIDATION_ERROR_0cc1c601);

        skip |= validate_flags_array(local_data->report_data, "vkCreateObjectTableNVX", "pCreateInfo->objectCount", "pCreateInfo->pObjectEntryUsageFlags", "VkObjectEntryUsageFlagBitsNVX", AllVkObjectEntryUsageFlagBitsNVX, pCreateInfo->objectCount, pCreateInfo->pObjectEntryUsageFlags, true, true);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateObjectTableNVX", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateObjectTableNVX", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateObjectTableNVX", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateObjectTableNVX", "pObjectTable", pObjectTable, VALIDATION_ERROR_2181d001);

    PFN_manual_vkCreateObjectTableNVX custom_func = (PFN_manual_vkCreateObjectTableNVX)custom_functions["vkCreateObjectTableNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pObjectTable);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateObjectTableNVX(device, pCreateInfo, pAllocator, pObjectTable);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyObjectTableNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nvx_device_generated_commands) skip |= OutputExtensionError(local_data, "vkDestroyObjectTableNVX", VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkDestroyObjectTableNVX", "objectTable", objectTable);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyObjectTableNVX", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyObjectTableNVX", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyObjectTableNVX", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyObjectTableNVX custom_func = (PFN_manual_vkDestroyObjectTableNVX)custom_functions["vkDestroyObjectTableNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, objectTable, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyObjectTableNVX(device, objectTable, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkRegisterObjectsNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    uint32_t                                    objectCount,
    const VkObjectTableEntryNVX* const*         ppObjectTableEntries,
    const uint32_t*                             pObjectIndices)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nvx_device_generated_commands) skip |= OutputExtensionError(local_data, "vkRegisterObjectsNVX", VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkRegisterObjectsNVX", "objectTable", objectTable);

    skip |= validate_array(local_data->report_data, "vkRegisterObjectsNVX", "objectCount", "ppObjectTableEntries", objectCount, ppObjectTableEntries, true, true, VALIDATION_ERROR_3220d61b, VALIDATION_ERROR_32229201);

    if (ppObjectTableEntries != NULL)
    {
        for (uint32_t objectIndex = 0; objectIndex < objectCount; ++objectIndex)
        {
            skip |= validate_ranged_enum(local_data->report_data, "vkRegisterObjectsNVX", ParameterName("ppObjectTableEntries[%i]->type", ParameterName::IndexVector{ objectIndex }), "VkObjectEntryTypeNVX", AllVkObjectEntryTypeNVXEnums, ppObjectTableEntries[objectIndex]->type, VALIDATION_ERROR_0d030401);

            skip |= validate_flags(local_data->report_data, "vkRegisterObjectsNVX", ParameterName("ppObjectTableEntries[%i]->flags", ParameterName::IndexVector{ objectIndex }), "VkObjectEntryUsageFlagBitsNVX", AllVkObjectEntryUsageFlagBitsNVX, ppObjectTableEntries[objectIndex]->flags, true, false, VALIDATION_ERROR_0d009003);
        }
    }

    skip |= validate_array(local_data->report_data, "vkRegisterObjectsNVX", "objectCount", "pObjectIndices", objectCount, pObjectIndices, true, true, VALIDATION_ERROR_3220d61b, VALIDATION_ERROR_3221cc01);

    PFN_manual_vkRegisterObjectsNVX custom_func = (PFN_manual_vkRegisterObjectsNVX)custom_functions["vkRegisterObjectsNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.RegisterObjectsNVX(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkUnregisterObjectsNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    uint32_t                                    objectCount,
    const VkObjectEntryTypeNVX*                 pObjectEntryTypes,
    const uint32_t*                             pObjectIndices)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nvx_device_generated_commands) skip |= OutputExtensionError(local_data, "vkUnregisterObjectsNVX", VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkUnregisterObjectsNVX", "objectTable", objectTable);

    skip |= validate_ranged_enum_array(local_data->report_data, "vkUnregisterObjectsNVX", "objectCount", "pObjectEntryTypes", "VkObjectEntryTypeNVX", AllVkObjectEntryTypeNVXEnums, objectCount, pObjectEntryTypes, true, true);

    skip |= validate_array(local_data->report_data, "vkUnregisterObjectsNVX", "objectCount", "pObjectIndices", objectCount, pObjectIndices, true, true, VALIDATION_ERROR_3380d61b, VALIDATION_ERROR_3381cc01);

    PFN_manual_vkUnregisterObjectsNVX custom_func = (PFN_manual_vkUnregisterObjectsNVX)custom_functions["vkUnregisterObjectsNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.UnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice                            physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX*       pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX*         pLimits)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX", "pFeatures", "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX", pFeatures, VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX, true, VALIDATION_ERROR_05a2b00b);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX", "pLimits", "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX", pLimits, VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX, true, VALIDATION_ERROR_05c2b00b);

    PFN_manual_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX custom_func = (PFN_manual_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX)custom_functions["vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, pFeatures, pLimits);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, pLimits);
    }
}



VKAPI_ATTR void VKAPI_CALL vkCmdSetViewportWScalingNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewportWScalingNV*                 pViewportWScalings)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_nv_clip_space_w_scaling) skip |= OutputExtensionError(local_data, "vkCmdSetViewportWScalingNV", VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME);

    skip |= validate_array(local_data->report_data, "vkCmdSetViewportWScalingNV", "viewportCount", "pViewportWScalings", viewportCount, pViewportWScalings, true, true, VALIDATION_ERROR_1e230a1b, VALIDATION_ERROR_1e23fc01);

    if (pViewportWScalings != NULL)
    {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex)
        {
            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdSetViewportWScalingNV custom_func = (PFN_manual_vkCmdSetViewportWScalingNV)custom_functions["vkCmdSetViewportWScalingNV"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
    }
}



VKAPI_ATTR VkResult VKAPI_CALL vkReleaseDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkReleaseDisplayEXT", VK_KHR_DISPLAY_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_direct_mode_display) skip |= OutputExtensionError(local_data, "vkReleaseDisplayEXT", VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkReleaseDisplayEXT", "display", display);

    PFN_manual_vkReleaseDisplayEXT custom_func = (PFN_manual_vkReleaseDisplayEXT)custom_functions["vkReleaseDisplayEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, display);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.ReleaseDisplayEXT(physicalDevice, display);
    }
    return result;
}



#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT

VKAPI_ATTR VkResult VKAPI_CALL vkAcquireXlibDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    VkDisplayKHR                                display)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_direct_mode_display) skip |= OutputExtensionError(local_data, "vkAcquireXlibDisplayEXT", VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_acquire_xlib_display) skip |= OutputExtensionError(local_data, "vkAcquireXlibDisplayEXT", VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME);

    skip |= validate_required_pointer(local_data->report_data, "vkAcquireXlibDisplayEXT", "dpy", dpy, VALIDATION_ERROR_16606601);

    skip |= validate_required_handle(local_data->report_data, "vkAcquireXlibDisplayEXT", "display", display);

    PFN_manual_vkAcquireXlibDisplayEXT custom_func = (PFN_manual_vkAcquireXlibDisplayEXT)custom_functions["vkAcquireXlibDisplayEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, dpy, display);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.AcquireXlibDisplayEXT(physicalDevice, dpy, display);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetRandROutputDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    RROutput                                    rrOutput,
    VkDisplayKHR*                               pDisplay)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_direct_mode_display) skip |= OutputExtensionError(local_data, "vkGetRandROutputDisplayEXT", VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_acquire_xlib_display) skip |= OutputExtensionError(local_data, "vkGetRandROutputDisplayEXT", VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME);

    skip |= validate_required_pointer(local_data->report_data, "vkGetRandROutputDisplayEXT", "dpy", dpy, VALIDATION_ERROR_2fc06601);

    skip |= validate_required_pointer(local_data->report_data, "vkGetRandROutputDisplayEXT", "pDisplay", pDisplay, VALIDATION_ERROR_2fc14801);

    PFN_manual_vkGetRandROutputDisplayEXT custom_func = (PFN_manual_vkGetRandROutputDisplayEXT)custom_functions["vkGetRandROutputDisplayEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, dpy, rrOutput, pDisplay);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
    }
    return result;
}

#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilities2EXT*                  pSurfaceCapabilities)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_display) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceCapabilities2EXT", VK_KHR_DISPLAY_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_surface_counter) skip |= OutputExtensionError(local_data, "vkGetPhysicalDeviceSurfaceCapabilities2EXT", VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetPhysicalDeviceSurfaceCapabilities2EXT", "surface", surface);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceSurfaceCapabilities2EXT", "pSurfaceCapabilities", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT", pSurfaceCapabilities, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT, true, VALIDATION_ERROR_1422b00b);

    PFN_manual_vkGetPhysicalDeviceSurfaceCapabilities2EXT custom_func = (PFN_manual_vkGetPhysicalDeviceSurfaceCapabilities2EXT)custom_functions["vkGetPhysicalDeviceSurfaceCapabilities2EXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, surface, pSurfaceCapabilities);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
    }
    return result;
}



VKAPI_ATTR VkResult VKAPI_CALL vkDisplayPowerControlEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    const VkDisplayPowerInfoEXT*                pDisplayPowerInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkDisplayPowerControlEXT", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_surface_counter) skip |= OutputExtensionError(local_data, "vkDisplayPowerControlEXT", VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_control) skip |= OutputExtensionError(local_data, "vkDisplayPowerControlEXT", VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkDisplayPowerControlEXT", "display", display);

    skip |= validate_struct_type(local_data->report_data, "vkDisplayPowerControlEXT", "pDisplayPowerInfo", "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT", pDisplayPowerInfo, VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT, true, VALIDATION_ERROR_0742b00b);

    if (pDisplayPowerInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkDisplayPowerControlEXT", "pDisplayPowerInfo->pNext", NULL, pDisplayPowerInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0741c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkDisplayPowerControlEXT", "pDisplayPowerInfo->powerState", "VkDisplayPowerStateEXT", AllVkDisplayPowerStateEXTEnums, pDisplayPowerInfo->powerState, VALIDATION_ERROR_07428a01);
    }

    PFN_manual_vkDisplayPowerControlEXT custom_func = (PFN_manual_vkDisplayPowerControlEXT)custom_functions["vkDisplayPowerControlEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, display, pDisplayPowerInfo);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.DisplayPowerControlEXT(device, display, pDisplayPowerInfo);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkRegisterDeviceEventEXT(
    VkDevice                                    device,
    const VkDeviceEventInfoEXT*                 pDeviceEventInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkRegisterDeviceEventEXT", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_surface_counter) skip |= OutputExtensionError(local_data, "vkRegisterDeviceEventEXT", VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_control) skip |= OutputExtensionError(local_data, "vkRegisterDeviceEventEXT", VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkRegisterDeviceEventEXT", "pDeviceEventInfo", "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT", pDeviceEventInfo, VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT, true, VALIDATION_ERROR_0582b00b);

    if (pDeviceEventInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkRegisterDeviceEventEXT", "pDeviceEventInfo->pNext", NULL, pDeviceEventInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0581c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkRegisterDeviceEventEXT", "pDeviceEventInfo->deviceEvent", "VkDeviceEventTypeEXT", AllVkDeviceEventTypeEXTEnums, pDeviceEventInfo->deviceEvent, VALIDATION_ERROR_05805801);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkRegisterDeviceEventEXT", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkRegisterDeviceEventEXT", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkRegisterDeviceEventEXT", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkRegisterDeviceEventEXT", "pFence", pFence, VALIDATION_ERROR_31e17001);

    PFN_manual_vkRegisterDeviceEventEXT custom_func = (PFN_manual_vkRegisterDeviceEventEXT)custom_functions["vkRegisterDeviceEventEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pDeviceEventInfo, pAllocator, pFence);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkRegisterDisplayEventEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    const VkDisplayEventInfoEXT*                pDisplayEventInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkRegisterDisplayEventEXT", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_surface_counter) skip |= OutputExtensionError(local_data, "vkRegisterDisplayEventEXT", VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_control) skip |= OutputExtensionError(local_data, "vkRegisterDisplayEventEXT", VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkRegisterDisplayEventEXT", "display", display);

    skip |= validate_struct_type(local_data->report_data, "vkRegisterDisplayEventEXT", "pDisplayEventInfo", "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT", pDisplayEventInfo, VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT, true, VALIDATION_ERROR_0702b00b);

    if (pDisplayEventInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkRegisterDisplayEventEXT", "pDisplayEventInfo->pNext", NULL, pDisplayEventInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0701c40d);

        skip |= validate_ranged_enum(local_data->report_data, "vkRegisterDisplayEventEXT", "pDisplayEventInfo->displayEvent", "VkDisplayEventTypeEXT", AllVkDisplayEventTypeEXTEnums, pDisplayEventInfo->displayEvent, VALIDATION_ERROR_07006201);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkRegisterDisplayEventEXT", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkRegisterDisplayEventEXT", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkRegisterDisplayEventEXT", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkRegisterDisplayEventEXT", "pFence", pFence, VALIDATION_ERROR_32017001);

    PFN_manual_vkRegisterDisplayEventEXT custom_func = (PFN_manual_vkRegisterDisplayEventEXT)custom_functions["vkRegisterDisplayEventEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, display, pDisplayEventInfo, pAllocator, pFence);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainCounterEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    uint64_t*                                   pCounterValue)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkGetSwapchainCounterEXT", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_surface_counter) skip |= OutputExtensionError(local_data, "vkGetSwapchainCounterEXT", VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_display_control) skip |= OutputExtensionError(local_data, "vkGetSwapchainCounterEXT", VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetSwapchainCounterEXT", "swapchain", swapchain);

    skip |= validate_flags(local_data->report_data, "vkGetSwapchainCounterEXT", "counter", "VkSurfaceCounterFlagBitsEXT", AllVkSurfaceCounterFlagBitsEXT, counter, true, true, VALIDATION_ERROR_30603601);

    skip |= validate_required_pointer(local_data->report_data, "vkGetSwapchainCounterEXT", "pCounterValue", pCounterValue, VALIDATION_ERROR_30611c01);

    PFN_manual_vkGetSwapchainCounterEXT custom_func = (PFN_manual_vkGetSwapchainCounterEXT)custom_functions["vkGetSwapchainCounterEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchain, counter, pCounterValue);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
    }
    return result;
}



VKAPI_ATTR VkResult VKAPI_CALL vkGetRefreshCycleDurationGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkRefreshCycleDurationGOOGLE*               pDisplayTimingProperties)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkGetRefreshCycleDurationGOOGLE", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_google_display_timing) skip |= OutputExtensionError(local_data, "vkGetRefreshCycleDurationGOOGLE", VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetRefreshCycleDurationGOOGLE", "swapchain", swapchain);

    skip |= validate_required_pointer(local_data->report_data, "vkGetRefreshCycleDurationGOOGLE", "pDisplayTimingProperties", pDisplayTimingProperties, VALIDATION_ERROR_2fe15001);

    PFN_manual_vkGetRefreshCycleDurationGOOGLE custom_func = (PFN_manual_vkGetRefreshCycleDurationGOOGLE)custom_functions["vkGetRefreshCycleDurationGOOGLE"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchain, pDisplayTimingProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetPastPresentationTimingGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE*             pPresentationTimings)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkGetPastPresentationTimingGOOGLE", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_google_display_timing) skip |= OutputExtensionError(local_data, "vkGetPastPresentationTimingGOOGLE", VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetPastPresentationTimingGOOGLE", "swapchain", swapchain);

    skip |= validate_array(local_data->report_data, "vkGetPastPresentationTimingGOOGLE", "pPresentationTimingCount", "pPresentationTimings", pPresentationTimingCount, pPresentationTimings, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_2b41ee01);

    PFN_manual_vkGetPastPresentationTimingGOOGLE custom_func = (PFN_manual_vkGetPastPresentationTimingGOOGLE)custom_functions["vkGetPastPresentationTimingGOOGLE"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchain, pPresentationTimingCount, pPresentationTimings);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings);
    }
    return result;
}













VKAPI_ATTR void VKAPI_CALL vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstDiscardRectangle,
    uint32_t                                    discardRectangleCount,
    const VkRect2D*                             pDiscardRectangles)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_get_physical_device_properties_2) skip |= OutputExtensionError(local_data, "vkCmdSetDiscardRectangleEXT", VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_discard_rectangles) skip |= OutputExtensionError(local_data, "vkCmdSetDiscardRectangleEXT", VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME);

    skip |= validate_array(local_data->report_data, "vkCmdSetDiscardRectangleEXT", "discardRectangleCount", "pDiscardRectangles", discardRectangleCount, pDiscardRectangles, true, true, VALIDATION_ERROR_1d205c1b, VALIDATION_ERROR_1d214601);

    if (pDiscardRectangles != NULL)
    {
        for (uint32_t discardRectangleIndex = 0; discardRectangleIndex < discardRectangleCount; ++discardRectangleIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }

    PFN_manual_vkCmdSetDiscardRectangleEXT custom_func = (PFN_manual_vkCmdSetDiscardRectangleEXT)custom_functions["vkCmdSetDiscardRectangleEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
    }
}







VKAPI_ATTR void VKAPI_CALL vkSetHdrMetadataEXT(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    const VkSwapchainKHR*                       pSwapchains,
    const VkHdrMetadataEXT*                     pMetadata)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_swapchain) skip |= OutputExtensionError(local_data, "vkSetHdrMetadataEXT", VK_KHR_SWAPCHAIN_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_hdr_metadata) skip |= OutputExtensionError(local_data, "vkSetHdrMetadataEXT", VK_EXT_HDR_METADATA_EXTENSION_NAME);

    skip |= validate_handle_array(local_data->report_data, "vkSetHdrMetadataEXT", "swapchainCount", "pSwapchains", swapchainCount, pSwapchains, true, true);

    skip |= validate_struct_type_array(local_data->report_data, "vkSetHdrMetadataEXT", "swapchainCount", "pMetadata", "VK_STRUCTURE_TYPE_HDR_METADATA_EXT", swapchainCount, pMetadata, VK_STRUCTURE_TYPE_HDR_METADATA_EXT, true, true, VALIDATION_ERROR_3321ba01);

    if (pMetadata != NULL)
    {
        for (uint32_t swapchainIndex = 0; swapchainIndex < swapchainCount; ++swapchainIndex)
        {
            skip |= validate_struct_pnext(local_data->report_data, "vkSetHdrMetadataEXT", ParameterName("pMetadata[%i].pNext", ParameterName::IndexVector{ swapchainIndex }), NULL, pMetadata[swapchainIndex].pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_UNDEFINED);

            // No xml-driven validation

            // No xml-driven validation

            // No xml-driven validation

            // No xml-driven validation
        }
    }

    PFN_manual_vkSetHdrMetadataEXT custom_func = (PFN_manual_vkSetHdrMetadataEXT)custom_functions["vkSetHdrMetadataEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, swapchainCount, pSwapchains, pMetadata);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
    }
}



#ifdef VK_USE_PLATFORM_IOS_MVK

VKAPI_ATTR VkResult VKAPI_CALL vkCreateIOSSurfaceMVK(
    VkInstance                                  instance,
    const VkIOSSurfaceCreateInfoMVK*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateIOSSurfaceMVK", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_mvk_ios_surface) skip |= OutputExtensionError(local_data, "vkCreateIOSSurfaceMVK", VK_MVK_IOS_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateIOSSurfaceMVK", "pCreateInfo", "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK", pCreateInfo, VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK, true, VALIDATION_ERROR_0982b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateIOSSurfaceMVK", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0981c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateIOSSurfaceMVK", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_09809005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateIOSSurfaceMVK", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateIOSSurfaceMVK", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateIOSSurfaceMVK", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateIOSSurfaceMVK", "pSurface", pSurface, VALIDATION_ERROR_20a24801);

    PFN_manual_vkCreateIOSSurfaceMVK custom_func = (PFN_manual_vkCreateIOSSurfaceMVK)custom_functions["vkCreateIOSSurfaceMVK"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

#endif // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK

VKAPI_ATTR VkResult VKAPI_CALL vkCreateMacOSSurfaceMVK(
    VkInstance                                  instance,
    const VkMacOSSurfaceCreateInfoMVK*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(instance), instance_layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_surface) skip |= OutputExtensionError(local_data, "vkCreateMacOSSurfaceMVK", VK_KHR_SURFACE_EXTENSION_NAME);

    if (!local_data->extensions.vk_mvk_macos_surface) skip |= OutputExtensionError(local_data, "vkCreateMacOSSurfaceMVK", VK_MVK_MACOS_SURFACE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateMacOSSurfaceMVK", "pCreateInfo", "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK", pCreateInfo, VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK, true, VALIDATION_ERROR_0c02b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateMacOSSurfaceMVK", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_0c01c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateMacOSSurfaceMVK", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_0c009005);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateMacOSSurfaceMVK", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateMacOSSurfaceMVK", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateMacOSSurfaceMVK", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateMacOSSurfaceMVK", "pSurface", pSurface, VALIDATION_ERROR_21424801);

    PFN_manual_vkCreateMacOSSurfaceMVK custom_func = (PFN_manual_vkCreateMacOSSurfaceMVK)custom_functions["vkCreateMacOSSurfaceMVK"];
    if (custom_func != nullptr) {
        skip |= custom_func(instance, pCreateInfo, pAllocator, pSurface);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
    }
    return result;
}

#endif // VK_USE_PLATFORM_MACOS_MVK















VKAPI_ATTR void VKAPI_CALL vkCmdSetSampleLocationsEXT(
    VkCommandBuffer                             commandBuffer,
    const VkSampleLocationsInfoEXT*             pSampleLocationsInfo)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_sample_locations) skip |= OutputExtensionError(local_data, "vkCmdSetSampleLocationsEXT", VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCmdSetSampleLocationsEXT", "pSampleLocationsInfo", "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT", pSampleLocationsInfo, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, true, VALIDATION_ERROR_3ce2b00b);

    if (pSampleLocationsInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCmdSetSampleLocationsEXT", "pSampleLocationsInfo->pNext", NULL, pSampleLocationsInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3ce1c40d);

        skip |= validate_flags(local_data->report_data, "vkCmdSetSampleLocationsEXT", "pSampleLocationsInfo->sampleLocationsPerPixel", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pSampleLocationsInfo->sampleLocationsPerPixel, true, true, VALIDATION_ERROR_3ce3b201);

        // No xml-driven validation

        skip |= validate_array(local_data->report_data, "vkCmdSetSampleLocationsEXT", "pSampleLocationsInfo->sampleLocationsCount", "pSampleLocationsInfo->pSampleLocations", pSampleLocationsInfo->sampleLocationsCount, pSampleLocationsInfo->pSampleLocations, true, true, VALIDATION_ERROR_3ce3b41b, VALIDATION_ERROR_3ce3b601);

        if (pSampleLocationsInfo->pSampleLocations != NULL)
        {
            for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < pSampleLocationsInfo->sampleLocationsCount; ++sampleLocationsIndex)
            {
                // No xml-driven validation
            }
        }
    }

    PFN_manual_vkCmdSetSampleLocationsEXT custom_func = (PFN_manual_vkCmdSetSampleLocationsEXT)custom_functions["vkCmdSetSampleLocationsEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pSampleLocationsInfo);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
    }
}

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice                            physicalDevice,
    VkSampleCountFlagBits                       samples,
    VkMultisamplePropertiesEXT*                 pMultisampleProperties)
{
    instance_layer_data *local_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    skip |= validate_flags(local_data->report_data, "vkGetPhysicalDeviceMultisamplePropertiesEXT", "samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, samples, true, true, VALIDATION_ERROR_3d82b401);

    skip |= validate_struct_type(local_data->report_data, "vkGetPhysicalDeviceMultisamplePropertiesEXT", "pMultisampleProperties", "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT", pMultisampleProperties, VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT, true, VALIDATION_ERROR_3d62b00b);

    PFN_manual_vkGetPhysicalDeviceMultisamplePropertiesEXT custom_func = (PFN_manual_vkGetPhysicalDeviceMultisamplePropertiesEXT)custom_functions["vkGetPhysicalDeviceMultisamplePropertiesEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(physicalDevice, samples, pMultisampleProperties);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
    }
}













VKAPI_ATTR VkResult VKAPI_CALL vkCreateValidationCacheEXT(
    VkDevice                                    device,
    const VkValidationCacheCreateInfoEXT*       pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkValidationCacheEXT*                       pValidationCache)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_validation_cache) skip |= OutputExtensionError(local_data, "vkCreateValidationCacheEXT", VK_EXT_VALIDATION_CACHE_EXTENSION_NAME);

    skip |= validate_struct_type(local_data->report_data, "vkCreateValidationCacheEXT", "pCreateInfo", "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT, true, VALIDATION_ERROR_3da2b00b);

    if (pCreateInfo != NULL)
    {
        skip |= validate_struct_pnext(local_data->report_data, "vkCreateValidationCacheEXT", "pCreateInfo->pNext", NULL, pCreateInfo->pNext, 0, NULL, GeneratedHeaderVersion, VALIDATION_ERROR_3da1c40d);

        skip |= validate_reserved_flags(local_data->report_data, "vkCreateValidationCacheEXT", "pCreateInfo->flags", pCreateInfo->flags, VALIDATION_ERROR_3da09005);

        skip |= validate_array(local_data->report_data, "vkCreateValidationCacheEXT", "pCreateInfo->initialDataSize", "pCreateInfo->pInitialData", pCreateInfo->initialDataSize, pCreateInfo->pInitialData, false, true, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_3da19601);
    }

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkCreateValidationCacheEXT", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateValidationCacheEXT", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkCreateValidationCacheEXT", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    skip |= validate_required_pointer(local_data->report_data, "vkCreateValidationCacheEXT", "pValidationCache", pValidationCache, VALIDATION_ERROR_3de3c201);

    PFN_manual_vkCreateValidationCacheEXT custom_func = (PFN_manual_vkCreateValidationCacheEXT)custom_functions["vkCreateValidationCacheEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, pCreateInfo, pAllocator, pValidationCache);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.CreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL vkDestroyValidationCacheEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        validationCache,
    const VkAllocationCallbacks*                pAllocator)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_validation_cache) skip |= OutputExtensionError(local_data, "vkDestroyValidationCacheEXT", VK_EXT_VALIDATION_CACHE_EXTENSION_NAME);

    if (pAllocator != NULL)
    {
        skip |= validate_required_pointer(local_data->report_data, "vkDestroyValidationCacheEXT", "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), VALIDATION_ERROR_002004f0);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyValidationCacheEXT", "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), VALIDATION_ERROR_002004f2);

        skip |= validate_required_pointer(local_data->report_data, "vkDestroyValidationCacheEXT", "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), VALIDATION_ERROR_002004f4);
    }

    PFN_manual_vkDestroyValidationCacheEXT custom_func = (PFN_manual_vkDestroyValidationCacheEXT)custom_functions["vkDestroyValidationCacheEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, validationCache, pAllocator);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.DestroyValidationCacheEXT(device, validationCache, pAllocator);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL vkMergeValidationCachesEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        dstCache,
    uint32_t                                    srcCacheCount,
    const VkValidationCacheEXT*                 pSrcCaches)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_validation_cache) skip |= OutputExtensionError(local_data, "vkMergeValidationCachesEXT", VK_EXT_VALIDATION_CACHE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkMergeValidationCachesEXT", "dstCache", dstCache);

    skip |= validate_handle_array(local_data->report_data, "vkMergeValidationCachesEXT", "srcCacheCount", "pSrcCaches", srcCacheCount, pSrcCaches, true, true);

    PFN_manual_vkMergeValidationCachesEXT custom_func = (PFN_manual_vkMergeValidationCachesEXT)custom_functions["vkMergeValidationCachesEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, dstCache, srcCacheCount, pSrcCaches);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
    }
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL vkGetValidationCacheDataEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        validationCache,
    size_t*                                     pDataSize,
    void*                                       pData)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_ext_validation_cache) skip |= OutputExtensionError(local_data, "vkGetValidationCacheDataEXT", VK_EXT_VALIDATION_CACHE_EXTENSION_NAME);

    skip |= validate_required_handle(local_data->report_data, "vkGetValidationCacheDataEXT", "validationCache", validationCache);

    skip |= validate_array(local_data->report_data, "vkGetValidationCacheDataEXT", "pDataSize", "pData", pDataSize, pData, true, false, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_3e012201);

    PFN_manual_vkGetValidationCacheDataEXT custom_func = (PFN_manual_vkGetValidationCacheDataEXT)custom_functions["vkGetValidationCacheDataEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, validationCache, pDataSize, pData);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
    }
    return result;
}







VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    const void*                                 pHostPointer,
    VkMemoryHostPointerPropertiesEXT*           pMemoryHostPointerProperties)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
    bool skip = false;
    VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_khr_external_memory) skip |= OutputExtensionError(local_data, "vkGetMemoryHostPointerPropertiesEXT", VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME);

    if (!local_data->extensions.vk_ext_external_memory_host) skip |= OutputExtensionError(local_data, "vkGetMemoryHostPointerPropertiesEXT", VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME);

    skip |= validate_flags(local_data->report_data, "vkGetMemoryHostPointerPropertiesEXT", "handleType", "VkExternalMemoryHandleTypeFlagBitsKHR", AllVkExternalMemoryHandleTypeFlagBitsKHR, handleType, true, true, VALIDATION_ERROR_41809c01);

    skip |= validate_required_pointer(local_data->report_data, "vkGetMemoryHostPointerPropertiesEXT", "pHostPointer", pHostPointer, VALIDATION_ERROR_UNDEFINED);

    skip |= validate_struct_type(local_data->report_data, "vkGetMemoryHostPointerPropertiesEXT", "pMemoryHostPointerProperties", "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT", pMemoryHostPointerProperties, VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT, true, VALIDATION_ERROR_4142b00b);

    PFN_manual_vkGetMemoryHostPointerPropertiesEXT custom_func = (PFN_manual_vkGetMemoryHostPointerPropertiesEXT)custom_functions["vkGetMemoryHostPointerPropertiesEXT"];
    if (custom_func != nullptr) {
        skip |= custom_func(device, handleType, pHostPointer, pMemoryHostPointerProperties);
    }

    lock.unlock();
    if (!skip) {
            result = local_data->dispatch_table.GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
    }
    return result;
}



VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker)
{
    layer_data *local_data = GetLayerDataPtr(get_dispatch_key(commandBuffer), layer_data_map);
    bool skip = false;
    std::unique_lock<std::mutex> lock(global_lock);

    if (!local_data->extensions.vk_amd_buffer_marker) skip |= OutputExtensionError(local_data, "vkCmdWriteBufferMarkerAMD", VK_AMD_BUFFER_MARKER_EXTENSION_NAME);

    skip |= validate_flags(local_data->report_data, "vkCmdWriteBufferMarkerAMD", "pipelineStage", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pipelineStage, true, true, VALIDATION_ERROR_41e28401);

    skip |= validate_required_handle(local_data->report_data, "vkCmdWriteBufferMarkerAMD", "dstBuffer", dstBuffer);

    PFN_manual_vkCmdWriteBufferMarkerAMD custom_func = (PFN_manual_vkCmdWriteBufferMarkerAMD)custom_functions["vkCmdWriteBufferMarkerAMD"];
    if (custom_func != nullptr) {
        skip |= custom_func(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
    }

    lock.unlock();
    if (!skip) {
        local_data->dispatch_table.CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
    }
}




// Declarations
VKAPI_ATTR VkResult VKAPI_CALL CreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);
VKAPI_ATTR void VKAPI_CALL DestroyInstance(
    VkInstance                                  instance,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL EnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties);
VKAPI_ATTR VkResult VKAPI_CALL CreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);
VKAPI_ATTR void VKAPI_CALL DestroyDevice(
    VkDevice                                    device,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR void VKAPI_CALL GetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue);
VKAPI_ATTR VkResult VKAPI_CALL QueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo*                         pSubmits,
    VkFence                                     fence);
VKAPI_ATTR VkResult VKAPI_CALL QueueWaitIdle(
    VkQueue                                     queue);
VKAPI_ATTR VkResult VKAPI_CALL DeviceWaitIdle(
    VkDevice                                    device);
VKAPI_ATTR VkResult VKAPI_CALL AllocateMemory(
    VkDevice                                    device,
    const VkMemoryAllocateInfo*                 pAllocateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory);
VKAPI_ATTR void VKAPI_CALL FreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL MapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData);
VKAPI_ATTR void VKAPI_CALL UnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory);
VKAPI_ATTR VkResult VKAPI_CALL FlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges);
VKAPI_ATTR VkResult VKAPI_CALL InvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges);
VKAPI_ATTR void VKAPI_CALL GetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes);
VKAPI_ATTR VkResult VKAPI_CALL BindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);
VKAPI_ATTR VkResult VKAPI_CALL BindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);
VKAPI_ATTR void VKAPI_CALL GetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements);
VKAPI_ATTR void VKAPI_CALL GetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements);
VKAPI_ATTR void VKAPI_CALL GetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties);
VKAPI_ATTR VkResult VKAPI_CALL QueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    const VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence);
VKAPI_ATTR VkResult VKAPI_CALL CreateFence(
    VkDevice                                    device,
    const VkFenceCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);
VKAPI_ATTR void VKAPI_CALL DestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL ResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences);
VKAPI_ATTR VkResult VKAPI_CALL GetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence);
VKAPI_ATTR VkResult VKAPI_CALL WaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout);
VKAPI_ATTR VkResult VKAPI_CALL CreateSemaphore(
    VkDevice                                    device,
    const VkSemaphoreCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore);
VKAPI_ATTR void VKAPI_CALL DestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateEvent(
    VkDevice                                    device,
    const VkEventCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent);
VKAPI_ATTR void VKAPI_CALL DestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL GetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event);
VKAPI_ATTR VkResult VKAPI_CALL SetEvent(
    VkDevice                                    device,
    VkEvent                                     event);
VKAPI_ATTR VkResult VKAPI_CALL ResetEvent(
    VkDevice                                    device,
    VkEvent                                     event);
VKAPI_ATTR VkResult VKAPI_CALL CreateQueryPool(
    VkDevice                                    device,
    const VkQueryPoolCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool);
VKAPI_ATTR void VKAPI_CALL DestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL GetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);
VKAPI_ATTR VkResult VKAPI_CALL CreateBuffer(
    VkDevice                                    device,
    const VkBufferCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer);
VKAPI_ATTR void VKAPI_CALL DestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateBufferView(
    VkDevice                                    device,
    const VkBufferViewCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView);
VKAPI_ATTR void VKAPI_CALL DestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateImage(
    VkDevice                                    device,
    const VkImageCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage);
VKAPI_ATTR void VKAPI_CALL DestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR void VKAPI_CALL GetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    const VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout);
VKAPI_ATTR VkResult VKAPI_CALL CreateImageView(
    VkDevice                                    device,
    const VkImageViewCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView);
VKAPI_ATTR void VKAPI_CALL DestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);
VKAPI_ATTR void VKAPI_CALL DestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreatePipelineCache(
    VkDevice                                    device,
    const VkPipelineCacheCreateInfo*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache);
VKAPI_ATTR void VKAPI_CALL DestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL GetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData);
VKAPI_ATTR VkResult VKAPI_CALL MergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    const VkPipelineCache*                      pSrcCaches);
VKAPI_ATTR VkResult VKAPI_CALL CreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkGraphicsPipelineCreateInfo*         pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);
VKAPI_ATTR VkResult VKAPI_CALL CreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkComputePipelineCreateInfo*          pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);
VKAPI_ATTR void VKAPI_CALL DestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreatePipelineLayout(
    VkDevice                                    device,
    const VkPipelineLayoutCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout);
VKAPI_ATTR void VKAPI_CALL DestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateSampler(
    VkDevice                                    device,
    const VkSamplerCreateInfo*                  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler);
VKAPI_ATTR void VKAPI_CALL DestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateDescriptorSetLayout(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout);
VKAPI_ATTR void VKAPI_CALL DestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateDescriptorPool(
    VkDevice                                    device,
    const VkDescriptorPoolCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool);
VKAPI_ATTR void VKAPI_CALL DestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL ResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags);
VKAPI_ATTR VkResult VKAPI_CALL AllocateDescriptorSets(
    VkDevice                                    device,
    const VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets);
VKAPI_ATTR VkResult VKAPI_CALL FreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets);
VKAPI_ATTR void VKAPI_CALL UpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const VkCopyDescriptorSet*                  pDescriptorCopies);
VKAPI_ATTR VkResult VKAPI_CALL CreateFramebuffer(
    VkDevice                                    device,
    const VkFramebufferCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer);
VKAPI_ATTR void VKAPI_CALL DestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateRenderPass(
    VkDevice                                    device,
    const VkRenderPassCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass);
VKAPI_ATTR void VKAPI_CALL DestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR void VKAPI_CALL GetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity);
VKAPI_ATTR VkResult VKAPI_CALL CreateCommandPool(
    VkDevice                                    device,
    const VkCommandPoolCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool);
VKAPI_ATTR void VKAPI_CALL DestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL ResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags);
VKAPI_ATTR VkResult VKAPI_CALL AllocateCommandBuffers(
    VkDevice                                    device,
    const VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers);
VKAPI_ATTR void VKAPI_CALL FreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers);
VKAPI_ATTR VkResult VKAPI_CALL BeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    const VkCommandBufferBeginInfo*             pBeginInfo);
VKAPI_ATTR VkResult VKAPI_CALL EndCommandBuffer(
    VkCommandBuffer                             commandBuffer);
VKAPI_ATTR VkResult VKAPI_CALL ResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags);
VKAPI_ATTR void VKAPI_CALL CmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline);
VKAPI_ATTR void VKAPI_CALL CmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewport*                           pViewports);
VKAPI_ATTR void VKAPI_CALL CmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const VkRect2D*                             pScissors);
VKAPI_ATTR void VKAPI_CALL CmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth);
VKAPI_ATTR void VKAPI_CALL CmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor);
VKAPI_ATTR void VKAPI_CALL CmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    const float                                 blendConstants[4]);
VKAPI_ATTR void VKAPI_CALL CmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);
VKAPI_ATTR void VKAPI_CALL CmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask);
VKAPI_ATTR void VKAPI_CALL CmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask);
VKAPI_ATTR void VKAPI_CALL CmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference);
VKAPI_ATTR void VKAPI_CALL CmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const uint32_t*                             pDynamicOffsets);
VKAPI_ATTR void VKAPI_CALL CmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType);
VKAPI_ATTR void VKAPI_CALL CmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets);
VKAPI_ATTR void VKAPI_CALL CmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);
VKAPI_ATTR void VKAPI_CALL CmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);
VKAPI_ATTR void VKAPI_CALL CmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);
VKAPI_ATTR void VKAPI_CALL CmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);
VKAPI_ATTR void VKAPI_CALL CmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ);
VKAPI_ATTR void VKAPI_CALL CmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset);
VKAPI_ATTR void VKAPI_CALL CmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferCopy*                         pRegions);
VKAPI_ATTR void VKAPI_CALL CmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageCopy*                          pRegions);
VKAPI_ATTR void VKAPI_CALL CmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageBlit*                          pRegions,
    VkFilter                                    filter);
VKAPI_ATTR void VKAPI_CALL CmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions);
VKAPI_ATTR void VKAPI_CALL CmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions);
VKAPI_ATTR void VKAPI_CALL CmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const void*                                 pData);
VKAPI_ATTR void VKAPI_CALL CmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data);
VKAPI_ATTR void VKAPI_CALL CmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges);
VKAPI_ATTR void VKAPI_CALL CmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges);
VKAPI_ATTR void VKAPI_CALL CmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    const VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    const VkClearRect*                          pRects);
VKAPI_ATTR void VKAPI_CALL CmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageResolve*                       pRegions);
VKAPI_ATTR void VKAPI_CALL CmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);
VKAPI_ATTR void VKAPI_CALL CmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);
VKAPI_ATTR void VKAPI_CALL CmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers);
VKAPI_ATTR void VKAPI_CALL CmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers);
VKAPI_ATTR void VKAPI_CALL CmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags);
VKAPI_ATTR void VKAPI_CALL CmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);
VKAPI_ATTR void VKAPI_CALL CmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount);
VKAPI_ATTR void VKAPI_CALL CmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);
VKAPI_ATTR void VKAPI_CALL CmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);
VKAPI_ATTR void VKAPI_CALL CmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const void*                                 pValues);
VKAPI_ATTR void VKAPI_CALL CmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents);
VKAPI_ATTR void VKAPI_CALL CmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents);
VKAPI_ATTR void VKAPI_CALL CmdEndRenderPass(
    VkCommandBuffer                             commandBuffer);
VKAPI_ATTR void VKAPI_CALL CmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers);
VKAPI_ATTR void VKAPI_CALL DestroySurfaceKHR(
    VkInstance                                  instance,
    VkSurfaceKHR                                surface,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    VkSurfaceKHR                                surface,
    VkBool32*                                   pSupported);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormatKHR*                         pSurfaceFormats);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes);
VKAPI_ATTR VkResult VKAPI_CALL CreateSwapchainKHR(
    VkDevice                                    device,
    const VkSwapchainCreateInfoKHR*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain);
VKAPI_ATTR void VKAPI_CALL DestroySwapchainKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL GetSwapchainImagesKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pSwapchainImageCount,
    VkImage*                                    pSwapchainImages);
VKAPI_ATTR VkResult VKAPI_CALL AcquireNextImageKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t*                                   pImageIndex);
VKAPI_ATTR VkResult VKAPI_CALL QueuePresentKHR(
    VkQueue                                     queue,
    const VkPresentInfoKHR*                     pPresentInfo);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPropertiesKHR*                     pProperties);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlanePropertiesKHR*                pProperties);
VKAPI_ATTR VkResult VKAPI_CALL GetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    planeIndex,
    uint32_t*                                   pDisplayCount,
    VkDisplayKHR*                               pDisplays);
VKAPI_ATTR VkResult VKAPI_CALL GetDisplayModePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModePropertiesKHR*                 pProperties);
VKAPI_ATTR VkResult VKAPI_CALL CreateDisplayModeKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    const VkDisplayModeCreateInfoKHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDisplayModeKHR*                           pMode);
VKAPI_ATTR VkResult VKAPI_CALL GetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayModeKHR                            mode,
    uint32_t                                    planeIndex,
    VkDisplayPlaneCapabilitiesKHR*              pCapabilities);
VKAPI_ATTR VkResult VKAPI_CALL CreateDisplayPlaneSurfaceKHR(
    VkInstance                                  instance,
    const VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
VKAPI_ATTR VkResult VKAPI_CALL CreateSharedSwapchainsKHR(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    const VkSwapchainCreateInfoKHR*             pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchains);
#ifdef VK_USE_PLATFORM_XLIB_KHR
VKAPI_ATTR VkResult VKAPI_CALL CreateXlibSurfaceKHR(
    VkInstance                                  instance,
    const VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
VKAPI_ATTR VkBool32 VKAPI_CALL GetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    Display*                                    dpy,
    VisualID                                    visualID);
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
VKAPI_ATTR VkResult VKAPI_CALL CreateXcbSurfaceKHR(
    VkInstance                                  instance,
    const VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
VKAPI_ATTR VkBool32 VKAPI_CALL GetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    xcb_connection_t*                           connection,
    xcb_visualid_t                              visual_id);
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
VKAPI_ATTR VkResult VKAPI_CALL CreateWaylandSurfaceKHR(
    VkInstance                                  instance,
    const VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
VKAPI_ATTR VkBool32 VKAPI_CALL GetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    struct wl_display*                          display);
#endif
#ifdef VK_USE_PLATFORM_MIR_KHR
VKAPI_ATTR VkResult VKAPI_CALL CreateMirSurfaceKHR(
    VkInstance                                  instance,
    const VkMirSurfaceCreateInfoKHR*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#ifdef VK_USE_PLATFORM_MIR_KHR
VKAPI_ATTR VkBool32 VKAPI_CALL GetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    MirConnection*                              connection);
#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
VKAPI_ATTR VkResult VKAPI_CALL CreateAndroidSurfaceKHR(
    VkInstance                                  instance,
    const VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL CreateWin32SurfaceKHR(
    VkInstance                                  instance,
    const VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkBool32 VKAPI_CALL GetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex);
#endif
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures2KHR*               pFeatures);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties2KHR*             pProperties);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties2KHR*                     pFormatProperties);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2KHR*  pImageFormatInfo,
    VkImageFormatProperties2KHR*                pImageFormatProperties);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2KHR*                pQueueFamilyProperties);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties2KHR*       pMemoryProperties);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2KHR* pFormatInfo,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties2KHR*          pProperties);
VKAPI_ATTR void VKAPI_CALL TrimCommandPoolKHR(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolTrimFlagsKHR                   flags);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalBufferInfoKHR* pExternalBufferInfo,
    VkExternalBufferPropertiesKHR*              pExternalBufferProperties);
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL GetMemoryWin32HandleKHR(
    VkDevice                                    device,
    const VkMemoryGetWin32HandleInfoKHR*        pGetWin32HandleInfo,
    HANDLE*                                     pHandle);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL GetMemoryWin32HandlePropertiesKHR(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    HANDLE                                      handle,
    VkMemoryWin32HandlePropertiesKHR*           pMemoryWin32HandleProperties);
#endif
VKAPI_ATTR VkResult VKAPI_CALL GetMemoryFdKHR(
    VkDevice                                    device,
    const VkMemoryGetFdInfoKHR*                 pGetFdInfo,
    int*                                        pFd);
VKAPI_ATTR VkResult VKAPI_CALL GetMemoryFdPropertiesKHR(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    int                                         fd,
    VkMemoryFdPropertiesKHR*                    pMemoryFdProperties);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfoKHR* pExternalSemaphoreInfo,
    VkExternalSemaphorePropertiesKHR*           pExternalSemaphoreProperties);
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL ImportSemaphoreWin32HandleKHR(
    VkDevice                                    device,
    const VkImportSemaphoreWin32HandleInfoKHR*  pImportSemaphoreWin32HandleInfo);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL GetSemaphoreWin32HandleKHR(
    VkDevice                                    device,
    const VkSemaphoreGetWin32HandleInfoKHR*     pGetWin32HandleInfo,
    HANDLE*                                     pHandle);
#endif
VKAPI_ATTR VkResult VKAPI_CALL ImportSemaphoreFdKHR(
    VkDevice                                    device,
    const VkImportSemaphoreFdInfoKHR*           pImportSemaphoreFdInfo);
VKAPI_ATTR VkResult VKAPI_CALL GetSemaphoreFdKHR(
    VkDevice                                    device,
    const VkSemaphoreGetFdInfoKHR*              pGetFdInfo,
    int*                                        pFd);
VKAPI_ATTR void VKAPI_CALL CmdPushDescriptorSetKHR(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites);
VKAPI_ATTR VkResult VKAPI_CALL CreateDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    const VkDescriptorUpdateTemplateCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplateKHR*              pDescriptorUpdateTemplate);
VKAPI_ATTR void VKAPI_CALL DestroyDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR void VKAPI_CALL UpdateDescriptorSetWithTemplateKHR(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
    const void*                                 pData);
VKAPI_ATTR void VKAPI_CALL CmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer                             commandBuffer,
    VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    const void*                                 pData);
VKAPI_ATTR VkResult VKAPI_CALL GetSwapchainStatusKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalFenceInfoKHR* pExternalFenceInfo,
    VkExternalFencePropertiesKHR*               pExternalFenceProperties);
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL ImportFenceWin32HandleKHR(
    VkDevice                                    device,
    const VkImportFenceWin32HandleInfoKHR*      pImportFenceWin32HandleInfo);
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL GetFenceWin32HandleKHR(
    VkDevice                                    device,
    const VkFenceGetWin32HandleInfoKHR*         pGetWin32HandleInfo,
    HANDLE*                                     pHandle);
#endif
VKAPI_ATTR VkResult VKAPI_CALL ImportFenceFdKHR(
    VkDevice                                    device,
    const VkImportFenceFdInfoKHR*               pImportFenceFdInfo);
VKAPI_ATTR VkResult VKAPI_CALL GetFenceFdKHR(
    VkDevice                                    device,
    const VkFenceGetFdInfoKHR*                  pGetFdInfo,
    int*                                        pFd);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    VkSurfaceCapabilities2KHR*                  pSurfaceCapabilities);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormat2KHR*                        pSurfaceFormats);
VKAPI_ATTR void VKAPI_CALL GetImageMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkImageMemoryRequirementsInfo2KHR*    pInfo,
    VkMemoryRequirements2KHR*                   pMemoryRequirements);
VKAPI_ATTR void VKAPI_CALL GetBufferMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkBufferMemoryRequirementsInfo2KHR*   pInfo,
    VkMemoryRequirements2KHR*                   pMemoryRequirements);
VKAPI_ATTR void VKAPI_CALL GetImageSparseMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkImageSparseMemoryRequirementsInfo2KHR* pInfo,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2KHR*        pSparseMemoryRequirements);
VKAPI_ATTR VkResult VKAPI_CALL CreateSamplerYcbcrConversionKHR(
    VkDevice                                    device,
    const VkSamplerYcbcrConversionCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSamplerYcbcrConversionKHR*                pYcbcrConversion);
VKAPI_ATTR void VKAPI_CALL DestroySamplerYcbcrConversionKHR(
    VkDevice                                    device,
    VkSamplerYcbcrConversionKHR                 ycbcrConversion,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL BindBufferMemory2KHR(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindBufferMemoryInfoKHR*            pBindInfos);
VKAPI_ATTR VkResult VKAPI_CALL BindImageMemory2KHR(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindImageMemoryInfoKHR*             pBindInfos);
VKAPI_ATTR VkResult VKAPI_CALL CreateDebugReportCallbackEXT(
    VkInstance                                  instance,
    const VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDebugReportCallbackEXT*                   pCallback);
VKAPI_ATTR void VKAPI_CALL DestroyDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackEXT                    callback,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR void VKAPI_CALL DebugReportMessageEXT(
    VkInstance                                  instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage);
VKAPI_ATTR VkResult VKAPI_CALL DebugMarkerSetObjectTagEXT(
    VkDevice                                    device,
    const VkDebugMarkerObjectTagInfoEXT*        pTagInfo);
VKAPI_ATTR VkResult VKAPI_CALL DebugMarkerSetObjectNameEXT(
    VkDevice                                    device,
    const VkDebugMarkerObjectNameInfoEXT*       pNameInfo);
VKAPI_ATTR void VKAPI_CALL CmdDebugMarkerBeginEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo);
VKAPI_ATTR void VKAPI_CALL CmdDebugMarkerInsertEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo);
VKAPI_ATTR void VKAPI_CALL CmdDrawIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
VKAPI_ATTR void VKAPI_CALL CmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
VKAPI_ATTR VkResult VKAPI_CALL GetShaderInfoAMD(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    VkShaderStageFlagBits                       shaderStage,
    VkShaderInfoTypeAMD                         infoType,
    size_t*                                     pInfoSize,
    void*                                       pInfo);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties);
#ifdef VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL GetMemoryWin32HandleNV(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE*                                     pHandle);
#endif
VKAPI_ATTR void VKAPI_CALL GetDeviceGroupPeerMemoryFeaturesKHX(
    VkDevice                                    device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    VkPeerMemoryFeatureFlagsKHX*                pPeerMemoryFeatures);
VKAPI_ATTR void VKAPI_CALL CmdSetDeviceMaskKHX(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    deviceMask);
VKAPI_ATTR void VKAPI_CALL CmdDispatchBaseKHX(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ);
VKAPI_ATTR VkResult VKAPI_CALL GetDeviceGroupPresentCapabilitiesKHX(
    VkDevice                                    device,
    VkDeviceGroupPresentCapabilitiesKHX*        pDeviceGroupPresentCapabilities);
VKAPI_ATTR VkResult VKAPI_CALL GetDeviceGroupSurfacePresentModesKHX(
    VkDevice                                    device,
    VkSurfaceKHR                                surface,
    VkDeviceGroupPresentModeFlagsKHX*           pModes);
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDevicePresentRectanglesKHX(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pRectCount,
    VkRect2D*                                   pRects);
VKAPI_ATTR VkResult VKAPI_CALL AcquireNextImage2KHX(
    VkDevice                                    device,
    const VkAcquireNextImageInfoKHX*            pAcquireInfo,
    uint32_t*                                   pImageIndex);
#ifdef VK_USE_PLATFORM_VI_NN
VKAPI_ATTR VkResult VKAPI_CALL CreateViSurfaceNN(
    VkInstance                                  instance,
    const VkViSurfaceCreateInfoNN*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
VKAPI_ATTR VkResult VKAPI_CALL EnumeratePhysicalDeviceGroupsKHX(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupPropertiesKHX*         pPhysicalDeviceGroupProperties);
VKAPI_ATTR void VKAPI_CALL CmdProcessCommandsNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCmdProcessCommandsInfoNVX*          pProcessCommandsInfo);
VKAPI_ATTR void VKAPI_CALL CmdReserveSpaceForCommandsNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX*  pReserveSpaceInfo);
VKAPI_ATTR VkResult VKAPI_CALL CreateIndirectCommandsLayoutNVX(
    VkDevice                                    device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkIndirectCommandsLayoutNVX*                pIndirectCommandsLayout);
VKAPI_ATTR void VKAPI_CALL DestroyIndirectCommandsLayoutNVX(
    VkDevice                                    device,
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL CreateObjectTableNVX(
    VkDevice                                    device,
    const VkObjectTableCreateInfoNVX*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkObjectTableNVX*                           pObjectTable);
VKAPI_ATTR void VKAPI_CALL DestroyObjectTableNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL RegisterObjectsNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    uint32_t                                    objectCount,
    const VkObjectTableEntryNVX* const*         ppObjectTableEntries,
    const uint32_t*                             pObjectIndices);
VKAPI_ATTR VkResult VKAPI_CALL UnregisterObjectsNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    uint32_t                                    objectCount,
    const VkObjectEntryTypeNVX*                 pObjectEntryTypes,
    const uint32_t*                             pObjectIndices);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice                            physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX*       pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX*         pLimits);
VKAPI_ATTR void VKAPI_CALL CmdSetViewportWScalingNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewportWScalingNV*                 pViewportWScalings);
VKAPI_ATTR VkResult VKAPI_CALL ReleaseDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display);
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
VKAPI_ATTR VkResult VKAPI_CALL AcquireXlibDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    VkDisplayKHR                                display);
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
VKAPI_ATTR VkResult VKAPI_CALL GetRandROutputDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    RROutput                                    rrOutput,
    VkDisplayKHR*                               pDisplay);
#endif
VKAPI_ATTR VkResult VKAPI_CALL GetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilities2EXT*                  pSurfaceCapabilities);
VKAPI_ATTR VkResult VKAPI_CALL DisplayPowerControlEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    const VkDisplayPowerInfoEXT*                pDisplayPowerInfo);
VKAPI_ATTR VkResult VKAPI_CALL RegisterDeviceEventEXT(
    VkDevice                                    device,
    const VkDeviceEventInfoEXT*                 pDeviceEventInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);
VKAPI_ATTR VkResult VKAPI_CALL RegisterDisplayEventEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    const VkDisplayEventInfoEXT*                pDisplayEventInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);
VKAPI_ATTR VkResult VKAPI_CALL GetSwapchainCounterEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    uint64_t*                                   pCounterValue);
VKAPI_ATTR VkResult VKAPI_CALL GetRefreshCycleDurationGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkRefreshCycleDurationGOOGLE*               pDisplayTimingProperties);
VKAPI_ATTR VkResult VKAPI_CALL GetPastPresentationTimingGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE*             pPresentationTimings);
VKAPI_ATTR void VKAPI_CALL CmdSetDiscardRectangleEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstDiscardRectangle,
    uint32_t                                    discardRectangleCount,
    const VkRect2D*                             pDiscardRectangles);
VKAPI_ATTR void VKAPI_CALL SetHdrMetadataEXT(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    const VkSwapchainKHR*                       pSwapchains,
    const VkHdrMetadataEXT*                     pMetadata);
#ifdef VK_USE_PLATFORM_IOS_MVK
VKAPI_ATTR VkResult VKAPI_CALL CreateIOSSurfaceMVK(
    VkInstance                                  instance,
    const VkIOSSurfaceCreateInfoMVK*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#ifdef VK_USE_PLATFORM_MACOS_MVK
VKAPI_ATTR VkResult VKAPI_CALL CreateMacOSSurfaceMVK(
    VkInstance                                  instance,
    const VkMacOSSurfaceCreateInfoMVK*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
VKAPI_ATTR void VKAPI_CALL CmdSetSampleLocationsEXT(
    VkCommandBuffer                             commandBuffer,
    const VkSampleLocationsInfoEXT*             pSampleLocationsInfo);
VKAPI_ATTR void VKAPI_CALL GetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice                            physicalDevice,
    VkSampleCountFlagBits                       samples,
    VkMultisamplePropertiesEXT*                 pMultisampleProperties);
VKAPI_ATTR VkResult VKAPI_CALL CreateValidationCacheEXT(
    VkDevice                                    device,
    const VkValidationCacheCreateInfoEXT*       pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkValidationCacheEXT*                       pValidationCache);
VKAPI_ATTR void VKAPI_CALL DestroyValidationCacheEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        validationCache,
    const VkAllocationCallbacks*                pAllocator);
VKAPI_ATTR VkResult VKAPI_CALL MergeValidationCachesEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        dstCache,
    uint32_t                                    srcCacheCount,
    const VkValidationCacheEXT*                 pSrcCaches);
VKAPI_ATTR VkResult VKAPI_CALL GetValidationCacheDataEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        validationCache,
    size_t*                                     pDataSize,
    void*                                       pData);
VKAPI_ATTR VkResult VKAPI_CALL GetMemoryHostPointerPropertiesEXT(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
    const void*                                 pHostPointer,
    VkMemoryHostPointerPropertiesEXT*           pMemoryHostPointerProperties);
VKAPI_ATTR void VKAPI_CALL CmdWriteBufferMarkerAMD(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker);
// Map of all APIs to be intercepted by this layer
const std::unordered_map<std::string, void*> name_to_funcptr_map = {
    {"vkCreateInstance", (void*)vkCreateInstance},
    {"vkDestroyInstance", (void*)vkDestroyInstance},
    {"vkEnumeratePhysicalDevices", (void*)vkEnumeratePhysicalDevices},
    {"vkGetPhysicalDeviceFeatures", (void*)vkGetPhysicalDeviceFeatures},
    {"vkGetPhysicalDeviceFormatProperties", (void*)vkGetPhysicalDeviceFormatProperties},
    {"vkGetPhysicalDeviceImageFormatProperties", (void*)vkGetPhysicalDeviceImageFormatProperties},
    {"vkGetPhysicalDeviceProperties", (void*)vkGetPhysicalDeviceProperties},
    {"vkGetPhysicalDeviceQueueFamilyProperties", (void*)vkGetPhysicalDeviceQueueFamilyProperties},
    {"vkGetPhysicalDeviceMemoryProperties", (void*)vkGetPhysicalDeviceMemoryProperties},
    {"vkCreateDevice", (void*)vkCreateDevice},
    {"vkDestroyDevice", (void*)vkDestroyDevice},
    {"vkGetDeviceQueue", (void*)vkGetDeviceQueue},
    {"vkQueueSubmit", (void*)vkQueueSubmit},
    {"vkQueueWaitIdle", (void*)vkQueueWaitIdle},
    {"vkDeviceWaitIdle", (void*)vkDeviceWaitIdle},
    {"vkAllocateMemory", (void*)vkAllocateMemory},
    {"vkFreeMemory", (void*)vkFreeMemory},
    {"vkMapMemory", (void*)vkMapMemory},
    {"vkUnmapMemory", (void*)vkUnmapMemory},
    {"vkFlushMappedMemoryRanges", (void*)vkFlushMappedMemoryRanges},
    {"vkInvalidateMappedMemoryRanges", (void*)vkInvalidateMappedMemoryRanges},
    {"vkGetDeviceMemoryCommitment", (void*)vkGetDeviceMemoryCommitment},
    {"vkBindBufferMemory", (void*)vkBindBufferMemory},
    {"vkBindImageMemory", (void*)vkBindImageMemory},
    {"vkGetBufferMemoryRequirements", (void*)vkGetBufferMemoryRequirements},
    {"vkGetImageMemoryRequirements", (void*)vkGetImageMemoryRequirements},
    {"vkGetImageSparseMemoryRequirements", (void*)vkGetImageSparseMemoryRequirements},
    {"vkGetPhysicalDeviceSparseImageFormatProperties", (void*)vkGetPhysicalDeviceSparseImageFormatProperties},
    {"vkQueueBindSparse", (void*)vkQueueBindSparse},
    {"vkCreateFence", (void*)vkCreateFence},
    {"vkDestroyFence", (void*)vkDestroyFence},
    {"vkResetFences", (void*)vkResetFences},
    {"vkGetFenceStatus", (void*)vkGetFenceStatus},
    {"vkWaitForFences", (void*)vkWaitForFences},
    {"vkCreateSemaphore", (void*)vkCreateSemaphore},
    {"vkDestroySemaphore", (void*)vkDestroySemaphore},
    {"vkCreateEvent", (void*)vkCreateEvent},
    {"vkDestroyEvent", (void*)vkDestroyEvent},
    {"vkGetEventStatus", (void*)vkGetEventStatus},
    {"vkSetEvent", (void*)vkSetEvent},
    {"vkResetEvent", (void*)vkResetEvent},
    {"vkCreateQueryPool", (void*)vkCreateQueryPool},
    {"vkDestroyQueryPool", (void*)vkDestroyQueryPool},
    {"vkGetQueryPoolResults", (void*)vkGetQueryPoolResults},
    {"vkCreateBuffer", (void*)vkCreateBuffer},
    {"vkDestroyBuffer", (void*)vkDestroyBuffer},
    {"vkCreateBufferView", (void*)vkCreateBufferView},
    {"vkDestroyBufferView", (void*)vkDestroyBufferView},
    {"vkCreateImage", (void*)vkCreateImage},
    {"vkDestroyImage", (void*)vkDestroyImage},
    {"vkGetImageSubresourceLayout", (void*)vkGetImageSubresourceLayout},
    {"vkCreateImageView", (void*)vkCreateImageView},
    {"vkDestroyImageView", (void*)vkDestroyImageView},
    {"vkCreateShaderModule", (void*)vkCreateShaderModule},
    {"vkDestroyShaderModule", (void*)vkDestroyShaderModule},
    {"vkCreatePipelineCache", (void*)vkCreatePipelineCache},
    {"vkDestroyPipelineCache", (void*)vkDestroyPipelineCache},
    {"vkGetPipelineCacheData", (void*)vkGetPipelineCacheData},
    {"vkMergePipelineCaches", (void*)vkMergePipelineCaches},
    {"vkCreateGraphicsPipelines", (void*)vkCreateGraphicsPipelines},
    {"vkCreateComputePipelines", (void*)vkCreateComputePipelines},
    {"vkDestroyPipeline", (void*)vkDestroyPipeline},
    {"vkCreatePipelineLayout", (void*)vkCreatePipelineLayout},
    {"vkDestroyPipelineLayout", (void*)vkDestroyPipelineLayout},
    {"vkCreateSampler", (void*)vkCreateSampler},
    {"vkDestroySampler", (void*)vkDestroySampler},
    {"vkCreateDescriptorSetLayout", (void*)vkCreateDescriptorSetLayout},
    {"vkDestroyDescriptorSetLayout", (void*)vkDestroyDescriptorSetLayout},
    {"vkCreateDescriptorPool", (void*)vkCreateDescriptorPool},
    {"vkDestroyDescriptorPool", (void*)vkDestroyDescriptorPool},
    {"vkResetDescriptorPool", (void*)vkResetDescriptorPool},
    {"vkAllocateDescriptorSets", (void*)vkAllocateDescriptorSets},
    {"vkFreeDescriptorSets", (void*)vkFreeDescriptorSets},
    {"vkUpdateDescriptorSets", (void*)vkUpdateDescriptorSets},
    {"vkCreateFramebuffer", (void*)vkCreateFramebuffer},
    {"vkDestroyFramebuffer", (void*)vkDestroyFramebuffer},
    {"vkCreateRenderPass", (void*)vkCreateRenderPass},
    {"vkDestroyRenderPass", (void*)vkDestroyRenderPass},
    {"vkGetRenderAreaGranularity", (void*)vkGetRenderAreaGranularity},
    {"vkCreateCommandPool", (void*)vkCreateCommandPool},
    {"vkDestroyCommandPool", (void*)vkDestroyCommandPool},
    {"vkResetCommandPool", (void*)vkResetCommandPool},
    {"vkAllocateCommandBuffers", (void*)vkAllocateCommandBuffers},
    {"vkFreeCommandBuffers", (void*)vkFreeCommandBuffers},
    {"vkBeginCommandBuffer", (void*)vkBeginCommandBuffer},
    {"vkEndCommandBuffer", (void*)vkEndCommandBuffer},
    {"vkResetCommandBuffer", (void*)vkResetCommandBuffer},
    {"vkCmdBindPipeline", (void*)vkCmdBindPipeline},
    {"vkCmdSetViewport", (void*)vkCmdSetViewport},
    {"vkCmdSetScissor", (void*)vkCmdSetScissor},
    {"vkCmdSetLineWidth", (void*)vkCmdSetLineWidth},
    {"vkCmdSetDepthBias", (void*)vkCmdSetDepthBias},
    {"vkCmdSetBlendConstants", (void*)vkCmdSetBlendConstants},
    {"vkCmdSetDepthBounds", (void*)vkCmdSetDepthBounds},
    {"vkCmdSetStencilCompareMask", (void*)vkCmdSetStencilCompareMask},
    {"vkCmdSetStencilWriteMask", (void*)vkCmdSetStencilWriteMask},
    {"vkCmdSetStencilReference", (void*)vkCmdSetStencilReference},
    {"vkCmdBindDescriptorSets", (void*)vkCmdBindDescriptorSets},
    {"vkCmdBindIndexBuffer", (void*)vkCmdBindIndexBuffer},
    {"vkCmdBindVertexBuffers", (void*)vkCmdBindVertexBuffers},
    {"vkCmdDraw", (void*)vkCmdDraw},
    {"vkCmdDrawIndexed", (void*)vkCmdDrawIndexed},
    {"vkCmdDrawIndirect", (void*)vkCmdDrawIndirect},
    {"vkCmdDrawIndexedIndirect", (void*)vkCmdDrawIndexedIndirect},
    {"vkCmdDispatch", (void*)vkCmdDispatch},
    {"vkCmdDispatchIndirect", (void*)vkCmdDispatchIndirect},
    {"vkCmdCopyBuffer", (void*)vkCmdCopyBuffer},
    {"vkCmdCopyImage", (void*)vkCmdCopyImage},
    {"vkCmdBlitImage", (void*)vkCmdBlitImage},
    {"vkCmdCopyBufferToImage", (void*)vkCmdCopyBufferToImage},
    {"vkCmdCopyImageToBuffer", (void*)vkCmdCopyImageToBuffer},
    {"vkCmdUpdateBuffer", (void*)vkCmdUpdateBuffer},
    {"vkCmdFillBuffer", (void*)vkCmdFillBuffer},
    {"vkCmdClearColorImage", (void*)vkCmdClearColorImage},
    {"vkCmdClearDepthStencilImage", (void*)vkCmdClearDepthStencilImage},
    {"vkCmdClearAttachments", (void*)vkCmdClearAttachments},
    {"vkCmdResolveImage", (void*)vkCmdResolveImage},
    {"vkCmdSetEvent", (void*)vkCmdSetEvent},
    {"vkCmdResetEvent", (void*)vkCmdResetEvent},
    {"vkCmdWaitEvents", (void*)vkCmdWaitEvents},
    {"vkCmdPipelineBarrier", (void*)vkCmdPipelineBarrier},
    {"vkCmdBeginQuery", (void*)vkCmdBeginQuery},
    {"vkCmdEndQuery", (void*)vkCmdEndQuery},
    {"vkCmdResetQueryPool", (void*)vkCmdResetQueryPool},
    {"vkCmdWriteTimestamp", (void*)vkCmdWriteTimestamp},
    {"vkCmdCopyQueryPoolResults", (void*)vkCmdCopyQueryPoolResults},
    {"vkCmdPushConstants", (void*)vkCmdPushConstants},
    {"vkCmdBeginRenderPass", (void*)vkCmdBeginRenderPass},
    {"vkCmdNextSubpass", (void*)vkCmdNextSubpass},
    {"vkCmdEndRenderPass", (void*)vkCmdEndRenderPass},
    {"vkCmdExecuteCommands", (void*)vkCmdExecuteCommands},
    {"vkDestroySurfaceKHR", (void*)vkDestroySurfaceKHR},
    {"vkGetPhysicalDeviceSurfaceSupportKHR", (void*)vkGetPhysicalDeviceSurfaceSupportKHR},
    {"vkGetPhysicalDeviceSurfaceCapabilitiesKHR", (void*)vkGetPhysicalDeviceSurfaceCapabilitiesKHR},
    {"vkGetPhysicalDeviceSurfaceFormatsKHR", (void*)vkGetPhysicalDeviceSurfaceFormatsKHR},
    {"vkGetPhysicalDeviceSurfacePresentModesKHR", (void*)vkGetPhysicalDeviceSurfacePresentModesKHR},
    {"vkCreateSwapchainKHR", (void*)vkCreateSwapchainKHR},
    {"vkDestroySwapchainKHR", (void*)vkDestroySwapchainKHR},
    {"vkGetSwapchainImagesKHR", (void*)vkGetSwapchainImagesKHR},
    {"vkAcquireNextImageKHR", (void*)vkAcquireNextImageKHR},
    {"vkQueuePresentKHR", (void*)vkQueuePresentKHR},
    {"vkGetPhysicalDeviceDisplayPropertiesKHR", (void*)vkGetPhysicalDeviceDisplayPropertiesKHR},
    {"vkGetPhysicalDeviceDisplayPlanePropertiesKHR", (void*)vkGetPhysicalDeviceDisplayPlanePropertiesKHR},
    {"vkGetDisplayPlaneSupportedDisplaysKHR", (void*)vkGetDisplayPlaneSupportedDisplaysKHR},
    {"vkGetDisplayModePropertiesKHR", (void*)vkGetDisplayModePropertiesKHR},
    {"vkCreateDisplayModeKHR", (void*)vkCreateDisplayModeKHR},
    {"vkGetDisplayPlaneCapabilitiesKHR", (void*)vkGetDisplayPlaneCapabilitiesKHR},
    {"vkCreateDisplayPlaneSurfaceKHR", (void*)vkCreateDisplayPlaneSurfaceKHR},
    {"vkCreateSharedSwapchainsKHR", (void*)vkCreateSharedSwapchainsKHR},
#ifdef VK_USE_PLATFORM_XLIB_KHR
    {"vkCreateXlibSurfaceKHR", (void*)vkCreateXlibSurfaceKHR},
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    {"vkGetPhysicalDeviceXlibPresentationSupportKHR", (void*)vkGetPhysicalDeviceXlibPresentationSupportKHR},
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    {"vkCreateXcbSurfaceKHR", (void*)vkCreateXcbSurfaceKHR},
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    {"vkGetPhysicalDeviceXcbPresentationSupportKHR", (void*)vkGetPhysicalDeviceXcbPresentationSupportKHR},
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    {"vkCreateWaylandSurfaceKHR", (void*)vkCreateWaylandSurfaceKHR},
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    {"vkGetPhysicalDeviceWaylandPresentationSupportKHR", (void*)vkGetPhysicalDeviceWaylandPresentationSupportKHR},
#endif
#ifdef VK_USE_PLATFORM_MIR_KHR
    {"vkCreateMirSurfaceKHR", (void*)vkCreateMirSurfaceKHR},
#endif
#ifdef VK_USE_PLATFORM_MIR_KHR
    {"vkGetPhysicalDeviceMirPresentationSupportKHR", (void*)vkGetPhysicalDeviceMirPresentationSupportKHR},
#endif
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    {"vkCreateAndroidSurfaceKHR", (void*)vkCreateAndroidSurfaceKHR},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkCreateWin32SurfaceKHR", (void*)vkCreateWin32SurfaceKHR},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetPhysicalDeviceWin32PresentationSupportKHR", (void*)vkGetPhysicalDeviceWin32PresentationSupportKHR},
#endif
    {"vkGetPhysicalDeviceFeatures2KHR", (void*)vkGetPhysicalDeviceFeatures2KHR},
    {"vkGetPhysicalDeviceProperties2KHR", (void*)vkGetPhysicalDeviceProperties2KHR},
    {"vkGetPhysicalDeviceFormatProperties2KHR", (void*)vkGetPhysicalDeviceFormatProperties2KHR},
    {"vkGetPhysicalDeviceImageFormatProperties2KHR", (void*)vkGetPhysicalDeviceImageFormatProperties2KHR},
    {"vkGetPhysicalDeviceQueueFamilyProperties2KHR", (void*)vkGetPhysicalDeviceQueueFamilyProperties2KHR},
    {"vkGetPhysicalDeviceMemoryProperties2KHR", (void*)vkGetPhysicalDeviceMemoryProperties2KHR},
    {"vkGetPhysicalDeviceSparseImageFormatProperties2KHR", (void*)vkGetPhysicalDeviceSparseImageFormatProperties2KHR},
    {"vkTrimCommandPoolKHR", (void*)vkTrimCommandPoolKHR},
    {"vkGetPhysicalDeviceExternalBufferPropertiesKHR", (void*)vkGetPhysicalDeviceExternalBufferPropertiesKHR},
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetMemoryWin32HandleKHR", (void*)vkGetMemoryWin32HandleKHR},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetMemoryWin32HandlePropertiesKHR", (void*)vkGetMemoryWin32HandlePropertiesKHR},
#endif
    {"vkGetMemoryFdKHR", (void*)vkGetMemoryFdKHR},
    {"vkGetMemoryFdPropertiesKHR", (void*)vkGetMemoryFdPropertiesKHR},
    {"vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", (void*)vkGetPhysicalDeviceExternalSemaphorePropertiesKHR},
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkImportSemaphoreWin32HandleKHR", (void*)vkImportSemaphoreWin32HandleKHR},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetSemaphoreWin32HandleKHR", (void*)vkGetSemaphoreWin32HandleKHR},
#endif
    {"vkImportSemaphoreFdKHR", (void*)vkImportSemaphoreFdKHR},
    {"vkGetSemaphoreFdKHR", (void*)vkGetSemaphoreFdKHR},
    {"vkCmdPushDescriptorSetKHR", (void*)vkCmdPushDescriptorSetKHR},
    {"vkCreateDescriptorUpdateTemplateKHR", (void*)vkCreateDescriptorUpdateTemplateKHR},
    {"vkDestroyDescriptorUpdateTemplateKHR", (void*)vkDestroyDescriptorUpdateTemplateKHR},
    {"vkUpdateDescriptorSetWithTemplateKHR", (void*)vkUpdateDescriptorSetWithTemplateKHR},
    {"vkCmdPushDescriptorSetWithTemplateKHR", (void*)vkCmdPushDescriptorSetWithTemplateKHR},
    {"vkGetSwapchainStatusKHR", (void*)vkGetSwapchainStatusKHR},
    {"vkGetPhysicalDeviceExternalFencePropertiesKHR", (void*)vkGetPhysicalDeviceExternalFencePropertiesKHR},
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkImportFenceWin32HandleKHR", (void*)vkImportFenceWin32HandleKHR},
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetFenceWin32HandleKHR", (void*)vkGetFenceWin32HandleKHR},
#endif
    {"vkImportFenceFdKHR", (void*)vkImportFenceFdKHR},
    {"vkGetFenceFdKHR", (void*)vkGetFenceFdKHR},
    {"vkGetPhysicalDeviceSurfaceCapabilities2KHR", (void*)vkGetPhysicalDeviceSurfaceCapabilities2KHR},
    {"vkGetPhysicalDeviceSurfaceFormats2KHR", (void*)vkGetPhysicalDeviceSurfaceFormats2KHR},
    {"vkGetImageMemoryRequirements2KHR", (void*)vkGetImageMemoryRequirements2KHR},
    {"vkGetBufferMemoryRequirements2KHR", (void*)vkGetBufferMemoryRequirements2KHR},
    {"vkGetImageSparseMemoryRequirements2KHR", (void*)vkGetImageSparseMemoryRequirements2KHR},
    {"vkCreateSamplerYcbcrConversionKHR", (void*)vkCreateSamplerYcbcrConversionKHR},
    {"vkDestroySamplerYcbcrConversionKHR", (void*)vkDestroySamplerYcbcrConversionKHR},
    {"vkBindBufferMemory2KHR", (void*)vkBindBufferMemory2KHR},
    {"vkBindImageMemory2KHR", (void*)vkBindImageMemory2KHR},
    {"vkCreateDebugReportCallbackEXT", (void*)vkCreateDebugReportCallbackEXT},
    {"vkDestroyDebugReportCallbackEXT", (void*)vkDestroyDebugReportCallbackEXT},
    {"vkDebugReportMessageEXT", (void*)vkDebugReportMessageEXT},
    {"vkDebugMarkerSetObjectTagEXT", (void*)vkDebugMarkerSetObjectTagEXT},
    {"vkDebugMarkerSetObjectNameEXT", (void*)vkDebugMarkerSetObjectNameEXT},
    {"vkCmdDebugMarkerBeginEXT", (void*)vkCmdDebugMarkerBeginEXT},
    {"vkCmdDebugMarkerInsertEXT", (void*)vkCmdDebugMarkerInsertEXT},
    {"vkCmdDrawIndirectCountAMD", (void*)vkCmdDrawIndirectCountAMD},
    {"vkCmdDrawIndexedIndirectCountAMD", (void*)vkCmdDrawIndexedIndirectCountAMD},
    {"vkGetShaderInfoAMD", (void*)vkGetShaderInfoAMD},
    {"vkGetPhysicalDeviceExternalImageFormatPropertiesNV", (void*)vkGetPhysicalDeviceExternalImageFormatPropertiesNV},
#ifdef VK_USE_PLATFORM_WIN32_KHR
    {"vkGetMemoryWin32HandleNV", (void*)vkGetMemoryWin32HandleNV},
#endif
    {"vkGetDeviceGroupPeerMemoryFeaturesKHX", (void*)vkGetDeviceGroupPeerMemoryFeaturesKHX},
    {"vkCmdSetDeviceMaskKHX", (void*)vkCmdSetDeviceMaskKHX},
    {"vkCmdDispatchBaseKHX", (void*)vkCmdDispatchBaseKHX},
    {"vkGetDeviceGroupPresentCapabilitiesKHX", (void*)vkGetDeviceGroupPresentCapabilitiesKHX},
    {"vkGetDeviceGroupSurfacePresentModesKHX", (void*)vkGetDeviceGroupSurfacePresentModesKHX},
    {"vkGetPhysicalDevicePresentRectanglesKHX", (void*)vkGetPhysicalDevicePresentRectanglesKHX},
    {"vkAcquireNextImage2KHX", (void*)vkAcquireNextImage2KHX},
#ifdef VK_USE_PLATFORM_VI_NN
    {"vkCreateViSurfaceNN", (void*)vkCreateViSurfaceNN},
#endif
    {"vkEnumeratePhysicalDeviceGroupsKHX", (void*)vkEnumeratePhysicalDeviceGroupsKHX},
    {"vkCmdProcessCommandsNVX", (void*)vkCmdProcessCommandsNVX},
    {"vkCmdReserveSpaceForCommandsNVX", (void*)vkCmdReserveSpaceForCommandsNVX},
    {"vkCreateIndirectCommandsLayoutNVX", (void*)vkCreateIndirectCommandsLayoutNVX},
    {"vkDestroyIndirectCommandsLayoutNVX", (void*)vkDestroyIndirectCommandsLayoutNVX},
    {"vkCreateObjectTableNVX", (void*)vkCreateObjectTableNVX},
    {"vkDestroyObjectTableNVX", (void*)vkDestroyObjectTableNVX},
    {"vkRegisterObjectsNVX", (void*)vkRegisterObjectsNVX},
    {"vkUnregisterObjectsNVX", (void*)vkUnregisterObjectsNVX},
    {"vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX", (void*)vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX},
    {"vkCmdSetViewportWScalingNV", (void*)vkCmdSetViewportWScalingNV},
    {"vkReleaseDisplayEXT", (void*)vkReleaseDisplayEXT},
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    {"vkAcquireXlibDisplayEXT", (void*)vkAcquireXlibDisplayEXT},
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    {"vkGetRandROutputDisplayEXT", (void*)vkGetRandROutputDisplayEXT},
#endif
    {"vkGetPhysicalDeviceSurfaceCapabilities2EXT", (void*)vkGetPhysicalDeviceSurfaceCapabilities2EXT},
    {"vkDisplayPowerControlEXT", (void*)vkDisplayPowerControlEXT},
    {"vkRegisterDeviceEventEXT", (void*)vkRegisterDeviceEventEXT},
    {"vkRegisterDisplayEventEXT", (void*)vkRegisterDisplayEventEXT},
    {"vkGetSwapchainCounterEXT", (void*)vkGetSwapchainCounterEXT},
    {"vkGetRefreshCycleDurationGOOGLE", (void*)vkGetRefreshCycleDurationGOOGLE},
    {"vkGetPastPresentationTimingGOOGLE", (void*)vkGetPastPresentationTimingGOOGLE},
    {"vkCmdSetDiscardRectangleEXT", (void*)vkCmdSetDiscardRectangleEXT},
    {"vkSetHdrMetadataEXT", (void*)vkSetHdrMetadataEXT},
#ifdef VK_USE_PLATFORM_IOS_MVK
    {"vkCreateIOSSurfaceMVK", (void*)vkCreateIOSSurfaceMVK},
#endif
#ifdef VK_USE_PLATFORM_MACOS_MVK
    {"vkCreateMacOSSurfaceMVK", (void*)vkCreateMacOSSurfaceMVK},
#endif
    {"vkCmdSetSampleLocationsEXT", (void*)vkCmdSetSampleLocationsEXT},
    {"vkGetPhysicalDeviceMultisamplePropertiesEXT", (void*)vkGetPhysicalDeviceMultisamplePropertiesEXT},
    {"vkCreateValidationCacheEXT", (void*)vkCreateValidationCacheEXT},
    {"vkDestroyValidationCacheEXT", (void*)vkDestroyValidationCacheEXT},
    {"vkMergeValidationCachesEXT", (void*)vkMergeValidationCachesEXT},
    {"vkGetValidationCacheDataEXT", (void*)vkGetValidationCacheDataEXT},
    {"vkGetMemoryHostPointerPropertiesEXT", (void*)vkGetMemoryHostPointerPropertiesEXT},
    {"vkCmdWriteBufferMarkerAMD", (void*)vkCmdWriteBufferMarkerAMD},
};


} // namespace parameter_validation
